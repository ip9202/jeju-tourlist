# "동네물어봐" 컴포넌트 구조 설계서

## 📋 목차
1. [컴포넌트 아키텍처 개요](#-컴포넌트-아키텍처-개요)
2. [여행 전 단계 컴포넌트](#-여행-전-단계-컴포넌트)
3. [여행 중 단계 컴포넌트](#-여행-중-단계-컴포넌트)
4. [여행 후 단계 컴포넌트](#-여행-후-단계-컴포넌트)
5. [공통 컴포넌트](#-공통-컴포넌트)
6. [상태 관리 설계](#-상태-관리-설계)
7. [컴포넌트 라이프사이클](#-컴포넌트-라이프사이클)

---

## 🏗️ 컴포넌트 아키텍처 개요

### 설계 원칙
1. **단계별 특화**: 여행 전-중-후 각 단계에 최적화된 컴포넌트
2. **재사용성**: 공통 기능은 재사용 가능한 컴포넌트로 추상화
3. **반응형**: 웹/모바일 모든 플랫폼에서 일관된 경험
4. **성능 최적화**: 지연 로딩 및 메모이제이션 적용
5. **접근성**: WCAG 2.1 AA 기준 준수

### 폴더 구조

```
src/
├── components/
│   ├── pre-trip/          # 여행 전 특화 컴포넌트
│   ├── during-trip/       # 여행 중 특화 컴포넌트
│   ├── post-trip/         # 여행 후 특화 컴포넌트
│   ├── shared/            # 공통 컴포넌트
│   ├── ui/                # 기본 UI 컴포넌트
│   └── layout/            # 레이아웃 컴포넌트
├── hooks/                 # 커스텀 훅
├── context/               # 컨텍스트 (상태 관리)
├── utils/                 # 유틸리티 함수
└── types/                 # TypeScript 타입 정의
```

---

## 🛣️ 여행 전 단계 컴포넌트 (Pre-Trip)

### 핵심 목표
- 상세한 계획 수립 지원
- 풍부한 정보 제공
- 멀티태스킹 지원
- 북마크 및 저장 기능

### 1. PreTripLanding 컴포넌트

```typescript
// components/pre-trip/PreTripLanding.tsx
interface PreTripLandingProps {
  user?: User;
  onQuestionCreate: (question: Question) => void;
}

const PreTripLanding: React.FC<PreTripLandingProps> = ({
  user,
  onQuestionCreate
}) => {
  return (
    <div className="pre-trip-landing">
      <HeroSection />
      <QuickSearchBar onSearch={handleSearch} />
      <PopularQuestions />
      <RegionalStats />
      <TrustIndicators />
    </div>
  );
};

// 하위 컴포넌트들
const HeroSection = () => (
  <section className="hero">
    <h1>제주 현지인이 답하는 여행 Q&A</h1>
    <p>궁금하면 동네 사람에게 물어봐!</p>
    <SearchPrompt />
  </section>
);

const SearchPrompt = () => (
  <div className="search-prompt">
    <input
      placeholder="3박4일 가족여행, 아이와 함께 가기 좋은 곳 추천..."
      className="hero-search"
    />
    <button>질문하기</button>
  </div>
);
```

### 2. PlanningQuestionComposer 컴포넌트

```typescript
// components/pre-trip/PlanningQuestionComposer.tsx
interface QuestionComposerProps {
  onSubmit: (question: QuestionData) => void;
  onSaveDraft: (draft: QuestionDraft) => void;
}

const PlanningQuestionComposer: React.FC<QuestionComposerProps> = ({
  onSubmit,
  onSaveDraft
}) => {
  const [step, setStep] = useState(1);
  const [questionData, setQuestionData] = useState<QuestionData>({
    travelInfo: null,
    content: '',
    tags: [],
    preferences: {}
  });

  return (
    <div className="planning-composer">
      <ProgressIndicator currentStep={step} totalSteps={3} />

      {step === 1 && (
        <TravelInfoStep
          data={questionData.travelInfo}
          onChange={updateTravelInfo}
          onNext={() => setStep(2)}
        />
      )}

      {step === 2 && (
        <ContentStep
          content={questionData.content}
          tags={questionData.tags}
          onChange={updateContent}
          onNext={() => setStep(3)}
          onPrev={() => setStep(1)}
        />
      )}

      {step === 3 && (
        <PreferencesStep
          preferences={questionData.preferences}
          onChange={updatePreferences}
          onSubmit={handleSubmit}
          onPrev={() => setStep(2)}
        />
      )}
    </div>
  );
};

// 각 단계별 컴포넌트
const TravelInfoStep: React.FC<TravelInfoStepProps> = ({
  data, onChange, onNext
}) => (
  <div className="travel-info-step">
    <h2>여행 기본 정보</h2>
    <DateRangePicker
      value={data?.dates}
      onChange={(dates) => onChange({ ...data, dates })}
    />
    <CompanionSelector
      value={data?.companions}
      onChange={(companions) => onChange({ ...data, companions })}
    />
    <BudgetSelector
      value={data?.budget}
      onChange={(budget) => onChange({ ...data, budget })}
    />
    <RegionSelector
      value={data?.regions}
      onChange={(regions) => onChange({ ...data, regions })}
    />
    <button onClick={onNext}>다음 단계</button>
  </div>
);
```

### 3. DetailedQuestionFeed 컴포넌트

```typescript
// components/pre-trip/DetailedQuestionFeed.tsx
const DetailedQuestionFeed: React.FC = () => {
  return (
    <div className="detailed-feed">
      <FilterSidebar />
      <QuestionGrid />
      <BookmarkPanel />
    </div>
  );
};

const FilterSidebar = () => (
  <aside className="filter-sidebar">
    <SearchFilters />
    <CategoryFilter />
    <RegionFilter />
    <TimeFilter />
    <AnswerStatusFilter />
  </aside>
);

const QuestionGrid = () => {
  const { questions, loading } = useQuestions();

  return (
    <main className="question-grid">
      {questions.map(question => (
        <QuestionCard
          key={question.id}
          question={question}
          variant="detailed"
        />
      ))}
    </main>
  );
};
```

---

## 📱 여행 중 단계 컴포넌트 (During-Trip)

### 핵심 목표
- 즉시성 중심 디자인
- 위치 기반 기능
- 간편한 입력 방식
- 긴급 상황 대응

### 1. MobileUrgentHome 컴포넌트

```typescript
// components/during-trip/MobileUrgentHome.tsx
const MobileUrgentHome: React.FC = () => {
  const { currentLocation } = useLocation();
  const { nearbyQuestions } = useNearbyQuestions(currentLocation);

  return (
    <div className="mobile-urgent-home">
      <LocationHeader location={currentLocation} />
      <UrgentActionPanel />
      <QuickQuestionButtons />
      <VoiceQuestionFAB />
      <NearbyQuestionsFeed questions={nearbyQuestions} />
    </div>
  );
};

const UrgentActionPanel = () => (
  <section className="urgent-panel">
    <h2>🚨 지금 당장 도움이 필요해요!</h2>
    <ActionGrid>
      <ActionButton
        icon="🍜"
        label="맛집"
        urgency="high"
        action={() => openQuickQuestion('restaurant')}
      />
      <ActionButton
        icon="☔"
        label="비피할곳"
        urgency="high"
        action={() => openQuickQuestion('shelter')}
      />
      <ActionButton
        icon="🚗"
        label="교통문제"
        urgency="high"
        action={() => openQuickQuestion('transport')}
      />
      <ActionButton
        icon="🏥"
        label="응급상황"
        urgency="critical"
        action={() => openQuickQuestion('emergency')}
      />
    </ActionGrid>
  </section>
);
```

### 2. VoiceQuestionComposer 컴포넌트

```typescript
// components/during-trip/VoiceQuestionComposer.tsx
const VoiceQuestionComposer: React.FC = () => {
  const [isRecording, setIsRecording] = useState(false);
  const [transcript, setTranscript] = useState('');
  const [autoTags, setAutoTags] = useState<string[]>([]);

  const { startRecording, stopRecording } = useSpeechRecognition({
    onResult: handleSpeechResult,
    onError: handleSpeechError
  });

  const handleSpeechResult = (result: string) => {
    setTranscript(result);
    // 자동 태그 및 위치 추출
    const tags = extractTagsFromSpeech(result);
    const location = detectLocationFromSpeech(result);
    setAutoTags(tags);
  };

  return (
    <div className="voice-composer">
      <RecordingIndicator isActive={isRecording} />

      <VoiceRecordButton
        isRecording={isRecording}
        onStart={() => {
          setIsRecording(true);
          startRecording();
        }}
        onStop={() => {
          setIsRecording(false);
          stopRecording();
        }}
      />

      {transcript && (
        <TranscriptEditor
          text={transcript}
          autoTags={autoTags}
          onEdit={setTranscript}
          onTagsChange={setAutoTags}
        />
      )}

      <QuickSubmitPanel
        content={transcript}
        tags={autoTags}
        urgency="high"
        onSubmit={handleQuickSubmit}
      />
    </div>
  );
};

const RecordingIndicator = ({ isActive }: { isActive: boolean }) => (
  <div className={`recording-indicator ${isActive ? 'active' : ''}`}>
    {isActive && (
      <>
        <div className="pulse-animation" />
        <span>🎙️ 음성 인식 중...</span>
        <div className="wave-animation" />
      </>
    )}
  </div>
);
```

### 3. LocationBasedFeed 컴포넌트

```typescript
// components/during-trip/LocationBasedFeed.tsx
const LocationBasedFeed: React.FC = () => {
  const { location } = useLocation();
  const [radius, setRadius] = useState(1000); // 1km
  const { questions } = useNearbyQuestions(location, radius);

  return (
    <div className="location-feed">
      <LocationControls
        location={location}
        radius={radius}
        onRadiusChange={setRadius}
      />

      <RealTimeQuestionList>
        {questions.map(question => (
          <MobileQuestionCard
            key={question.id}
            question={question}
            distance={calculateDistance(location, question.location)}
            variant="urgent"
          />
        ))}
      </RealTimeQuestionList>
    </div>
  );
};

const MobileQuestionCard = ({ question, distance, variant }: Props) => (
  <div className={`mobile-question-card ${variant}`}>
    <QuestionHeader question={question} distance={distance} />
    <QuestionContent content={question.content} />
    <UrgencyIndicator urgency={question.urgency} />
    <QuickActionButtons questionId={question.id} />
  </div>
);
```

---

## 🏖️ 여행 후 단계 컴포넌트 (Post-Trip)

### 핵심 목표
- 경험 공유 촉진
- 답변자 전환 유도
- 커뮤니티 기여도 상승
- 재방문 유도

### 1. PostTripDashboard 컴포넌트

```typescript
// components/post-trip/PostTripDashboard.tsx
const PostTripDashboard: React.FC = () => {
  const { travelStats } = useUserTravelStats();
  const { pendingReviews } = usePendingReviews();
  const { suggestedQuestions } = useSuggestedQuestions();

  return (
    <div className="post-trip-dashboard">
      <TravelCompletionBanner stats={travelStats} />
      <ReviewRequestSection reviews={pendingReviews} />
      <AnswererTransitionSection suggestions={suggestedQuestions} />
      <CommunityContributionSection />
    </div>
  );
};

const TravelCompletionBanner = ({ stats }: { stats: TravelStats }) => (
  <section className="completion-banner">
    <h2>🎉 제주도 여행 다녀오셨네요!</h2>
    <TravelStatsGrid stats={stats} />
    <SatisfactionRating onRate={handleSatisfactionRate} />
  </section>
);

const TravelStatsGrid = ({ stats }: { stats: TravelStats }) => (
  <div className="stats-grid">
    <StatCard
      icon="💬"
      label="받은 답변"
      value={stats.receivedAnswers}
      color="blue"
    />
    <StatCard
      icon="✅"
      label="채택한 답변"
      value={stats.acceptedAnswers}
      color="green"
    />
    <StatCard
      icon="👥"
      label="도움받은 답변자"
      value={stats.helpfulAnswerers}
      color="purple"
    />
    <StatCard
      icon="⭐"
      label="여행 만족도"
      value={`${stats.satisfaction}/5`}
      color="orange"
    />
  </div>
);
```

### 2. AnswerReviewComposer 컴포넌트

```typescript
// components/post-trip/AnswerReviewComposer.tsx
const AnswerReviewComposer: React.FC<ReviewComposerProps> = ({
  answer,
  onSubmit
}) => {
  const [rating, setRating] = useState(0);
  const [review, setReview] = useState('');
  const [photos, setPhotos] = useState<File[]>([]);

  return (
    <div className="review-composer">
      <AnswerReference answer={answer} />

      <RatingSection
        rating={rating}
        onRatingChange={setRating}
      />

      <ReviewTextArea
        value={review}
        onChange={setReview}
        placeholder="실제로 어떠셨나요? 다른 여행자들에게 도움이 되는 후기를 남겨주세요!"
      />

      <PhotoUploadSection
        photos={photos}
        onPhotosChange={setPhotos}
        prompt="방문 인증샷을 올려주세요!"
      />

      <ThankYouMessageTemplates
        answerer={answer.user}
        onTemplateSelect={handleTemplateSelect}
      />

      <SubmitButton
        disabled={!rating || !review}
        onClick={() => onSubmit({ rating, review, photos })}
      >
        💝 후기 남기기
      </SubmitButton>
    </div>
  );
};

const ThankYouMessageTemplates = ({ answerer, onTemplateSelect }: Props) => {
  const templates = [
    "정말 도움됐어요! 감사합니다 🙏",
    "덕분에 좋은 시간 보냈어요! 고맙습니다 😊",
    "최고의 답변이었어요! 다음에도 부탁드려요 ✨",
    "현지인만 아는 정보 공유해주셔서 감사해요! 👍"
  ];

  return (
    <div className="thank-you-templates">
      <h4>{answerer.nickname}님에게 감사 인사</h4>
      <div className="template-buttons">
        {templates.map((template, index) => (
          <button
            key={index}
            className="template-btn"
            onClick={() => onTemplateSelect(template)}
          >
            {template}
          </button>
        ))}
      </div>
    </div>
  );
};
```

### 3. AnswererTransition 컴포넌트

```typescript
// components/post-trip/AnswererTransition.tsx
const AnswererTransition: React.FC = () => {
  const { suggestedQuestions } = useSuggestedQuestionsForUser();
  const { rewards } = useAnswererRewards();

  return (
    <div className="answerer-transition">
      <TransitionPrompt />
      <RewardsPreview rewards={rewards} />
      <SuggestedQuestionsList questions={suggestedQuestions} />
      <FirstAnswerIncentive />
    </div>
  );
};

const TransitionPrompt = () => (
  <section className="transition-prompt">
    <h3>🤝 이제 당신도 답변자가 되어보세요!</h3>
    <p>최근 제주도를 다녀온 생생한 경험을 다른 여행자들과 공유해보세요.</p>
  </section>
);

const SuggestedQuestionsList = ({ questions }: { questions: Question[] }) => (
  <div className="suggested-questions">
    <h4>🎯 당신이 답변할 수 있는 질문들</h4>
    {questions.map(question => (
      <SuggestedQuestionCard
        key={question.id}
        question={question}
        onAnswerStart={handleAnswerStart}
      />
    ))}
  </div>
);

const SuggestedQuestionCard = ({ question, onAnswerStart }: Props) => (
  <div className="suggested-question-card">
    <QuestionPreview question={question} />
    <MatchReasonBadge reason={question.matchReason} />
    <ActionButtons>
      <button
        className="answer-btn primary"
        onClick={() => onAnswerStart(question.id)}
      >
        ✍️ 답변 작성하기
      </button>
      <button className="save-btn secondary">
        📌 나중에 답변하기
      </button>
    </ActionButtons>
  </div>
);
```

---

## 🔄 공통 컴포넌트 (Shared)

### 1. MessageBubble 컴포넌트

```typescript
// components/shared/MessageBubble.tsx
interface MessageBubbleProps {
  type: 'question' | 'answer';
  user: User;
  content: string;
  timestamp: Date;
  images?: string[];
  tags?: string[];
  status?: MessageStatus;
  onAction?: (action: string) => void;
}

const MessageBubble: React.FC<MessageBubbleProps> = ({
  type,
  user,
  content,
  timestamp,
  images,
  tags,
  status,
  onAction
}) => {
  return (
    <div className={`message-bubble ${type}`}>
      <UserProfile user={user} />

      <MessageContent>
        <TextContent content={content} />
        {tags && <HashtagList tags={tags} />}
        {images && <ImageGallery images={images} />}
      </MessageContent>

      <MessageMeta>
        <Timestamp timestamp={timestamp} />
        <MessageStatus status={status} />
      </MessageMeta>

      <ActionButtons type={type} onAction={onAction} />
    </div>
  );
};

const ActionButtons = ({ type, onAction }: Props) => {
  if (type === 'question') {
    return (
      <div className="question-actions">
        <button onClick={() => onAction?.('reply')}>💬 답변</button>
        <button onClick={() => onAction?.('bookmark')}>📌 저장</button>
        <button onClick={() => onAction?.('share')}>📤 공유</button>
      </div>
    );
  }

  return (
    <div className="answer-actions">
      <LikeButton onLike={() => onAction?.('like')} />
      <AcceptButton onAccept={() => onAction?.('accept')} />
      <LocationButton onLocation={() => onAction?.('location')} />
      <SaveButton onSave={() => onAction?.('save')} />
    </div>
  );
};
```

### 2. HashtagSystem 컴포넌트

```typescript
// components/shared/HashtagSystem.tsx
const HashtagInput: React.FC<HashtagInputProps> = ({
  value,
  onChange,
  suggestions = [],
  autoComplete = true
}) => {
  const [input, setInput] = useState('');
  const [showSuggestions, setShowSuggestions] = useState(false);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newInput = e.target.value;
    setInput(newInput);

    if (autoComplete && newInput.includes('#')) {
      setShowSuggestions(true);
    }
  };

  const handleTagAdd = (tag: string) => {
    const newTags = [...value, tag];
    onChange(newTags);
    setInput('');
    setShowSuggestions(false);
  };

  return (
    <div className="hashtag-input">
      <input
        value={input}
        onChange={handleInputChange}
        placeholder="태그를 입력하세요... #제주맛집"
        className="tag-input"
      />

      {showSuggestions && (
        <HashtagSuggestions
          query={input}
          suggestions={suggestions}
          onSelect={handleTagAdd}
        />
      )}

      <HashtagDisplay tags={value} onRemove={handleTagRemove} />
    </div>
  );
};

const HashtagDisplay = ({ tags, onRemove }: Props) => (
  <div className="hashtag-display">
    {tags.map((tag, index) => (
      <HashtagChip
        key={index}
        tag={tag}
        category={categorizeTag(tag)}
        onRemove={() => onRemove(index)}
      />
    ))}
  </div>
);

const HashtagChip = ({ tag, category, onRemove }: Props) => (
  <span className={`hashtag-chip ${category}`}>
    {tag}
    <button className="remove-btn" onClick={onRemove}>×</button>
  </span>
);
```

### 3. RealTimeIndicators 컴포넌트

```typescript
// components/shared/RealTimeIndicators.tsx
const TypingIndicator: React.FC<TypingIndicatorProps> = ({
  typingUsers,
  visible
}) => {
  if (!visible || typingUsers.length === 0) return null;

  return (
    <div className="typing-indicator">
      <UserAvatars users={typingUsers} size="small" />
      <TypingAnimation />
      <span className="typing-text">
        {formatTypingText(typingUsers)}가 답변을 작성 중입니다...
      </span>
    </div>
  );
};

const TypingAnimation = () => (
  <div className="typing-animation">
    <span className="dot"></span>
    <span className="dot"></span>
    <span className="dot"></span>
  </div>
);

const OnlineStatus = ({ user, size = 'medium' }: Props) => (
  <div className={`online-status ${size}`}>
    <UserAvatar user={user} size={size} />
    <div className={`status-indicator ${user.isOnline ? 'online' : 'offline'}`} />
  </div>
);

const ReadStatus = ({ status }: { status: 'sent' | 'delivered' | 'read' }) => (
  <div className={`read-status ${status}`}>
    {status === 'sent' && <CheckIcon />}
    {status === 'delivered' && <DoubleCheckIcon />}
    {status === 'read' && <DoubleCheckIcon className="read" />}
  </div>
);
```

---

## 🗄️ 상태 관리 설계

### Context 기반 상태 관리

```typescript
// context/TripStageContext.tsx
interface TripStageContextType {
  currentStage: 'pre-trip' | 'during-trip' | 'post-trip';
  userLocation: Location | null;
  travelDates: DateRange | null;
  isUrgentMode: boolean;
  setStage: (stage: TripStage) => void;
  enableUrgentMode: () => void;
  disableUrgentMode: () => void;
}

export const TripStageProvider: React.FC<{ children: ReactNode }> = ({
  children
}) => {
  const [currentStage, setCurrentStage] = useState<TripStage>('pre-trip');
  const [isUrgentMode, setIsUrgentMode] = useState(false);
  const { location } = useLocation();

  // 자동 스테이지 감지
  useEffect(() => {
    if (location && isInJeju(location)) {
      setCurrentStage('during-trip');
    }
  }, [location]);

  const value = {
    currentStage,
    userLocation: location,
    isUrgentMode,
    setStage: setCurrentStage,
    enableUrgentMode: () => setIsUrgentMode(true),
    disableUrgentMode: () => setIsUrgentMode(false)
  };

  return (
    <TripStageContext.Provider value={value}>
      {children}
    </TripStageContext.Provider>
  );
};

// context/RealTimeContext.tsx
export const RealTimeProvider: React.FC<{ children: ReactNode }> = ({
  children
}) => {
  const { socket } = useSocket();
  const [typingUsers, setTypingUsers] = useState<TypingUser[]>([]);
  const [onlineUsers, setOnlineUsers] = useState<User[]>([]);

  useEffect(() => {
    socket?.on('user_typing', handleUserTyping);
    socket?.on('user_online', handleUserOnline);
    socket?.on('user_offline', handleUserOffline);

    return () => {
      socket?.off('user_typing');
      socket?.off('user_online');
      socket?.off('user_offline');
    };
  }, [socket]);

  const value = {
    typingUsers,
    onlineUsers,
    startTyping: (questionId: string) => {
      socket?.emit('typing_start', { questionId });
    },
    stopTyping: (questionId: string) => {
      socket?.emit('typing_stop', { questionId });
    }
  };

  return (
    <RealTimeContext.Provider value={value}>
      {children}
    </RealTimeContext.Provider>
  );
};
```

### 커스텀 훅

```typescript
// hooks/useTripStage.ts
export const useTripStage = () => {
  const context = useContext(TripStageContext);
  if (!context) {
    throw new Error('useTripStage must be used within TripStageProvider');
  }
  return context;
};

// hooks/useLocationBasedQuestions.ts
export const useLocationBasedQuestions = (
  location: Location | null,
  radius: number = 1000
) => {
  const [questions, setQuestions] = useState<Question[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!location) return;

    const fetchNearbyQuestions = async () => {
      setLoading(true);
      try {
        const response = await api.get('/questions/nearby', {
          params: {
            lat: location.latitude,
            lng: location.longitude,
            radius
          }
        });
        setQuestions(response.data);
      } catch (error) {
        console.error('Failed to fetch nearby questions:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchNearbyQuestions();
  }, [location, radius]);

  return { questions, loading };
};

// hooks/useVoiceInput.ts
export const useVoiceInput = () => {
  const [isRecording, setIsRecording] = useState(false);
  const [transcript, setTranscript] = useState('');
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const startRecording = () => {
    if (!('webkitSpeechRecognition' in window)) {
      alert('음성 인식이 지원되지 않는 브라우저입니다.');
      return;
    }

    const recognition = new window.webkitSpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = 'ko-KR';

    recognition.onstart = () => setIsRecording(true);
    recognition.onend = () => setIsRecording(false);
    recognition.onresult = (event) => {
      const lastResult = event.results[event.results.length - 1];
      if (lastResult.isFinal) {
        setTranscript(lastResult[0].transcript);
      }
    };

    recognitionRef.current = recognition;
    recognition.start();
  };

  const stopRecording = () => {
    recognitionRef.current?.stop();
  };

  return {
    isRecording,
    transcript,
    startRecording,
    stopRecording,
    clearTranscript: () => setTranscript('')
  };
};
```

---

## ⚡ 컴포넌트 라이프사이클 및 최적화

### 지연 로딩 (Lazy Loading)

```typescript
// 단계별 컴포넌트 지연 로딩
const PreTripComponents = lazy(() => import('../components/pre-trip'));
const DuringTripComponents = lazy(() => import('../components/during-trip'));
const PostTripComponents = lazy(() => import('../components/post-trip'));

const App: React.FC = () => {
  const { currentStage } = useTripStage();

  return (
    <div className="app">
      <Suspense fallback={<StageLoadingSpinner />}>
        {currentStage === 'pre-trip' && <PreTripComponents />}
        {currentStage === 'during-trip' && <DuringTripComponents />}
        {currentStage === 'post-trip' && <PostTripComponents />}
      </Suspense>
    </div>
  );
};
```

### 메모이제이션 최적화

```typescript
// 리렌더링 최적화
const MessageBubble = memo<MessageBubbleProps>(({
  type,
  user,
  content,
  timestamp,
  images,
  tags
}) => {
  // 메시지 내용이 변경되지 않으면 리렌더링 방지
  return (
    <div className={`message-bubble ${type}`}>
      {/* 컴포넌트 내용 */}
    </div>
  );
}, (prevProps, nextProps) => {
  return (
    prevProps.content === nextProps.content &&
    prevProps.timestamp === nextProps.timestamp &&
    prevProps.images?.length === nextProps.images?.length
  );
});

// 비용이 큰 계산 메모이제이션
const QuestionFeed = () => {
  const { questions } = useQuestions();

  const sortedQuestions = useMemo(() => {
    return questions
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
      .filter(q => q.status !== 'hidden');
  }, [questions]);

  return (
    <div className="question-feed">
      {sortedQuestions.map(question => (
        <QuestionCard key={question.id} question={question} />
      ))}
    </div>
  );
};
```

### 가상화 (Virtualization)

```typescript
// 긴 목록 가상화로 성능 최적화
import { FixedSizeList as List } from 'react-window';

const VirtualizedQuestionList = ({ questions }: Props) => {
  const Row = ({ index, style }: { index: number; style: CSSProperties }) => (
    <div style={style}>
      <QuestionCard question={questions[index]} />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={questions.length}
      itemSize={200}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

---

이 컴포넌트 구조 설계서는 실제 개발 시 각 컴포넌트의 역할과 구현 방향을 명확하게 제시합니다. 다음 단계로 메시지 스타일 인터페이스의 상세 상호작용 명세서를 작성하겠습니다.