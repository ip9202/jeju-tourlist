# "ë™ë„¤ë¬¼ì–´ë´" ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

## ğŸ“‹ ëª©ì°¨
1. [ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ê°œìš”](#-ì‹¤ì‹œê°„-ì‹œìŠ¤í…œ-ê°œìš”)
2. [Socket.io ê¸°ë°˜ ì•„í‚¤í…ì²˜](#-socketio-ê¸°ë°˜-ì•„í‚¤í…ì²˜)
3. [ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ì„¤ê³„](#-ì´ë²¤íŠ¸-ì‹œìŠ¤í…œ-ì„¤ê³„)
4. [ì‹¤ì‹œê°„ ì•Œë¦¼ ì‹œìŠ¤í…œ](#-ì‹¤ì‹œê°„-ì•Œë¦¼-ì‹œìŠ¤í…œ)
5. [í™•ì¥ì„± ë° ì„±ëŠ¥ ìµœì í™”](#-í™•ì¥ì„±-ë°-ì„±ëŠ¥-ìµœì í™”)
6. [ë³´ì•ˆ ë° ì•ˆì •ì„±](#-ë³´ì•ˆ-ë°-ì•ˆì •ì„±)
7. [ëª¨ë‹ˆí„°ë§ ë° ë””ë²„ê¹…](#-ëª¨ë‹ˆí„°ë§-ë°-ë””ë²„ê¹…)

---

## âš¡ ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ê°œìš”

### í•µì‹¬ ëª©í‘œ
- **ì´ˆì¦‰ì‹œì„±**: 10ë¶„ ë‚´ ì²« ë‹µë³€ ëª©í‘œ ë‹¬ì„± (ì œì£¼ë„ íŠ¹ì„± ë°˜ì˜)
- **ì‹¤ì‹œê°„ì„±**: íƒ€ì´í•‘, ë‹µë³€ ìˆ˜ì‹ , ìƒíƒœ ë³€í™” ì¦‰ì‹œ ë°˜ì˜
- **ìœ„ì¹˜ ê¸°ë°˜ ì¦‰ì‹œ ì•Œë¦¼**: GPS ê¸°ë°˜ ë°˜ê²½ 5km ë‚´ í˜„ì§€ì¸ ì¦‰ì‹œ ì•Œë¦¼
- **ì•ˆì •ì„±**: ì—°ê²° ëŠê¹€ ì‹œ ìë™ ì¬ì—°ê²° ë° ìƒíƒœ ë³µêµ¬
- **í™•ì¥ì„±**: ë™ì‹œ ì‚¬ìš©ì 1,000ëª… ì´ìƒ ì§€ì›

### ì‹¤ì‹œê°„ ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­

#### 1. ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ ì‹¤ì‹œê°„ ê¸°ëŠ¥
- íƒ€ì´í•‘ ì¸ë””ì¼€ì´í„° (ë‹µë³€ ì‘ì„± ì¤‘ í‘œì‹œ)
- ì‹¤ì‹œê°„ ë©”ì‹œì§€ ì „ì†¡/ìˆ˜ì‹ 
- ì½ìŒ ìƒíƒœ í‘œì‹œ (sent/delivered/read)
- ì˜¨ë¼ì¸ ìƒíƒœ í‘œì‹œ

#### 2. ì´ˆì¦‰ì‹œ ì•Œë¦¼ ì‹œìŠ¤í…œ
- **3ì´ˆ ì´ë‚´**: ìƒˆ ì§ˆë¬¸ ë“±ë¡ ì‹œ ë°˜ê²½ 5km ë‚´ í˜„ì§€ì¸ì—ê²Œ ì¦‰ì‹œ ì•Œë¦¼
- **1ì´ˆ ì´ë‚´**: ë‹µë³€ ìˆ˜ì‹  ì‹œ ì§ˆë¬¸ìì—ê²Œ ì‹¤ì‹œê°„ ì•Œë¦¼
- **ì¹´ì¹´ì˜¤í†¡ ìˆ˜ì¤€**: ì½ìŒ/ë¯¸ì½ìŒ ìƒíƒœ ì‹¤ì‹œê°„ ë™ê¸°í™”
- **ê¸´ê¸‰ ëª¨ë“œ**: ğŸš¨ ê¸´ê¸‰ ì§ˆë¬¸ ì‹œ ì§„ë™/ì‚¬ìš´ë“œ ì•Œë¦¼ ê°•ì œ ë°œì†¡
- **ìœ„ì¹˜ ê¸°ë°˜ ìš°ì„ ìˆœìœ„**: ê°€ê¹Œìš´ ê±°ë¦¬ ìˆœìœ¼ë¡œ ì•Œë¦¼ ìš°ì„ ë„ ì„¤ì •

#### 3. ì œì£¼ë„ íŠ¹í™” ìœ„ì¹˜ ê¸°ë°˜ ì‹œìŠ¤í…œ
- **ì´ˆì •ë°€ GPS**: 100m ë‹¨ìœ„ ìœ„ì¹˜ ê¸°ë°˜ ì•Œë¦¼ (ì œì£¼ ì‘ì€ ë™ë„¤ íŠ¹ì„±)
- **ì‹¤ì‹œê°„ ìœ„ì¹˜ ì¶”ì **: ì´ë™ ì¤‘ì—ë„ ëŠê¹€ ì—†ëŠ” ì•Œë¦¼ ìˆ˜ì‹ 
- **í•«ìŠ¤íŒŸ ê°ì§€**: ê´€ê´‘ì§€ ì§‘ì¤‘ ì§€ì—­ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- **ë™ë„¤ë³„ ì¦‰ì‹œ ì•Œë¦¼**: ì• ì›”, ì„±ì‚°, ì¤‘ë¬¸ ë“± ë™ë„¤ ë‹¨ìœ„ íƒ€ê²ŸíŒ…

---

## ğŸ”— Socket.io ê¸°ë°˜ ì•„í‚¤í…ì²˜

### ì‹œìŠ¤í…œ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ì›¹ í´ë¼ì´ì–¸íŠ¸   â”‚    â”‚   ëª¨ë°”ì¼ ì•±      â”‚    â”‚   ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ â”‚
â”‚   (Next.js)     â”‚    â”‚ (React Native)  â”‚    â”‚   (Next.js)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     Socket.io ì„œë²„        â”‚
                    â”‚   (Node.js + Express)     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     Redis Adapter         â”‚
                    â”‚  (í´ëŸ¬ìŠ¤í„°ë§ & ìºì‹±)      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    PostgreSQL DB          â”‚
                    â”‚  (ì˜êµ¬ ë°ì´í„° ì €ì¥)       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Socket.io ì„œë²„ êµ¬ì„±

```typescript
// server/socket/socketServer.ts
import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { createClient } from 'redis';

export class SocketServer {
  private io: Server;
  private redisClient;
  private redisAdapter;

  constructor(httpServer: any) {
    // Socket.io ì„œë²„ ì´ˆê¸°í™”
    this.io = new Server(httpServer, {
      cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
        methods: ['GET', 'POST'],
        credentials: true
      },
      pingTimeout: 60000,
      pingInterval: 25000,
      maxHttpBufferSize: 1e6, // 1MB
      transports: ['websocket', 'polling']
    });

    this.setupRedisAdapter();
    this.setupEventHandlers();
    this.setupRoomManagement();
  }

  private async setupRedisAdapter() {
    // Redis í´ëŸ¬ìŠ¤í„° ì–´ëŒ‘í„° ì„¤ì •
    this.redisClient = createClient({
      url: process.env.REDIS_URL || 'redis://localhost:6379'
    });

    const subClient = this.redisClient.duplicate();
    await Promise.all([
      this.redisClient.connect(),
      subClient.connect()
    ]);

    this.redisAdapter = createAdapter(this.redisClient, subClient);
    this.io.adapter(this.redisAdapter);
  }

  private setupEventHandlers() {
    this.io.on('connection', this.handleConnection.bind(this));
  }

  private handleConnection(socket: Socket) {
    console.log(`User connected: ${socket.id}`);

    // ì¸ì¦ ë¯¸ë“¤ì›¨ì–´
    this.authenticateSocket(socket);

    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡
    this.registerQuestionEvents(socket);
    this.registerAnswerEvents(socket);
    this.registerTypingEvents(socket);
    this.registerLocationEvents(socket);
    this.registerNotificationEvents(socket);

    // ì—°ê²° í•´ì œ ì²˜ë¦¬
    socket.on('disconnect', () => {
      this.handleDisconnection(socket);
    });
  }
}
```

### ì¸ì¦ ë° ì‚¬ìš©ì ì„¸ì…˜ ê´€ë¦¬

```typescript
// server/socket/middleware/auth.ts
export const authenticateSocket = async (socket: Socket, next: Function) => {
  try {
    const token = socket.handshake.auth.token;
    if (!token) {
      throw new Error('No token provided');
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!);
    const user = await User.findById(decoded.userId);

    if (!user) {
      throw new Error('User not found');
    }

    socket.userId = user.id;
    socket.user = user;
    next();
  } catch (error) {
    next(new Error('Authentication failed'));
  }
};

// ì‚¬ìš©ì ì„¸ì…˜ ê´€ë¦¬
export class UserSessionManager {
  private static sessions = new Map<string, UserSession>();

  static addSession(socket: Socket) {
    const session: UserSession = {
      socketId: socket.id,
      userId: socket.userId,
      connectedAt: new Date(),
      lastActivity: new Date(),
      rooms: new Set(),
      isOnline: true
    };

    this.sessions.set(socket.userId, session);
    this.broadcastUserOnline(socket.userId);
  }

  static removeSession(socket: Socket) {
    const session = this.sessions.get(socket.userId);
    if (session) {
      session.isOnline = false;
      this.broadcastUserOffline(socket.userId);
      this.sessions.delete(socket.userId);
    }
  }

  static updateActivity(userId: string) {
    const session = this.sessions.get(userId);
    if (session) {
      session.lastActivity = new Date();
    }
  }

  static getUserSession(userId: string): UserSession | null {
    return this.sessions.get(userId) || null;
  }

  private static broadcastUserOnline(userId: string) {
    // ê´€ë ¨ ë£¸ì— ì‚¬ìš©ì ì˜¨ë¼ì¸ ìƒíƒœ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    io.emit('user_online', { userId, timestamp: new Date() });
  }

  private static broadcastUserOffline(userId: string) {
    io.emit('user_offline', { userId, timestamp: new Date() });
  }
}
```

---

## ğŸ“¡ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ì„¤ê³„

### ì´ë²¤íŠ¸ ì¹´í…Œê³ ë¦¬

#### 1. ì§ˆë¬¸ ê´€ë ¨ ì´ë²¤íŠ¸

```typescript
// server/socket/events/questionEvents.ts
export class QuestionEvents {
  static register(socket: Socket) {
    // ì§ˆë¬¸ ë£¸ ì…ì¥
    socket.on('join_question', async (data: { questionId: string }) => {
      try {
        const { questionId } = data;
        const question = await Question.findById(questionId);

        if (!question) {
          socket.emit('error', { message: 'Question not found' });
          return;
        }

        // ì§ˆë¬¸ ë£¸ ì…ì¥
        socket.join(`question:${questionId}`);

        // í˜„ì¬ ì˜¨ë¼ì¸ ì‚¬ìš©ì ëª©ë¡ ì „ì†¡
        const onlineUsers = await this.getOnlineUsersInRoom(`question:${questionId}`);
        socket.emit('room_users', { questionId, users: onlineUsers });

        // ê¸°ì¡´ ë©”ì‹œì§€ ë¡œë“œ
        const messages = await this.loadQuestionMessages(questionId);
        socket.emit('question_messages', { questionId, messages });

      } catch (error) {
        socket.emit('error', { message: 'Failed to join question' });
      }
    });

    // ìƒˆ ì§ˆë¬¸ ë“±ë¡
    socket.on('create_question', async (data: CreateQuestionData) => {
      try {
        const question = await this.createQuestion(data, socket.userId);

        // ì§ˆë¬¸ìë¥¼ ì§ˆë¬¸ ë£¸ì— ì¶”ê°€
        socket.join(`question:${question.id}`);

        // íƒ€ê²Ÿ ë‹µë³€ìë“¤ì—ê²Œ ì•Œë¦¼
        await this.notifyTargetAnswerers(question);

        // ì„±ê³µ ì‘ë‹µ
        socket.emit('question_created', { question });

      } catch (error) {
        socket.emit('error', { message: 'Failed to create question' });
      }
    });
  }

  private static async createQuestion(data: CreateQuestionData, userId: string) {
    const question = await Question.create({
      ...data,
      userId,
      createdAt: new Date()
    });

    // í•´ì‹œíƒœê·¸ ì²˜ë¦¬
    if (data.hashtags?.length > 0) {
      await this.processHashtags(question.id, data.hashtags);
    }

    return question;
  }

  private static async notifyTargetAnswerers(question: Question) {
    // ì œì£¼ë„ íŠ¹í™” ì´ˆì¦‰ì‹œ ì•Œë¦¼ ì‹œìŠ¤í…œ
    await this.sendUltraFastNotifications(question);
  }

  private static async sendUltraFastNotifications(question: Question) {
    // 1ë‹¨ê³„: ì¦‰ì‹œ ì•Œë¦¼ (3ì´ˆ ì´ë‚´) - ë°˜ê²½ 2km ë‚´ ì˜¨ë¼ì¸ í˜„ì§€ì¸
    const immediateTargets = await this.findImmediateTargets(question.location, 2000);
    await this.sendBatchNotifications(immediateTargets, question, 'IMMEDIATE');

    // 2ë‹¨ê³„: ë¹ ë¥¸ ì•Œë¦¼ (30ì´ˆ ì´ë‚´) - ë°˜ê²½ 5km ë‚´ í˜„ì§€ì¸
    setTimeout(async () => {
      const quickTargets = await this.findQuickTargets(question.location, 5000);
      await this.sendBatchNotifications(quickTargets, question, 'QUICK');
    }, 3000);

    // 3ë‹¨ê³„: í™•ì¥ ì•Œë¦¼ (2ë¶„ ì´ë‚´) - ì œì£¼ ì „ì²´ ê´€ë ¨ ì „ë¬¸ê°€
    setTimeout(async () => {
      const extendedTargets = await this.findExpertTargets(question.hashtags);
      await this.sendBatchNotifications(extendedTargets, question, 'EXTENDED');
    }, 30000);

    // 4ë‹¨ê³„: ìµœì¢… ì•Œë¦¼ (5ë¶„ ì´ë‚´) - ì œì£¼ ì „ì²´ ë‹µë³€ì
    setTimeout(async () => {
      if (await this.hasNoAnswers(question.id)) {
        const allTargets = await this.findAllJejuAnswerers();
        await this.sendBatchNotifications(allTargets, question, 'FINAL');
      }
    }, 120000);
  }

  private static async findImmediateTargets(location: Location, radiusMeters: number) {
    return await User.find({
      isLocalVerified: true,
      isOnline: true,
      location: {
        $nearSphere: {
          $geometry: { type: 'Point', coordinates: [location.lng, location.lat] },
          $maxDistance: radiusMeters
        }
      },
      notificationSettings: { immediateAlerts: true }
    }).limit(10); // ìµœëŒ€ 10ëª…ì—ê²Œ ì¦‰ì‹œ ì•Œë¦¼
  }

  private static async sendBatchNotifications(
    targets: User[],
    question: Question,
    priority: 'IMMEDIATE' | 'QUICK' | 'EXTENDED' | 'FINAL'
  ) {
    const notificationData = {
      question: {
        id: question.id,
        title: question.title,
        location: question.location,
        hashtags: question.hashtags,
        urgency: question.urgency,
        createdAt: question.createdAt
      },
      priority,
      sound: priority === 'IMMEDIATE' ? 'urgent' : 'normal',
      vibration: priority === 'IMMEDIATE' ? 'strong' : 'light'
    };

    // ë³‘ë ¬ë¡œ ì•Œë¦¼ ì „ì†¡ (ì„±ëŠ¥ ìµœì í™”)
    const promises = targets.map(async (user) => {
      const session = UserSessionManager.getUserSession(user.id);
      if (session?.isOnline) {
        // Socket ì•Œë¦¼
        io.to(session.socketId).emit('new_question_notification', notificationData);

        // ê¸´ê¸‰í•œ ê²½ìš° í‘¸ì‹œ ì•Œë¦¼ë„ í•¨ê»˜ ì „ì†¡
        if (priority === 'IMMEDIATE' && question.urgency === 'urgent') {
          await PushNotificationService.sendUrgent(user.deviceToken, {
            title: 'ğŸš¨ ê¸´ê¸‰ ì§ˆë¬¸ì´ ë„ì°©í–ˆìŠµë‹ˆë‹¤!',
            body: question.title.substring(0, 50),
            data: { questionId: question.id }
          });
        }
      }
    });

    await Promise.allSettled(promises);

    console.log(`${priority} notifications sent to ${targets.length} users for question ${question.id}`);
  }
}
```

#### 2. ë‹µë³€ ê´€ë ¨ ì´ë²¤íŠ¸

```typescript
// server/socket/events/answerEvents.ts
export class AnswerEvents {
  static register(socket: Socket) {
    // ë‹µë³€ ì‘ì„±
    socket.on('create_answer', async (data: CreateAnswerData) => {
      try {
        const answer = await this.createAnswer(data, socket.userId);

        // ì§ˆë¬¸ ë£¸ì— ìƒˆ ë‹µë³€ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        socket.to(`question:${data.questionId}`).emit('new_answer', {
          answer: {
            id: answer.id,
            content: answer.content,
            user: answer.user,
            createdAt: answer.createdAt,
            images: answer.images
          }
        });

        // ì§ˆë¬¸ìì—ê²Œ ê°œë³„ ì•Œë¦¼
        await this.notifyQuestionOwner(data.questionId, answer);

        // ì„±ê³µ ì‘ë‹µ
        socket.emit('answer_created', { answer });

      } catch (error) {
        socket.emit('error', { message: 'Failed to create answer' });
      }
    });

    // ë‹µë³€ ì±„íƒ
    socket.on('accept_answer', async (data: { answerId: string }) => {
      try {
        const answer = await Answer.findById(data.answerId);
        const question = await Question.findById(answer.questionId);

        // ê¶Œí•œ ê²€ì¦ (ì§ˆë¬¸ ì‘ì„±ìë§Œ ì±„íƒ ê°€ëŠ¥)
        if (question.userId !== socket.userId) {
          socket.emit('error', { message: 'Unauthorized' });
          return;
        }

        // ë‹µë³€ ì±„íƒ ì²˜ë¦¬
        await Answer.updateOne(
          { _id: data.answerId },
          { isAccepted: true, acceptedAt: new Date() }
        );

        // í¬ì¸íŠ¸ ì ë¦½
        await this.addPointsForAcceptedAnswer(answer.userId);

        // ë£¸ ì „ì²´ì— ì±„íƒ ì•Œë¦¼
        io.to(`question:${question.id}`).emit('answer_accepted', {
          answerId: data.answerId,
          questionId: question.id
        });

        // ë‹µë³€ìì—ê²Œ ê°œë³„ ì•Œë¦¼
        await this.notifyAnswerAccepted(answer.userId, answer);

      } catch (error) {
        socket.emit('error', { message: 'Failed to accept answer' });
      }
    });
  }

  private static async notifyQuestionOwner(questionId: string, answer: Answer) {
    const question = await Question.findById(questionId);
    const questionOwnerSession = UserSessionManager.getUserSession(question.userId);

    if (questionOwnerSession?.isOnline) {
      io.to(questionOwnerSession.socketId).emit('answer_notification', {
        questionId,
        answer: {
          id: answer.id,
          preview: answer.content.substring(0, 100),
          user: answer.user,
          createdAt: answer.createdAt
        }
      });
    }
  }
}
```

#### 3. íƒ€ì´í•‘ ì´ë²¤íŠ¸

```typescript
// server/socket/events/typingEvents.ts
export class TypingEvents {
  private static typingUsers = new Map<string, TypingUser>();

  static register(socket: Socket) {
    // íƒ€ì´í•‘ ì‹œì‘
    socket.on('typing_start', (data: { questionId: string }) => {
      const typingUser: TypingUser = {
        userId: socket.userId,
        username: socket.user.nickname,
        questionId: data.questionId,
        startedAt: new Date()
      };

      const key = `${data.questionId}:${socket.userId}`;
      this.typingUsers.set(key, typingUser);

      // ê°™ì€ ì§ˆë¬¸ ë£¸ì˜ ë‹¤ë¥¸ ì‚¬ìš©ìë“¤ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      socket.to(`question:${data.questionId}`).emit('user_typing', {
        userId: socket.userId,
        username: socket.user.nickname,
        questionId: data.questionId
      });

      // 3ì´ˆ í›„ ìë™ìœ¼ë¡œ íƒ€ì´í•‘ ì¤‘ì§€
      setTimeout(() => {
        this.stopTyping(socket, data.questionId);
      }, 3000);
    });

    // íƒ€ì´í•‘ ì¤‘ì§€
    socket.on('typing_stop', (data: { questionId: string }) => {
      this.stopTyping(socket, data.questionId);
    });
  }

  private static stopTyping(socket: Socket, questionId: string) {
    const key = `${questionId}:${socket.userId}`;
    if (this.typingUsers.has(key)) {
      this.typingUsers.delete(key);

      socket.to(`question:${questionId}`).emit('user_stop_typing', {
        userId: socket.userId,
        questionId
      });
    }
  }

  static getTypingUsers(questionId: string): TypingUser[] {
    return Array.from(this.typingUsers.values())
      .filter(user => user.questionId === questionId);
  }

  static cleanupExpiredTyping() {
    const now = new Date();
    const expiredKeys: string[] = [];

    for (const [key, user] of this.typingUsers) {
      if (now.getTime() - user.startedAt.getTime() > 5000) { // 5ì´ˆ í›„ ë§Œë£Œ
        expiredKeys.push(key);
      }
    }

    expiredKeys.forEach(key => this.typingUsers.delete(key));
  }
}

// ì£¼ê¸°ì ìœ¼ë¡œ ë§Œë£Œëœ íƒ€ì´í•‘ ìƒíƒœ ì •ë¦¬
setInterval(() => {
  TypingEvents.cleanupExpiredTyping();
}, 30000); // 30ì´ˆë§ˆë‹¤
```

---

## ğŸ”” ì‹¤ì‹œê°„ ì•Œë¦¼ ì‹œìŠ¤í…œ

### ì•Œë¦¼ ìš°ì„ ìˆœìœ„ ì‹œìŠ¤í…œ

```typescript
// server/notification/notificationManager.ts
export class NotificationManager {
  private static readonly PRIORITY_LEVELS = {
    CRITICAL: 1,  // ì‘ê¸‰ìƒí™©
    HIGH: 2,      // ê¸´ê¸‰ ì§ˆë¬¸
    NORMAL: 3,    // ì¼ë°˜ ì§ˆë¬¸
    LOW: 4        // ì‹œìŠ¤í…œ ì•Œë¦¼
  };

  static async sendNotification(
    userId: string,
    notification: Notification,
    channels: NotificationChannel[] = ['socket', 'push']
  ) {
    const user = await User.findById(userId);
    if (!user) return;

    // ì‚¬ìš©ì ì•Œë¦¼ ì„¤ì • í™•ì¸
    const settings = await this.getUserNotificationSettings(userId);
    if (!this.shouldSendNotification(notification, settings)) {
      return;
    }

    // ì±„ë„ë³„ ì•Œë¦¼ ì „ì†¡
    const promises = channels.map(channel => {
      switch (channel) {
        case 'socket':
          return this.sendSocketNotification(userId, notification);
        case 'push':
          return this.sendPushNotification(user, notification);
        case 'email':
          return this.sendEmailNotification(user, notification);
        case 'sms':
          return this.sendSMSNotification(user, notification);
      }
    });

    await Promise.allSettled(promises);

    // ì•Œë¦¼ íˆìŠ¤í† ë¦¬ ì €ì¥
    await this.saveNotificationHistory(userId, notification);
  }

  private static async sendSocketNotification(
    userId: string,
    notification: Notification
  ) {
    const session = UserSessionManager.getUserSession(userId);
    if (session?.isOnline) {
      io.to(session.socketId).emit('notification', {
        id: notification.id,
        type: notification.type,
        title: notification.title,
        message: notification.message,
        data: notification.data,
        priority: notification.priority,
        timestamp: new Date(),
        sound: this.getNotificationSound(notification.priority)
      });
    }
  }

  private static async sendTargetedNotifications(question: Question) {
    // ì§€ì—­ ê¸°ë°˜ íƒ€ê²ŸíŒ…
    const regionTargets = await this.getRegionTargets(question.regionCode);

    // ê´€ì‹¬ì‚¬ ê¸°ë°˜ íƒ€ê²ŸíŒ…
    const interestTargets = await this.getInterestTargets(question.hashtags);

    // ì „ë¬¸ê°€ íƒ€ê²ŸíŒ…
    const expertTargets = await this.getExpertTargets(question.category);

    // ì¤‘ë³µ ì œê±° ë° ìš°ì„ ìˆœìœ„ ì •ë ¬
    const allTargets = this.deduplicateAndPrioritize([
      ...expertTargets,
      ...regionTargets,
      ...interestTargets
    ]);

    // ë°°ì¹˜ ì•Œë¦¼ ì „ì†¡ (ìµœëŒ€ 50ëª…)
    const batchSize = 50;
    for (let i = 0; i < allTargets.length; i += batchSize) {
      const batch = allTargets.slice(i, i + batchSize);
      await this.sendBatchNotifications(batch, question);
    }
  }
}
```

### ìœ„ì¹˜ ê¸°ë°˜ ì‹¤ì‹œê°„ ì•Œë¦¼

```typescript
// server/notification/locationNotification.ts
export class LocationBasedNotification {
  private static nearbyUsers = new Map<string, LocationData>();

  static updateUserLocation(userId: string, location: LocationData) {
    this.nearbyUsers.set(userId, {
      ...location,
      updatedAt: new Date()
    });

    // ì£¼ë³€ ì‚¬ìš©ìì—ê²Œ ì‹¤ì‹œê°„ ì§ˆë¬¸ ì•Œë¦¼
    this.notifyNearbyUsers(userId, location);
  }

  static async notifyNearbyUsers(userId: string, location: LocationData) {
    // ë°˜ê²½ ë‚´ ì‚¬ìš©ì ì°¾ê¸° (ê¸°ë³¸ 3km)
    const nearbyUsers = this.findUsersInRadius(location, 3000);

    // í•´ë‹¹ ì§€ì—­ì˜ ìµœê·¼ ì§ˆë¬¸ë“¤
    const recentQuestions = await Question.find({
      createdAt: { $gte: new Date(Date.now() - 3600000) }, // 1ì‹œê°„ ì´ë‚´
      location: {
        $nearSphere: {
          $geometry: {
            type: 'Point',
            coordinates: [location.longitude, location.latitude]
          },
          $maxDistance: 3000 // 3km
        }
      }
    }).limit(5);

    // ì£¼ë³€ ì‚¬ìš©ìë“¤ì—ê²Œ ì•Œë¦¼
    for (const nearbyUserId of nearbyUsers) {
      const session = UserSessionManager.getUserSession(nearbyUserId);
      if (session?.isOnline) {
        io.to(session.socketId).emit('nearby_questions_update', {
          location,
          questions: recentQuestions.map(q => ({
            id: q.id,
            title: q.title,
            distance: this.calculateDistance(location, q.location),
            urgency: q.urgency,
            createdAt: q.createdAt
          }))
        });
      }
    }
  }

  private static findUsersInRadius(
    center: LocationData,
    radiusMeters: number
  ): string[] {
    const nearbyUserIds: string[] = [];

    for (const [userId, userLocation] of this.nearbyUsers) {
      const distance = this.calculateDistance(center, userLocation);
      if (distance <= radiusMeters) {
        nearbyUserIds.push(userId);
      }
    }

    return nearbyUserIds;
  }

  private static calculateDistance(
    point1: LocationData,
    point2: LocationData
  ): number {
    const R = 6371e3; // ì§€êµ¬ ë°˜ì§€ë¦„ (ë¯¸í„°)
    const Ï†1 = (point1.latitude * Math.PI) / 180;
    const Ï†2 = (point2.latitude * Math.PI) / 180;
    const Î”Ï† = ((point2.latitude - point1.latitude) * Math.PI) / 180;
    const Î”Î» = ((point2.longitude - point1.longitude) * Math.PI) / 180;

    const a =
      Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
      Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // ë¯¸í„° ë‹¨ìœ„ ê±°ë¦¬
  }
}
```

---

## ğŸ“ˆ í™•ì¥ì„± ë° ì„±ëŠ¥ ìµœì í™”

### Redis í´ëŸ¬ìŠ¤í„°ë§

```typescript
// server/redis/redisCluster.ts
export class RedisClusterManager {
  private redisCluster: Cluster;
  private readonly CACHE_TTL = {
    USER_SESSION: 3600,      // 1ì‹œê°„
    QUESTION_CACHE: 1800,    // 30ë¶„
    NOTIFICATION_CACHE: 300,  // 5ë¶„
    TRENDING_TAGS: 900       // 15ë¶„
  };

  constructor() {
    this.redisCluster = new Redis.Cluster([
      { host: 'redis-node-1', port: 6379 },
      { host: 'redis-node-2', port: 6379 },
      { host: 'redis-node-3', port: 6379 }
    ], {
      enableOfflineQueue: false,
      redisOptions: {
        password: process.env.REDIS_PASSWORD,
        connectTimeout: 60000,
        lazyConnect: true,
        maxRetriesPerRequest: 3
      }
    });
  }

  // ì‚¬ìš©ì ì„¸ì…˜ ìºì‹±
  async cacheUserSession(userId: string, session: UserSession) {
    const key = `session:${userId}`;
    await this.redisCluster.setex(
      key,
      this.CACHE_TTL.USER_SESSION,
      JSON.stringify(session)
    );
  }

  async getUserSession(userId: string): Promise<UserSession | null> {
    const key = `session:${userId}`;
    const cached = await this.redisCluster.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  // ì§ˆë¬¸ ìºì‹±
  async cacheQuestion(questionId: string, question: Question) {
    const key = `question:${questionId}`;
    await this.redisCluster.setex(
      key,
      this.CACHE_TTL.QUESTION_CACHE,
      JSON.stringify(question)
    );
  }

  // ì‹¤ì‹œê°„ í†µê³„ ìºì‹±
  async updateRealtimeStats(regionCode: string, stats: RegionStats) {
    const key = `stats:${regionCode}`;
    await this.redisCluster.setex(
      key,
      this.CACHE_TTL.TRENDING_TAGS,
      JSON.stringify(stats)
    );
  }

  // íŠ¸ë Œë”© í•´ì‹œíƒœê·¸ ìºì‹±
  async cacheTrendingTags(timeRange: string, tags: TrendingTag[]) {
    const key = `trending:${timeRange}`;
    await this.redisCluster.setex(
      key,
      this.CACHE_TTL.TRENDING_TAGS,
      JSON.stringify(tags)
    );
  }
}
```

### ë¡œë“œ ë°¸ëŸ°ì‹± ë° í´ëŸ¬ìŠ¤í„°ë§

```typescript
// server/cluster/socketCluster.ts
export class SocketCluster {
  private servers: SocketServer[] = [];
  private loadBalancer: LoadBalancer;

  constructor() {
    this.setupCluster();
    this.setupLoadBalancer();
  }

  private setupCluster() {
    const numCPUs = os.cpus().length;
    const numWorkers = Math.min(numCPUs, parseInt(process.env.MAX_WORKERS || '4'));

    if (cluster.isMaster) {
      console.log(`Master ${process.pid} is running`);

      // ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ ìƒì„±
      for (let i = 0; i < numWorkers; i++) {
        cluster.fork();
      }

      cluster.on('exit', (worker, code, signal) => {
        console.log(`Worker ${worker.process.pid} died`);
        cluster.fork(); // ìë™ ì¬ì‹œì‘
      });
    } else {
      // ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ì—ì„œ Socket.io ì„œë²„ ì‹¤í–‰
      const server = new SocketServer(this.createHttpServer());
      this.servers.push(server);
      console.log(`Worker ${process.pid} started`);
    }
  }

  private setupLoadBalancer() {
    this.loadBalancer = new LoadBalancer({
      algorithm: 'round-robin',
      healthCheck: {
        interval: 30000,
        timeout: 5000,
        retries: 3
      }
    });

    // ì„œë²„ ì¸ìŠ¤í„´ìŠ¤ ë“±ë¡
    this.servers.forEach((server, index) => {
      this.loadBalancer.addServer({
        id: `worker-${index}`,
        host: 'localhost',
        port: 3001 + index,
        weight: 1
      });
    });
  }
}
```

### ë©”ì‹œì§€ í ì‹œìŠ¤í…œ

```typescript
// server/queue/messageQueue.ts
import Bull from 'bull';

export class MessageQueue {
  private notificationQueue: Bull.Queue;
  private emailQueue: Bull.Queue;
  private pushNotificationQueue: Bull.Queue;

  constructor() {
    const redisConfig = {
      redis: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT || '6379'),
        password: process.env.REDIS_PASSWORD
      }
    };

    this.notificationQueue = new Bull('notification', redisConfig);
    this.emailQueue = new Bull('email', redisConfig);
    this.pushNotificationQueue = new Bull('push-notification', redisConfig);

    this.setupQueueProcessors();
  }

  private setupQueueProcessors() {
    // ì¼ë°˜ ì•Œë¦¼ ì²˜ë¦¬ (ë†’ì€ ë™ì‹œì„±)
    this.notificationQueue.process(10, async (job) => {
      const { userId, notification } = job.data;
      await NotificationManager.sendSocketNotification(userId, notification);
    });

    // ì´ë©”ì¼ ì²˜ë¦¬ (ì¤‘ê°„ ë™ì‹œì„±)
    this.emailQueue.process(5, async (job) => {
      const { email, subject, content } = job.data;
      await EmailService.send(email, subject, content);
    });

    // í‘¸ì‹œ ì•Œë¦¼ ì²˜ë¦¬ (ë‚®ì€ ë™ì‹œì„±, ë†’ì€ ì‹ ë¢°ì„±)
    this.pushNotificationQueue.process(2, async (job) => {
      const { deviceToken, payload } = job.data;
      await PushNotificationService.send(deviceToken, payload);
    });
  }

  async addNotificationJob(userId: string, notification: Notification, priority = 0) {
    await this.notificationQueue.add(
      'send-notification',
      { userId, notification },
      {
        priority,
        attempts: 3,
        backoff: 'exponential',
        delay: priority > 0 ? 0 : 1000 // ë†’ì€ ìš°ì„ ìˆœìœ„ëŠ” ì¦‰ì‹œ ì²˜ë¦¬
      }
    );
  }

  async addBulkNotifications(notifications: BulkNotification[]) {
    const jobs = notifications.map(notif => ({
      name: 'send-notification',
      data: notif,
      opts: {
        priority: notif.priority || 0,
        attempts: 3,
        backoff: 'exponential'
      }
    }));

    await this.notificationQueue.addBulk(jobs);
  }
}
```

---

## ğŸ”’ ë³´ì•ˆ ë° ì•ˆì •ì„±

### ì—°ê²° ë³´ì•ˆ

```typescript
// server/security/socketSecurity.ts
export class SocketSecurity {
  static setupSecurityMiddleware(io: Server) {
    // Rate Limiting
    const rateLimiter = new Map<string, RateLimitData>();

    io.use((socket, next) => {
      const clientIP = socket.handshake.address;
      const now = Date.now();
      const windowMs = 60000; // 1ë¶„ ìœˆë„ìš°
      const maxRequests = 100; // ë¶„ë‹¹ ìµœëŒ€ 100ê°œ ìš”ì²­

      if (!rateLimiter.has(clientIP)) {
        rateLimiter.set(clientIP, {
          requests: 1,
          windowStart: now
        });
        return next();
      }

      const clientData = rateLimiter.get(clientIP)!;

      // ìœˆë„ìš° ì¬ì„¤ì •
      if (now - clientData.windowStart > windowMs) {
        clientData.requests = 1;
        clientData.windowStart = now;
        return next();
      }

      // Rate limit ê²€ì‚¬
      if (clientData.requests >= maxRequests) {
        return next(new Error('Rate limit exceeded'));
      }

      clientData.requests++;
      next();
    });

    // IP ë¸”ë™ë¦¬ìŠ¤íŠ¸ ê²€ì‚¬
    io.use(async (socket, next) => {
      const clientIP = socket.handshake.address;
      const isBlocked = await this.checkIPBlacklist(clientIP);

      if (isBlocked) {
        return next(new Error('IP blocked'));
      }

      next();
    });
  }

  // ë©”ì‹œì§€ ê²€ì¦ ë° ìƒˆë‹ˆíƒ€ì´ì œì´ì…˜
  static validateMessage(message: any): ValidationResult {
    const errors: string[] = [];

    // ë©”ì‹œì§€ ê¸¸ì´ ê²€ì¦
    if (message.content && message.content.length > 1000) {
      errors.push('Message too long');
    }

    // HTML íƒœê·¸ ì œê±°
    if (message.content) {
      message.content = this.sanitizeHTML(message.content);
    }

    // ìŠ¤íŒ¸ í‚¤ì›Œë“œ ê²€ì‚¬
    if (this.containsSpam(message.content)) {
      errors.push('Message contains spam content');
    }

    // í•´ì‹œíƒœê·¸ ê²€ì¦
    if (message.hashtags && message.hashtags.length > 5) {
      errors.push('Too many hashtags');
    }

    return {
      isValid: errors.length === 0,
      errors,
      sanitizedMessage: message
    };
  }

  private static sanitizeHTML(content: string): string {
    return content
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<[^>]*>/g, '')
      .trim();
  }

  private static containsSpam(content: string): boolean {
    const spamPatterns = [
      /ê´‘ê³ /gi,
      /í™ë³´/gi,
      /í• ì¸/gi,
      /ë¬´ë£Œ/gi,
      /í´ë¦­/gi
    ];

    return spamPatterns.some(pattern => pattern.test(content));
  }
}
```

### ìë™ ì¬ì—°ê²° ì‹œìŠ¤í…œ

```typescript
// client/socket/reconnection.ts
export class ReconnectionManager {
  private socket: Socket;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectInterval = 1000;
  private isReconnecting = false;

  constructor(socket: Socket) {
    this.socket = socket;
    this.setupEventHandlers();
  }

  private setupEventHandlers() {
    this.socket.on('disconnect', (reason) => {
      console.log('Socket disconnected:', reason);

      if (reason === 'io server disconnect') {
        // ì„œë²„ì—ì„œ ê°•ì œë¡œ ì—°ê²°ì„ ëŠì€ ê²½ìš° ì¬ì—°ê²°í•˜ì§€ ì•ŠìŒ
        return;
      }

      this.startReconnection();
    });

    this.socket.on('connect', () => {
      console.log('Socket reconnected');
      this.reconnectAttempts = 0;
      this.isReconnecting = false;

      // ì¬ì—°ê²° í›„ ìƒíƒœ ë³µêµ¬
      this.restoreState();
    });

    this.socket.on('reconnect_error', (error) => {
      console.error('Reconnection failed:', error);
      this.handleReconnectionError();
    });
  }

  private startReconnection() {
    if (this.isReconnecting) return;

    this.isReconnecting = true;
    this.attemptReconnection();
  }

  private attemptReconnection() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      this.onReconnectionFailed();
      return;
    }

    this.reconnectAttempts++;
    const delay = this.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1);

    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms`);

    setTimeout(() => {
      if (!this.socket.connected) {
        this.socket.connect();
      }
    }, delay);
  }

  private restoreState() {
    // ì¬ì—°ê²° í›„ ì´ì „ ìƒíƒœ ë³µêµ¬
    const savedState = this.getSavedState();

    if (savedState.currentQuestionId) {
      this.socket.emit('join_question', {
        questionId: savedState.currentQuestionId
      });
    }

    if (savedState.userLocation) {
      this.socket.emit('update_location', savedState.userLocation);
    }

    // ì½ì§€ ì•Šì€ ë©”ì‹œì§€ ë™ê¸°í™”
    this.socket.emit('sync_unread_messages', {
      lastSyncTimestamp: savedState.lastSyncTimestamp
    });
  }

  private getSavedState(): SavedState {
    const saved = localStorage.getItem('socketState');
    return saved ? JSON.parse(saved) : {};
  }

  private saveState(state: Partial<SavedState>) {
    const currentState = this.getSavedState();
    const newState = { ...currentState, ...state };
    localStorage.setItem('socketState', JSON.stringify(newState));
  }

  private onReconnectionFailed() {
    // ì¬ì—°ê²° ì‹¤íŒ¨ ì‹œ ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼
    this.showReconnectionFailedMessage();

    // ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì „í™˜
    this.enableOfflineMode();
  }

  private showReconnectionFailedMessage() {
    // UIì— ì—°ê²° ì‹¤íŒ¨ ë©”ì‹œì§€ í‘œì‹œ
    const event = new CustomEvent('socket-reconnection-failed');
    window.dispatchEvent(event);
  }

  private enableOfflineMode() {
    // ì˜¤í”„ë¼ì¸ ëª¨ë“œ í™œì„±í™”
    const event = new CustomEvent('socket-offline-mode');
    window.dispatchEvent(event);
  }
}
```

---

## ğŸ“Š ëª¨ë‹ˆí„°ë§ ë° ë””ë²„ê¹…

### 10ë¶„ ëª©í‘œ ë‹¬ì„± ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

```typescript
// server/monitoring/responseTimeMonitoring.ts
export class ResponseTimeMonitoring {
  private static metrics = {
    connectedUsers: 0,
    totalMessages: 0,
    messageRate: 0,
    errorRate: 0,
    averageResponseTime: 0,
    // ì œì£¼ë„ íŠ¹í™” ì§€í‘œ
    under10MinuteResponseRate: 0,  // 10ë¶„ ë‚´ ë‹µë³€ìœ¨
    under5MinuteResponseRate: 0,   // 5ë¶„ ë‚´ ë‹µë³€ìœ¨
    under1MinuteResponseRate: 0,   // 1ë¶„ ë‚´ ë‹µë³€ìœ¨
    locationBasedResponseTime: {},  // ì§€ì—­ë³„ ì‘ë‹µì‹œê°„
    urgentQuestionResponseTime: 0   // ê¸´ê¸‰ ì§ˆë¬¸ ì‘ë‹µì‹œê°„
  };

  static startMonitoring(io: Server) {
    // ì—°ê²°ëœ ì‚¬ìš©ì ìˆ˜ ì¶”ì 
    io.on('connection', (socket) => {
      this.metrics.connectedUsers++;
      this.updateDashboard();

      socket.on('disconnect', () => {
        this.metrics.connectedUsers--;
        this.updateDashboard();
      });
    });

    // 10ë¶„ ëª©í‘œ ì‘ë‹µì‹œê°„ ì¶”ì 
    this.trackResponseTimes();

    // ì§€ì—­ë³„ ì‘ë‹µì„±ëŠ¥ ì¶”ì 
    this.trackLocationBasedPerformance();

    // ê¸´ê¸‰ ì§ˆë¬¸ íŠ¹ë³„ ì¶”ì 
    this.trackUrgentQuestions();

    // ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸ (1ì´ˆë§ˆë‹¤)
    setInterval(() => {
      this.updateRealtimeDashboard();
    }, 1000);
  }

  private static trackResponseTimes() {
    // ì§ˆë¬¸ ë“±ë¡ ì‹œê°„ ê¸°ë¡
    io.on('question_created', (questionData) => {
      const questionId = questionData.question.id;
      RedisCache.set(`question_start_${questionId}`, Date.now());
    });

    // ì²« ë²ˆì§¸ ë‹µë³€ ë“±ë¡ ì‹œ ì‘ë‹µì‹œê°„ ê³„ì‚°
    io.on('first_answer_received', (answerData) => {
      const questionId = answerData.questionId;
      const startTime = RedisCache.get(`question_start_${questionId}`);

      if (startTime) {
        const responseTime = Date.now() - startTime;

        // ì‘ë‹µì‹œê°„ ì¹´í…Œê³ ë¦¬ë³„ ë¶„ë¥˜
        if (responseTime <= 60000) { // 1ë¶„ ì´ë‚´
          this.metrics.under1MinuteResponseRate++;
        }
        if (responseTime <= 300000) { // 5ë¶„ ì´ë‚´
          this.metrics.under5MinuteResponseRate++;
        }
        if (responseTime <= 600000) { // 10ë¶„ ì´ë‚´
          this.metrics.under10MinuteResponseRate++;
        }

        // 10ë¶„ ì´ˆê³¼ ì‹œ ì•ŒëŒ
        if (responseTime > 600000) {
          this.alertSlowResponse(questionId, responseTime);
        }

        // í‰ê·  ì‘ë‹µì‹œê°„ ì—…ë°ì´íŠ¸
        this.updateAverageResponseTime(responseTime);
      }
    });
  }

  private static trackLocationBasedPerformance() {
    // ì§€ì—­ë³„ ì‘ë‹µì‹œê°„ ì¶”ì 
    const jejuRegions = ['ì• ì›”', 'í•œë¦¼', 'ì œì£¼ì‹œ', 'ì¡°ì²œ', 'êµ¬ì¢Œ', 'ì„±ì‚°', 'í‘œì„ ', 'ë‚¨ì›', 'ì„œê·€í¬', 'ì•ˆë•', 'ëŒ€ì •'];

    jejuRegions.forEach(region => {
      this.metrics.locationBasedResponseTime[region] = {
        averageTime: 0,
        questionCount: 0,
        under10MinRate: 0
      };
    });
  }

  private static alertSlowResponse(questionId: string, responseTime: number) {
    // 10ë¶„ ì´ˆê³¼ ì‹œ ê´€ë¦¬ìì—ê²Œ ì¦‰ì‹œ ì•Œë¦¼
    io.to('admin-room').emit('slow_response_alert', {
      questionId,
      responseTime,
      message: `ì§ˆë¬¸ ${questionId}ì´ ${Math.round(responseTime/60000)}ë¶„ í›„ì— ì²« ë‹µë³€ì„ ë°›ì•˜ìŠµë‹ˆë‹¤.`,
      urgency: 'high'
    });

    // ìŠ¬ë™/ë””ìŠ¤ì½”ë“œ ë“± ì™¸ë¶€ ì•Œë¦¼ë„ ì „ì†¡
    this.sendExternalAlert({
      type: 'SLOW_RESPONSE',
      questionId,
      responseTime: Math.round(responseTime/60000),
      threshold: 10
    });
  }

  private static trackMessageRate() {
    let messageCount = 0;
    const startTime = Date.now();

    // ëª¨ë“  ë©”ì‹œì§€ ì´ë²¤íŠ¸ ì¶”ì 
    const originalEmit = io.emit;
    io.emit = function(...args) {
      messageCount++;
      return originalEmit.apply(this, args);
    };

    setInterval(() => {
      const elapsed = (Date.now() - startTime) / 1000;
      this.metrics.messageRate = messageCount / elapsed;
      messageCount = 0;
    }, 60000); // 1ë¶„ë§ˆë‹¤ ê³„ì‚°
  }

  private static async collectMetrics() {
    // Redisì—ì„œ í†µê³„ ìˆ˜ì§‘
    const redis = new Redis(process.env.REDIS_URL);

    // í™œì„± ë£¸ ìˆ˜
    const activeRooms = await redis.scard('active-rooms');

    // ì²˜ë¦¬ ëŒ€ê¸° ì¤‘ì¸ ì‘ì—… ìˆ˜
    const pendingJobs = await redis.llen('bull:notification:waiting');

    // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
    const memoryUsage = process.memoryUsage();

    // CPU ì‚¬ìš©ë¥ 
    const cpuUsage = process.cpuUsage();

    return {
      activeRooms,
      pendingJobs,
      memoryUsage,
      cpuUsage,
      uptime: process.uptime()
    };
  }

  static async updateDashboard() {
    const metrics = await this.collectMetrics();

    // ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œì— ì‹¤ì‹œê°„ ì „ì†¡
    io.to('admin-dashboard').emit('metrics-update', {
      ...this.metrics,
      ...metrics,
      timestamp: new Date()
    });

    // ì™¸ë¶€ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì— ì „ì†¡ (DataDog, New Relic ë“±)
    if (process.env.MONITORING_WEBHOOK) {
      await this.sendToMonitoringService(metrics);
    }
  }

  private static async sendToMonitoringService(metrics: any) {
    try {
      await fetch(process.env.MONITORING_WEBHOOK!, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          service: 'dongne-socket-server',
          metrics,
          timestamp: new Date().toISOString()
        })
      });
    } catch (error) {
      console.error('Failed to send metrics to monitoring service:', error);
    }
  }
}
```

### ë¡œê·¸ ì‹œìŠ¤í…œ

```typescript
// server/logging/socketLogger.ts
export class SocketLogger {
  private logger: winston.Logger;

  constructor() {
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      ),
      transports: [
        new winston.transports.File({ filename: 'logs/socket-error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/socket-combined.log' }),
        new winston.transports.Console({
          format: winston.format.simple()
        })
      ]
    });
  }

  logConnection(socket: Socket) {
    this.logger.info('User connected', {
      socketId: socket.id,
      userId: socket.userId,
      ip: socket.handshake.address,
      userAgent: socket.handshake.headers['user-agent'],
      timestamp: new Date()
    });
  }

  logDisconnection(socket: Socket, reason: string) {
    this.logger.info('User disconnected', {
      socketId: socket.id,
      userId: socket.userId,
      reason,
      connectionDuration: Date.now() - socket.connectedAt,
      timestamp: new Date()
    });
  }

  logMessage(socket: Socket, event: string, data: any) {
    this.logger.debug('Message received', {
      socketId: socket.id,
      userId: socket.userId,
      event,
      dataSize: JSON.stringify(data).length,
      timestamp: new Date()
    });
  }

  logError(socket: Socket, error: Error, context?: any) {
    this.logger.error('Socket error', {
      socketId: socket.id,
      userId: socket.userId,
      error: error.message,
      stack: error.stack,
      context,
      timestamp: new Date()
    });
  }

  logPerformance(event: string, duration: number, metadata?: any) {
    this.logger.info('Performance metric', {
      event,
      duration,
      metadata,
      timestamp: new Date()
    });
  }
}
```

---

## ğŸš€ ë°°í¬ ë° ìš´ì˜

### Docker ì»¨í…Œì´ë„ˆ ì„¤ì •

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# ì˜ì¡´ì„± ì„¤ì¹˜
COPY package*.json ./
RUN npm ci --only=production

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œ ë³µì‚¬
COPY . .

# ë¹Œë“œ
RUN npm run build

# ë¹„root ì‚¬ìš©ì ìƒì„±
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

USER nextjs

EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["npm", "start"]
```

### Kubernetes ë°°í¬ ì„¤ì •

```yaml
# k8s/socket-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dongne-socket-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: dongne-socket-server
  template:
    metadata:
      labels:
        app: dongne-socket-server
    spec:
      containers:
      - name: socket-server
        image: dongne/socket-server:latest
        ports:
        - containerPort: 3000
        env:
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: dongne-socket-service
spec:
  selector:
    app: dongne-socket-server
  ports:
  - port: 80
    targetPort: 3000
  type: LoadBalancer
```

ì´ ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ë¬¸ì„œëŠ” "ë™ë„¤ë¬¼ì–´ë´" ì„œë¹„ìŠ¤ì˜ í•µì‹¬ì¸ ì‹¤ì‹œê°„ ê¸°ëŠ¥ì„ ì•ˆì •ì ì´ê³  í™•ì¥ ê°€ëŠ¥í•˜ê²Œ êµ¬í˜„í•˜ê¸° ìœ„í•œ í¬ê´„ì ì¸ ê°€ì´ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "UX \ud50c\ub85c\uc6b0 \uc0c1\uc138 \ubb38\uc11c\ud654 - \uc640\uc774\uc5b4\ud504\ub808\uc784 \ubc0f \uc0ac\uc6a9\uc790 \uc2dc\ub098\ub9ac\uc624 \uc791\uc131", "status": "completed", "activeForm": "UX \ud50c\ub85c\uc6b0 \uc0c1\uc138 \ubb38\uc11c\ud654 - \uc640\uc774\uc5b4\ud504\ub808\uc784 \ubc0f \uc0ac\uc6a9\uc790 \uc2dc\ub098\ub9ac\uc624 \uc791\uc131 \uc911"}, {"content": "\uc5ec\ud589 \uc804-\uc911-\ud6c4 \ub2e8\uacc4\ubcc4 \ucef4\ud3ec\ub10c\ud2b8 \uad6c\uc870 \uc124\uacc4 \ubb38\uc11c \uc791\uc131", "status": "completed", "activeForm": "\uc5ec\ud589 \uc804-\uc911-\ud6c4 \ub2e8\uacc4\ubcc4 \ucef4\ud3ec\ub10c\ud2b8 \uad6c\uc870 \uc124\uacc4 \ubb38\uc11c \uc791\uc131 \uc911"}, {"content": "\uba54\uc2dc\uc9c0 \uc2a4\ud0c0\uc77c \uc778\ud130\ud398\uc774\uc2a4 \uc0c1\ud638\uc791\uc6a9 \uba85\uc138\uc11c \uc791\uc131", "status": "completed", "activeForm": "\uba54\uc2dc\uc9c0 \uc2a4\ud0c0\uc77c \uc778\ud130\ud398\uc774\uc2a4 \uc0c1\ud638\uc791\uc6a9 \uba85\uc138\uc11c \uc791\uc131 \uc911"}, {"content": "\uc2e4\uc2dc\uac04 \uc2dc\uc2a4\ud15c \uc544\ud0a4\ud14d\ucc98 \uae30\uc220 \ubb38\uc11c \uc791\uc131", "status": "completed", "activeForm": "\uc2e4\uc2dc\uac04 \uc2dc\uc2a4\ud15c \uc544\ud0a4\ud14d\ucc98 \uae30\uc220 \ubb38\uc11c \uc791\uc131 \uc911"}]