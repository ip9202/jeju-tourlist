# "동네물어봐" 실시간 시스템 아키텍처

## 📋 목차
1. [실시간 시스템 개요](#-실시간-시스템-개요)
2. [Socket.io 기반 아키텍처](#-socketio-기반-아키텍처)
3. [이벤트 시스템 설계](#-이벤트-시스템-설계)
4. [실시간 알림 시스템](#-실시간-알림-시스템)
5. [확장성 및 성능 최적화](#-확장성-및-성능-최적화)
6. [보안 및 안정성](#-보안-및-안정성)
7. [모니터링 및 디버깅](#-모니터링-및-디버깅)

---

## ⚡ 실시간 시스템 개요

### 핵심 목표
- **초즉시성**: 10분 내 첫 답변 목표 달성 (제주도 특성 반영)
- **실시간성**: 타이핑, 답변 수신, 상태 변화 즉시 반영
- **위치 기반 즉시 알림**: GPS 기반 반경 5km 내 현지인 즉시 알림
- **안정성**: 연결 끊김 시 자동 재연결 및 상태 복구
- **확장성**: 동시 사용자 1,000명 이상 지원

### 실시간 기능 요구사항

#### 1. 메시지 스타일 실시간 기능
- 타이핑 인디케이터 (답변 작성 중 표시)
- 실시간 메시지 전송/수신
- 읽음 상태 표시 (sent/delivered/read)
- 온라인 상태 표시

#### 2. 초즉시 알림 시스템
- **3초 이내**: 새 질문 등록 시 반경 5km 내 현지인에게 즉시 알림
- **1초 이내**: 답변 수신 시 질문자에게 실시간 알림
- **카카오톡 수준**: 읽음/미읽음 상태 실시간 동기화
- **긴급 모드**: 🚨 긴급 질문 시 진동/사운드 알림 강제 발송
- **위치 기반 우선순위**: 가까운 거리 순으로 알림 우선도 설정

#### 3. 제주도 특화 위치 기반 시스템
- **초정밀 GPS**: 100m 단위 위치 기반 알림 (제주 작은 동네 특성)
- **실시간 위치 추적**: 이동 중에도 끊김 없는 알림 수신
- **핫스팟 감지**: 관광지 집중 지역 실시간 모니터링
- **동네별 즉시 알림**: 애월, 성산, 중문 등 동네 단위 타겟팅

---

## 🔗 Socket.io 기반 아키텍처

### 시스템 구조

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   웹 클라이언트   │    │   모바일 앱      │    │   관리자 대시보드 │
│   (Next.js)     │    │ (React Native)  │    │   (Next.js)     │
└─────────┬───────┘    └─────────┬───────┘    └─────────┬───────┘
          │                      │                      │
          └──────────────────────┼──────────────────────┘
                                 │
                    ┌─────────────┴─────────────┐
                    │     Socket.io 서버        │
                    │   (Node.js + Express)     │
                    └─────────────┬─────────────┘
                                 │
                    ┌─────────────┴─────────────┐
                    │     Redis Adapter         │
                    │  (클러스터링 & 캐싱)      │
                    └─────────────┬─────────────┘
                                 │
                    ┌─────────────┴─────────────┐
                    │    PostgreSQL DB          │
                    │  (영구 데이터 저장)       │
                    └───────────────────────────┘
```

### Socket.io 서버 구성

```typescript
// server/socket/socketServer.ts
import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { createClient } from 'redis';

export class SocketServer {
  private io: Server;
  private redisClient;
  private redisAdapter;

  constructor(httpServer: any) {
    // Socket.io 서버 초기화
    this.io = new Server(httpServer, {
      cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
        methods: ['GET', 'POST'],
        credentials: true
      },
      pingTimeout: 60000,
      pingInterval: 25000,
      maxHttpBufferSize: 1e6, // 1MB
      transports: ['websocket', 'polling']
    });

    this.setupRedisAdapter();
    this.setupEventHandlers();
    this.setupRoomManagement();
  }

  private async setupRedisAdapter() {
    // Redis 클러스터 어댑터 설정
    this.redisClient = createClient({
      url: process.env.REDIS_URL || 'redis://localhost:6379'
    });

    const subClient = this.redisClient.duplicate();
    await Promise.all([
      this.redisClient.connect(),
      subClient.connect()
    ]);

    this.redisAdapter = createAdapter(this.redisClient, subClient);
    this.io.adapter(this.redisAdapter);
  }

  private setupEventHandlers() {
    this.io.on('connection', this.handleConnection.bind(this));
  }

  private handleConnection(socket: Socket) {
    console.log(`User connected: ${socket.id}`);

    // 인증 미들웨어
    this.authenticateSocket(socket);

    // 이벤트 핸들러 등록
    this.registerQuestionEvents(socket);
    this.registerAnswerEvents(socket);
    this.registerTypingEvents(socket);
    this.registerLocationEvents(socket);
    this.registerNotificationEvents(socket);

    // 연결 해제 처리
    socket.on('disconnect', () => {
      this.handleDisconnection(socket);
    });
  }
}
```

### 인증 및 사용자 세션 관리

```typescript
// server/socket/middleware/auth.ts
export const authenticateSocket = async (socket: Socket, next: Function) => {
  try {
    const token = socket.handshake.auth.token;
    if (!token) {
      throw new Error('No token provided');
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!);
    const user = await User.findById(decoded.userId);

    if (!user) {
      throw new Error('User not found');
    }

    socket.userId = user.id;
    socket.user = user;
    next();
  } catch (error) {
    next(new Error('Authentication failed'));
  }
};

// 사용자 세션 관리
export class UserSessionManager {
  private static sessions = new Map<string, UserSession>();

  static addSession(socket: Socket) {
    const session: UserSession = {
      socketId: socket.id,
      userId: socket.userId,
      connectedAt: new Date(),
      lastActivity: new Date(),
      rooms: new Set(),
      isOnline: true
    };

    this.sessions.set(socket.userId, session);
    this.broadcastUserOnline(socket.userId);
  }

  static removeSession(socket: Socket) {
    const session = this.sessions.get(socket.userId);
    if (session) {
      session.isOnline = false;
      this.broadcastUserOffline(socket.userId);
      this.sessions.delete(socket.userId);
    }
  }

  static updateActivity(userId: string) {
    const session = this.sessions.get(userId);
    if (session) {
      session.lastActivity = new Date();
    }
  }

  static getUserSession(userId: string): UserSession | null {
    return this.sessions.get(userId) || null;
  }

  private static broadcastUserOnline(userId: string) {
    // 관련 룸에 사용자 온라인 상태 브로드캐스트
    io.emit('user_online', { userId, timestamp: new Date() });
  }

  private static broadcastUserOffline(userId: string) {
    io.emit('user_offline', { userId, timestamp: new Date() });
  }
}
```

---

## 📡 이벤트 시스템 설계

### 이벤트 카테고리

#### 1. 질문 관련 이벤트

```typescript
// server/socket/events/questionEvents.ts
export class QuestionEvents {
  static register(socket: Socket) {
    // 질문 룸 입장
    socket.on('join_question', async (data: { questionId: string }) => {
      try {
        const { questionId } = data;
        const question = await Question.findById(questionId);

        if (!question) {
          socket.emit('error', { message: 'Question not found' });
          return;
        }

        // 질문 룸 입장
        socket.join(`question:${questionId}`);

        // 현재 온라인 사용자 목록 전송
        const onlineUsers = await this.getOnlineUsersInRoom(`question:${questionId}`);
        socket.emit('room_users', { questionId, users: onlineUsers });

        // 기존 메시지 로드
        const messages = await this.loadQuestionMessages(questionId);
        socket.emit('question_messages', { questionId, messages });

      } catch (error) {
        socket.emit('error', { message: 'Failed to join question' });
      }
    });

    // 새 질문 등록
    socket.on('create_question', async (data: CreateQuestionData) => {
      try {
        const question = await this.createQuestion(data, socket.userId);

        // 질문자를 질문 룸에 추가
        socket.join(`question:${question.id}`);

        // 타겟 답변자들에게 알림
        await this.notifyTargetAnswerers(question);

        // 성공 응답
        socket.emit('question_created', { question });

      } catch (error) {
        socket.emit('error', { message: 'Failed to create question' });
      }
    });
  }

  private static async createQuestion(data: CreateQuestionData, userId: string) {
    const question = await Question.create({
      ...data,
      userId,
      createdAt: new Date()
    });

    // 해시태그 처리
    if (data.hashtags?.length > 0) {
      await this.processHashtags(question.id, data.hashtags);
    }

    return question;
  }

  private static async notifyTargetAnswerers(question: Question) {
    // 제주도 특화 초즉시 알림 시스템
    await this.sendUltraFastNotifications(question);
  }

  private static async sendUltraFastNotifications(question: Question) {
    // 1단계: 즉시 알림 (3초 이내) - 반경 2km 내 온라인 현지인
    const immediateTargets = await this.findImmediateTargets(question.location, 2000);
    await this.sendBatchNotifications(immediateTargets, question, 'IMMEDIATE');

    // 2단계: 빠른 알림 (30초 이내) - 반경 5km 내 현지인
    setTimeout(async () => {
      const quickTargets = await this.findQuickTargets(question.location, 5000);
      await this.sendBatchNotifications(quickTargets, question, 'QUICK');
    }, 3000);

    // 3단계: 확장 알림 (2분 이내) - 제주 전체 관련 전문가
    setTimeout(async () => {
      const extendedTargets = await this.findExpertTargets(question.hashtags);
      await this.sendBatchNotifications(extendedTargets, question, 'EXTENDED');
    }, 30000);

    // 4단계: 최종 알림 (5분 이내) - 제주 전체 답변자
    setTimeout(async () => {
      if (await this.hasNoAnswers(question.id)) {
        const allTargets = await this.findAllJejuAnswerers();
        await this.sendBatchNotifications(allTargets, question, 'FINAL');
      }
    }, 120000);
  }

  private static async findImmediateTargets(location: Location, radiusMeters: number) {
    return await User.find({
      isLocalVerified: true,
      isOnline: true,
      location: {
        $nearSphere: {
          $geometry: { type: 'Point', coordinates: [location.lng, location.lat] },
          $maxDistance: radiusMeters
        }
      },
      notificationSettings: { immediateAlerts: true }
    }).limit(10); // 최대 10명에게 즉시 알림
  }

  private static async sendBatchNotifications(
    targets: User[],
    question: Question,
    priority: 'IMMEDIATE' | 'QUICK' | 'EXTENDED' | 'FINAL'
  ) {
    const notificationData = {
      question: {
        id: question.id,
        title: question.title,
        location: question.location,
        hashtags: question.hashtags,
        urgency: question.urgency,
        createdAt: question.createdAt
      },
      priority,
      sound: priority === 'IMMEDIATE' ? 'urgent' : 'normal',
      vibration: priority === 'IMMEDIATE' ? 'strong' : 'light'
    };

    // 병렬로 알림 전송 (성능 최적화)
    const promises = targets.map(async (user) => {
      const session = UserSessionManager.getUserSession(user.id);
      if (session?.isOnline) {
        // Socket 알림
        io.to(session.socketId).emit('new_question_notification', notificationData);

        // 긴급한 경우 푸시 알림도 함께 전송
        if (priority === 'IMMEDIATE' && question.urgency === 'urgent') {
          await PushNotificationService.sendUrgent(user.deviceToken, {
            title: '🚨 긴급 질문이 도착했습니다!',
            body: question.title.substring(0, 50),
            data: { questionId: question.id }
          });
        }
      }
    });

    await Promise.allSettled(promises);

    console.log(`${priority} notifications sent to ${targets.length} users for question ${question.id}`);
  }
}
```

#### 2. 답변 관련 이벤트

```typescript
// server/socket/events/answerEvents.ts
export class AnswerEvents {
  static register(socket: Socket) {
    // 답변 작성
    socket.on('create_answer', async (data: CreateAnswerData) => {
      try {
        const answer = await this.createAnswer(data, socket.userId);

        // 질문 룸에 새 답변 브로드캐스트
        socket.to(`question:${data.questionId}`).emit('new_answer', {
          answer: {
            id: answer.id,
            content: answer.content,
            user: answer.user,
            createdAt: answer.createdAt,
            images: answer.images
          }
        });

        // 질문자에게 개별 알림
        await this.notifyQuestionOwner(data.questionId, answer);

        // 성공 응답
        socket.emit('answer_created', { answer });

      } catch (error) {
        socket.emit('error', { message: 'Failed to create answer' });
      }
    });

    // 답변 채택
    socket.on('accept_answer', async (data: { answerId: string }) => {
      try {
        const answer = await Answer.findById(data.answerId);
        const question = await Question.findById(answer.questionId);

        // 권한 검증 (질문 작성자만 채택 가능)
        if (question.userId !== socket.userId) {
          socket.emit('error', { message: 'Unauthorized' });
          return;
        }

        // 답변 채택 처리
        await Answer.updateOne(
          { _id: data.answerId },
          { isAccepted: true, acceptedAt: new Date() }
        );

        // 포인트 적립
        await this.addPointsForAcceptedAnswer(answer.userId);

        // 룸 전체에 채택 알림
        io.to(`question:${question.id}`).emit('answer_accepted', {
          answerId: data.answerId,
          questionId: question.id
        });

        // 답변자에게 개별 알림
        await this.notifyAnswerAccepted(answer.userId, answer);

      } catch (error) {
        socket.emit('error', { message: 'Failed to accept answer' });
      }
    });
  }

  private static async notifyQuestionOwner(questionId: string, answer: Answer) {
    const question = await Question.findById(questionId);
    const questionOwnerSession = UserSessionManager.getUserSession(question.userId);

    if (questionOwnerSession?.isOnline) {
      io.to(questionOwnerSession.socketId).emit('answer_notification', {
        questionId,
        answer: {
          id: answer.id,
          preview: answer.content.substring(0, 100),
          user: answer.user,
          createdAt: answer.createdAt
        }
      });
    }
  }
}
```

#### 3. 타이핑 이벤트

```typescript
// server/socket/events/typingEvents.ts
export class TypingEvents {
  private static typingUsers = new Map<string, TypingUser>();

  static register(socket: Socket) {
    // 타이핑 시작
    socket.on('typing_start', (data: { questionId: string }) => {
      const typingUser: TypingUser = {
        userId: socket.userId,
        username: socket.user.nickname,
        questionId: data.questionId,
        startedAt: new Date()
      };

      const key = `${data.questionId}:${socket.userId}`;
      this.typingUsers.set(key, typingUser);

      // 같은 질문 룸의 다른 사용자들에게 브로드캐스트
      socket.to(`question:${data.questionId}`).emit('user_typing', {
        userId: socket.userId,
        username: socket.user.nickname,
        questionId: data.questionId
      });

      // 3초 후 자동으로 타이핑 중지
      setTimeout(() => {
        this.stopTyping(socket, data.questionId);
      }, 3000);
    });

    // 타이핑 중지
    socket.on('typing_stop', (data: { questionId: string }) => {
      this.stopTyping(socket, data.questionId);
    });
  }

  private static stopTyping(socket: Socket, questionId: string) {
    const key = `${questionId}:${socket.userId}`;
    if (this.typingUsers.has(key)) {
      this.typingUsers.delete(key);

      socket.to(`question:${questionId}`).emit('user_stop_typing', {
        userId: socket.userId,
        questionId
      });
    }
  }

  static getTypingUsers(questionId: string): TypingUser[] {
    return Array.from(this.typingUsers.values())
      .filter(user => user.questionId === questionId);
  }

  static cleanupExpiredTyping() {
    const now = new Date();
    const expiredKeys: string[] = [];

    for (const [key, user] of this.typingUsers) {
      if (now.getTime() - user.startedAt.getTime() > 5000) { // 5초 후 만료
        expiredKeys.push(key);
      }
    }

    expiredKeys.forEach(key => this.typingUsers.delete(key));
  }
}

// 주기적으로 만료된 타이핑 상태 정리
setInterval(() => {
  TypingEvents.cleanupExpiredTyping();
}, 30000); // 30초마다
```

---

## 🔔 실시간 알림 시스템

### 알림 우선순위 시스템

```typescript
// server/notification/notificationManager.ts
export class NotificationManager {
  private static readonly PRIORITY_LEVELS = {
    CRITICAL: 1,  // 응급상황
    HIGH: 2,      // 긴급 질문
    NORMAL: 3,    // 일반 질문
    LOW: 4        // 시스템 알림
  };

  static async sendNotification(
    userId: string,
    notification: Notification,
    channels: NotificationChannel[] = ['socket', 'push']
  ) {
    const user = await User.findById(userId);
    if (!user) return;

    // 사용자 알림 설정 확인
    const settings = await this.getUserNotificationSettings(userId);
    if (!this.shouldSendNotification(notification, settings)) {
      return;
    }

    // 채널별 알림 전송
    const promises = channels.map(channel => {
      switch (channel) {
        case 'socket':
          return this.sendSocketNotification(userId, notification);
        case 'push':
          return this.sendPushNotification(user, notification);
        case 'email':
          return this.sendEmailNotification(user, notification);
        case 'sms':
          return this.sendSMSNotification(user, notification);
      }
    });

    await Promise.allSettled(promises);

    // 알림 히스토리 저장
    await this.saveNotificationHistory(userId, notification);
  }

  private static async sendSocketNotification(
    userId: string,
    notification: Notification
  ) {
    const session = UserSessionManager.getUserSession(userId);
    if (session?.isOnline) {
      io.to(session.socketId).emit('notification', {
        id: notification.id,
        type: notification.type,
        title: notification.title,
        message: notification.message,
        data: notification.data,
        priority: notification.priority,
        timestamp: new Date(),
        sound: this.getNotificationSound(notification.priority)
      });
    }
  }

  private static async sendTargetedNotifications(question: Question) {
    // 지역 기반 타겟팅
    const regionTargets = await this.getRegionTargets(question.regionCode);

    // 관심사 기반 타겟팅
    const interestTargets = await this.getInterestTargets(question.hashtags);

    // 전문가 타겟팅
    const expertTargets = await this.getExpertTargets(question.category);

    // 중복 제거 및 우선순위 정렬
    const allTargets = this.deduplicateAndPrioritize([
      ...expertTargets,
      ...regionTargets,
      ...interestTargets
    ]);

    // 배치 알림 전송 (최대 50명)
    const batchSize = 50;
    for (let i = 0; i < allTargets.length; i += batchSize) {
      const batch = allTargets.slice(i, i + batchSize);
      await this.sendBatchNotifications(batch, question);
    }
  }
}
```

### 위치 기반 실시간 알림

```typescript
// server/notification/locationNotification.ts
export class LocationBasedNotification {
  private static nearbyUsers = new Map<string, LocationData>();

  static updateUserLocation(userId: string, location: LocationData) {
    this.nearbyUsers.set(userId, {
      ...location,
      updatedAt: new Date()
    });

    // 주변 사용자에게 실시간 질문 알림
    this.notifyNearbyUsers(userId, location);
  }

  static async notifyNearbyUsers(userId: string, location: LocationData) {
    // 반경 내 사용자 찾기 (기본 3km)
    const nearbyUsers = this.findUsersInRadius(location, 3000);

    // 해당 지역의 최근 질문들
    const recentQuestions = await Question.find({
      createdAt: { $gte: new Date(Date.now() - 3600000) }, // 1시간 이내
      location: {
        $nearSphere: {
          $geometry: {
            type: 'Point',
            coordinates: [location.longitude, location.latitude]
          },
          $maxDistance: 3000 // 3km
        }
      }
    }).limit(5);

    // 주변 사용자들에게 알림
    for (const nearbyUserId of nearbyUsers) {
      const session = UserSessionManager.getUserSession(nearbyUserId);
      if (session?.isOnline) {
        io.to(session.socketId).emit('nearby_questions_update', {
          location,
          questions: recentQuestions.map(q => ({
            id: q.id,
            title: q.title,
            distance: this.calculateDistance(location, q.location),
            urgency: q.urgency,
            createdAt: q.createdAt
          }))
        });
      }
    }
  }

  private static findUsersInRadius(
    center: LocationData,
    radiusMeters: number
  ): string[] {
    const nearbyUserIds: string[] = [];

    for (const [userId, userLocation] of this.nearbyUsers) {
      const distance = this.calculateDistance(center, userLocation);
      if (distance <= radiusMeters) {
        nearbyUserIds.push(userId);
      }
    }

    return nearbyUserIds;
  }

  private static calculateDistance(
    point1: LocationData,
    point2: LocationData
  ): number {
    const R = 6371e3; // 지구 반지름 (미터)
    const φ1 = (point1.latitude * Math.PI) / 180;
    const φ2 = (point2.latitude * Math.PI) / 180;
    const Δφ = ((point2.latitude - point1.latitude) * Math.PI) / 180;
    const Δλ = ((point2.longitude - point1.longitude) * Math.PI) / 180;

    const a =
      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // 미터 단위 거리
  }
}
```

---

## 📈 확장성 및 성능 최적화

### Redis 클러스터링

```typescript
// server/redis/redisCluster.ts
export class RedisClusterManager {
  private redisCluster: Cluster;
  private readonly CACHE_TTL = {
    USER_SESSION: 3600,      // 1시간
    QUESTION_CACHE: 1800,    // 30분
    NOTIFICATION_CACHE: 300,  // 5분
    TRENDING_TAGS: 900       // 15분
  };

  constructor() {
    this.redisCluster = new Redis.Cluster([
      { host: 'redis-node-1', port: 6379 },
      { host: 'redis-node-2', port: 6379 },
      { host: 'redis-node-3', port: 6379 }
    ], {
      enableOfflineQueue: false,
      redisOptions: {
        password: process.env.REDIS_PASSWORD,
        connectTimeout: 60000,
        lazyConnect: true,
        maxRetriesPerRequest: 3
      }
    });
  }

  // 사용자 세션 캐싱
  async cacheUserSession(userId: string, session: UserSession) {
    const key = `session:${userId}`;
    await this.redisCluster.setex(
      key,
      this.CACHE_TTL.USER_SESSION,
      JSON.stringify(session)
    );
  }

  async getUserSession(userId: string): Promise<UserSession | null> {
    const key = `session:${userId}`;
    const cached = await this.redisCluster.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  // 질문 캐싱
  async cacheQuestion(questionId: string, question: Question) {
    const key = `question:${questionId}`;
    await this.redisCluster.setex(
      key,
      this.CACHE_TTL.QUESTION_CACHE,
      JSON.stringify(question)
    );
  }

  // 실시간 통계 캐싱
  async updateRealtimeStats(regionCode: string, stats: RegionStats) {
    const key = `stats:${regionCode}`;
    await this.redisCluster.setex(
      key,
      this.CACHE_TTL.TRENDING_TAGS,
      JSON.stringify(stats)
    );
  }

  // 트렌딩 해시태그 캐싱
  async cacheTrendingTags(timeRange: string, tags: TrendingTag[]) {
    const key = `trending:${timeRange}`;
    await this.redisCluster.setex(
      key,
      this.CACHE_TTL.TRENDING_TAGS,
      JSON.stringify(tags)
    );
  }
}
```

### 로드 밸런싱 및 클러스터링

```typescript
// server/cluster/socketCluster.ts
export class SocketCluster {
  private servers: SocketServer[] = [];
  private loadBalancer: LoadBalancer;

  constructor() {
    this.setupCluster();
    this.setupLoadBalancer();
  }

  private setupCluster() {
    const numCPUs = os.cpus().length;
    const numWorkers = Math.min(numCPUs, parseInt(process.env.MAX_WORKERS || '4'));

    if (cluster.isMaster) {
      console.log(`Master ${process.pid} is running`);

      // 워커 프로세스 생성
      for (let i = 0; i < numWorkers; i++) {
        cluster.fork();
      }

      cluster.on('exit', (worker, code, signal) => {
        console.log(`Worker ${worker.process.pid} died`);
        cluster.fork(); // 자동 재시작
      });
    } else {
      // 워커 프로세스에서 Socket.io 서버 실행
      const server = new SocketServer(this.createHttpServer());
      this.servers.push(server);
      console.log(`Worker ${process.pid} started`);
    }
  }

  private setupLoadBalancer() {
    this.loadBalancer = new LoadBalancer({
      algorithm: 'round-robin',
      healthCheck: {
        interval: 30000,
        timeout: 5000,
        retries: 3
      }
    });

    // 서버 인스턴스 등록
    this.servers.forEach((server, index) => {
      this.loadBalancer.addServer({
        id: `worker-${index}`,
        host: 'localhost',
        port: 3001 + index,
        weight: 1
      });
    });
  }
}
```

### 메시지 큐 시스템

```typescript
// server/queue/messageQueue.ts
import Bull from 'bull';

export class MessageQueue {
  private notificationQueue: Bull.Queue;
  private emailQueue: Bull.Queue;
  private pushNotificationQueue: Bull.Queue;

  constructor() {
    const redisConfig = {
      redis: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT || '6379'),
        password: process.env.REDIS_PASSWORD
      }
    };

    this.notificationQueue = new Bull('notification', redisConfig);
    this.emailQueue = new Bull('email', redisConfig);
    this.pushNotificationQueue = new Bull('push-notification', redisConfig);

    this.setupQueueProcessors();
  }

  private setupQueueProcessors() {
    // 일반 알림 처리 (높은 동시성)
    this.notificationQueue.process(10, async (job) => {
      const { userId, notification } = job.data;
      await NotificationManager.sendSocketNotification(userId, notification);
    });

    // 이메일 처리 (중간 동시성)
    this.emailQueue.process(5, async (job) => {
      const { email, subject, content } = job.data;
      await EmailService.send(email, subject, content);
    });

    // 푸시 알림 처리 (낮은 동시성, 높은 신뢰성)
    this.pushNotificationQueue.process(2, async (job) => {
      const { deviceToken, payload } = job.data;
      await PushNotificationService.send(deviceToken, payload);
    });
  }

  async addNotificationJob(userId: string, notification: Notification, priority = 0) {
    await this.notificationQueue.add(
      'send-notification',
      { userId, notification },
      {
        priority,
        attempts: 3,
        backoff: 'exponential',
        delay: priority > 0 ? 0 : 1000 // 높은 우선순위는 즉시 처리
      }
    );
  }

  async addBulkNotifications(notifications: BulkNotification[]) {
    const jobs = notifications.map(notif => ({
      name: 'send-notification',
      data: notif,
      opts: {
        priority: notif.priority || 0,
        attempts: 3,
        backoff: 'exponential'
      }
    }));

    await this.notificationQueue.addBulk(jobs);
  }
}
```

---

## 🔒 보안 및 안정성

### 연결 보안

```typescript
// server/security/socketSecurity.ts
export class SocketSecurity {
  static setupSecurityMiddleware(io: Server) {
    // Rate Limiting
    const rateLimiter = new Map<string, RateLimitData>();

    io.use((socket, next) => {
      const clientIP = socket.handshake.address;
      const now = Date.now();
      const windowMs = 60000; // 1분 윈도우
      const maxRequests = 100; // 분당 최대 100개 요청

      if (!rateLimiter.has(clientIP)) {
        rateLimiter.set(clientIP, {
          requests: 1,
          windowStart: now
        });
        return next();
      }

      const clientData = rateLimiter.get(clientIP)!;

      // 윈도우 재설정
      if (now - clientData.windowStart > windowMs) {
        clientData.requests = 1;
        clientData.windowStart = now;
        return next();
      }

      // Rate limit 검사
      if (clientData.requests >= maxRequests) {
        return next(new Error('Rate limit exceeded'));
      }

      clientData.requests++;
      next();
    });

    // IP 블랙리스트 검사
    io.use(async (socket, next) => {
      const clientIP = socket.handshake.address;
      const isBlocked = await this.checkIPBlacklist(clientIP);

      if (isBlocked) {
        return next(new Error('IP blocked'));
      }

      next();
    });
  }

  // 메시지 검증 및 새니타이제이션
  static validateMessage(message: any): ValidationResult {
    const errors: string[] = [];

    // 메시지 길이 검증
    if (message.content && message.content.length > 1000) {
      errors.push('Message too long');
    }

    // HTML 태그 제거
    if (message.content) {
      message.content = this.sanitizeHTML(message.content);
    }

    // 스팸 키워드 검사
    if (this.containsSpam(message.content)) {
      errors.push('Message contains spam content');
    }

    // 해시태그 검증
    if (message.hashtags && message.hashtags.length > 5) {
      errors.push('Too many hashtags');
    }

    return {
      isValid: errors.length === 0,
      errors,
      sanitizedMessage: message
    };
  }

  private static sanitizeHTML(content: string): string {
    return content
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<[^>]*>/g, '')
      .trim();
  }

  private static containsSpam(content: string): boolean {
    const spamPatterns = [
      /광고/gi,
      /홍보/gi,
      /할인/gi,
      /무료/gi,
      /클릭/gi
    ];

    return spamPatterns.some(pattern => pattern.test(content));
  }
}
```

### 자동 재연결 시스템

```typescript
// client/socket/reconnection.ts
export class ReconnectionManager {
  private socket: Socket;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectInterval = 1000;
  private isReconnecting = false;

  constructor(socket: Socket) {
    this.socket = socket;
    this.setupEventHandlers();
  }

  private setupEventHandlers() {
    this.socket.on('disconnect', (reason) => {
      console.log('Socket disconnected:', reason);

      if (reason === 'io server disconnect') {
        // 서버에서 강제로 연결을 끊은 경우 재연결하지 않음
        return;
      }

      this.startReconnection();
    });

    this.socket.on('connect', () => {
      console.log('Socket reconnected');
      this.reconnectAttempts = 0;
      this.isReconnecting = false;

      // 재연결 후 상태 복구
      this.restoreState();
    });

    this.socket.on('reconnect_error', (error) => {
      console.error('Reconnection failed:', error);
      this.handleReconnectionError();
    });
  }

  private startReconnection() {
    if (this.isReconnecting) return;

    this.isReconnecting = true;
    this.attemptReconnection();
  }

  private attemptReconnection() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      this.onReconnectionFailed();
      return;
    }

    this.reconnectAttempts++;
    const delay = this.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1);

    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms`);

    setTimeout(() => {
      if (!this.socket.connected) {
        this.socket.connect();
      }
    }, delay);
  }

  private restoreState() {
    // 재연결 후 이전 상태 복구
    const savedState = this.getSavedState();

    if (savedState.currentQuestionId) {
      this.socket.emit('join_question', {
        questionId: savedState.currentQuestionId
      });
    }

    if (savedState.userLocation) {
      this.socket.emit('update_location', savedState.userLocation);
    }

    // 읽지 않은 메시지 동기화
    this.socket.emit('sync_unread_messages', {
      lastSyncTimestamp: savedState.lastSyncTimestamp
    });
  }

  private getSavedState(): SavedState {
    const saved = localStorage.getItem('socketState');
    return saved ? JSON.parse(saved) : {};
  }

  private saveState(state: Partial<SavedState>) {
    const currentState = this.getSavedState();
    const newState = { ...currentState, ...state };
    localStorage.setItem('socketState', JSON.stringify(newState));
  }

  private onReconnectionFailed() {
    // 재연결 실패 시 사용자에게 알림
    this.showReconnectionFailedMessage();

    // 오프라인 모드로 전환
    this.enableOfflineMode();
  }

  private showReconnectionFailedMessage() {
    // UI에 연결 실패 메시지 표시
    const event = new CustomEvent('socket-reconnection-failed');
    window.dispatchEvent(event);
  }

  private enableOfflineMode() {
    // 오프라인 모드 활성화
    const event = new CustomEvent('socket-offline-mode');
    window.dispatchEvent(event);
  }
}
```

---

## 📊 모니터링 및 디버깅

### 10분 목표 달성 모니터링 대시보드

```typescript
// server/monitoring/responseTimeMonitoring.ts
export class ResponseTimeMonitoring {
  private static metrics = {
    connectedUsers: 0,
    totalMessages: 0,
    messageRate: 0,
    errorRate: 0,
    averageResponseTime: 0,
    // 제주도 특화 지표
    under10MinuteResponseRate: 0,  // 10분 내 답변율
    under5MinuteResponseRate: 0,   // 5분 내 답변율
    under1MinuteResponseRate: 0,   // 1분 내 답변율
    locationBasedResponseTime: {},  // 지역별 응답시간
    urgentQuestionResponseTime: 0   // 긴급 질문 응답시간
  };

  static startMonitoring(io: Server) {
    // 연결된 사용자 수 추적
    io.on('connection', (socket) => {
      this.metrics.connectedUsers++;
      this.updateDashboard();

      socket.on('disconnect', () => {
        this.metrics.connectedUsers--;
        this.updateDashboard();
      });
    });

    // 10분 목표 응답시간 추적
    this.trackResponseTimes();

    // 지역별 응답성능 추적
    this.trackLocationBasedPerformance();

    // 긴급 질문 특별 추적
    this.trackUrgentQuestions();

    // 실시간 대시보드 업데이트 (1초마다)
    setInterval(() => {
      this.updateRealtimeDashboard();
    }, 1000);
  }

  private static trackResponseTimes() {
    // 질문 등록 시간 기록
    io.on('question_created', (questionData) => {
      const questionId = questionData.question.id;
      RedisCache.set(`question_start_${questionId}`, Date.now());
    });

    // 첫 번째 답변 등록 시 응답시간 계산
    io.on('first_answer_received', (answerData) => {
      const questionId = answerData.questionId;
      const startTime = RedisCache.get(`question_start_${questionId}`);

      if (startTime) {
        const responseTime = Date.now() - startTime;

        // 응답시간 카테고리별 분류
        if (responseTime <= 60000) { // 1분 이내
          this.metrics.under1MinuteResponseRate++;
        }
        if (responseTime <= 300000) { // 5분 이내
          this.metrics.under5MinuteResponseRate++;
        }
        if (responseTime <= 600000) { // 10분 이내
          this.metrics.under10MinuteResponseRate++;
        }

        // 10분 초과 시 알람
        if (responseTime > 600000) {
          this.alertSlowResponse(questionId, responseTime);
        }

        // 평균 응답시간 업데이트
        this.updateAverageResponseTime(responseTime);
      }
    });
  }

  private static trackLocationBasedPerformance() {
    // 지역별 응답시간 추적
    const jejuRegions = ['애월', '한림', '제주시', '조천', '구좌', '성산', '표선', '남원', '서귀포', '안덕', '대정'];

    jejuRegions.forEach(region => {
      this.metrics.locationBasedResponseTime[region] = {
        averageTime: 0,
        questionCount: 0,
        under10MinRate: 0
      };
    });
  }

  private static alertSlowResponse(questionId: string, responseTime: number) {
    // 10분 초과 시 관리자에게 즉시 알림
    io.to('admin-room').emit('slow_response_alert', {
      questionId,
      responseTime,
      message: `질문 ${questionId}이 ${Math.round(responseTime/60000)}분 후에 첫 답변을 받았습니다.`,
      urgency: 'high'
    });

    // 슬랙/디스코드 등 외부 알림도 전송
    this.sendExternalAlert({
      type: 'SLOW_RESPONSE',
      questionId,
      responseTime: Math.round(responseTime/60000),
      threshold: 10
    });
  }

  private static trackMessageRate() {
    let messageCount = 0;
    const startTime = Date.now();

    // 모든 메시지 이벤트 추적
    const originalEmit = io.emit;
    io.emit = function(...args) {
      messageCount++;
      return originalEmit.apply(this, args);
    };

    setInterval(() => {
      const elapsed = (Date.now() - startTime) / 1000;
      this.metrics.messageRate = messageCount / elapsed;
      messageCount = 0;
    }, 60000); // 1분마다 계산
  }

  private static async collectMetrics() {
    // Redis에서 통계 수집
    const redis = new Redis(process.env.REDIS_URL);

    // 활성 룸 수
    const activeRooms = await redis.scard('active-rooms');

    // 처리 대기 중인 작업 수
    const pendingJobs = await redis.llen('bull:notification:waiting');

    // 메모리 사용량
    const memoryUsage = process.memoryUsage();

    // CPU 사용률
    const cpuUsage = process.cpuUsage();

    return {
      activeRooms,
      pendingJobs,
      memoryUsage,
      cpuUsage,
      uptime: process.uptime()
    };
  }

  static async updateDashboard() {
    const metrics = await this.collectMetrics();

    // 관리자 대시보드에 실시간 전송
    io.to('admin-dashboard').emit('metrics-update', {
      ...this.metrics,
      ...metrics,
      timestamp: new Date()
    });

    // 외부 모니터링 시스템에 전송 (DataDog, New Relic 등)
    if (process.env.MONITORING_WEBHOOK) {
      await this.sendToMonitoringService(metrics);
    }
  }

  private static async sendToMonitoringService(metrics: any) {
    try {
      await fetch(process.env.MONITORING_WEBHOOK!, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          service: 'dongne-socket-server',
          metrics,
          timestamp: new Date().toISOString()
        })
      });
    } catch (error) {
      console.error('Failed to send metrics to monitoring service:', error);
    }
  }
}
```

### 로그 시스템

```typescript
// server/logging/socketLogger.ts
export class SocketLogger {
  private logger: winston.Logger;

  constructor() {
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      ),
      transports: [
        new winston.transports.File({ filename: 'logs/socket-error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/socket-combined.log' }),
        new winston.transports.Console({
          format: winston.format.simple()
        })
      ]
    });
  }

  logConnection(socket: Socket) {
    this.logger.info('User connected', {
      socketId: socket.id,
      userId: socket.userId,
      ip: socket.handshake.address,
      userAgent: socket.handshake.headers['user-agent'],
      timestamp: new Date()
    });
  }

  logDisconnection(socket: Socket, reason: string) {
    this.logger.info('User disconnected', {
      socketId: socket.id,
      userId: socket.userId,
      reason,
      connectionDuration: Date.now() - socket.connectedAt,
      timestamp: new Date()
    });
  }

  logMessage(socket: Socket, event: string, data: any) {
    this.logger.debug('Message received', {
      socketId: socket.id,
      userId: socket.userId,
      event,
      dataSize: JSON.stringify(data).length,
      timestamp: new Date()
    });
  }

  logError(socket: Socket, error: Error, context?: any) {
    this.logger.error('Socket error', {
      socketId: socket.id,
      userId: socket.userId,
      error: error.message,
      stack: error.stack,
      context,
      timestamp: new Date()
    });
  }

  logPerformance(event: string, duration: number, metadata?: any) {
    this.logger.info('Performance metric', {
      event,
      duration,
      metadata,
      timestamp: new Date()
    });
  }
}
```

---

## 🚀 배포 및 운영

### Docker 컨테이너 설정

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# 의존성 설치
COPY package*.json ./
RUN npm ci --only=production

# 애플리케이션 코드 복사
COPY . .

# 빌드
RUN npm run build

# 비root 사용자 생성
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

USER nextjs

EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["npm", "start"]
```

### Kubernetes 배포 설정

```yaml
# k8s/socket-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dongne-socket-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: dongne-socket-server
  template:
    metadata:
      labels:
        app: dongne-socket-server
    spec:
      containers:
      - name: socket-server
        image: dongne/socket-server:latest
        ports:
        - containerPort: 3000
        env:
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: dongne-socket-service
spec:
  selector:
    app: dongne-socket-server
  ports:
  - port: 80
    targetPort: 3000
  type: LoadBalancer
```

이 실시간 시스템 아키텍처 문서는 "동네물어봐" 서비스의 핵심인 실시간 기능을 안정적이고 확장 가능하게 구현하기 위한 포괄적인 가이드를 제공합니다.

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "UX \ud50c\ub85c\uc6b0 \uc0c1\uc138 \ubb38\uc11c\ud654 - \uc640\uc774\uc5b4\ud504\ub808\uc784 \ubc0f \uc0ac\uc6a9\uc790 \uc2dc\ub098\ub9ac\uc624 \uc791\uc131", "status": "completed", "activeForm": "UX \ud50c\ub85c\uc6b0 \uc0c1\uc138 \ubb38\uc11c\ud654 - \uc640\uc774\uc5b4\ud504\ub808\uc784 \ubc0f \uc0ac\uc6a9\uc790 \uc2dc\ub098\ub9ac\uc624 \uc791\uc131 \uc911"}, {"content": "\uc5ec\ud589 \uc804-\uc911-\ud6c4 \ub2e8\uacc4\ubcc4 \ucef4\ud3ec\ub10c\ud2b8 \uad6c\uc870 \uc124\uacc4 \ubb38\uc11c \uc791\uc131", "status": "completed", "activeForm": "\uc5ec\ud589 \uc804-\uc911-\ud6c4 \ub2e8\uacc4\ubcc4 \ucef4\ud3ec\ub10c\ud2b8 \uad6c\uc870 \uc124\uacc4 \ubb38\uc11c \uc791\uc131 \uc911"}, {"content": "\uba54\uc2dc\uc9c0 \uc2a4\ud0c0\uc77c \uc778\ud130\ud398\uc774\uc2a4 \uc0c1\ud638\uc791\uc6a9 \uba85\uc138\uc11c \uc791\uc131", "status": "completed", "activeForm": "\uba54\uc2dc\uc9c0 \uc2a4\ud0c0\uc77c \uc778\ud130\ud398\uc774\uc2a4 \uc0c1\ud638\uc791\uc6a9 \uba85\uc138\uc11c \uc791\uc131 \uc911"}, {"content": "\uc2e4\uc2dc\uac04 \uc2dc\uc2a4\ud15c \uc544\ud0a4\ud14d\ucc98 \uae30\uc220 \ubb38\uc11c \uc791\uc131", "status": "completed", "activeForm": "\uc2e4\uc2dc\uac04 \uc2dc\uc2a4\ud15c \uc544\ud0a4\ud14d\ucc98 \uae30\uc220 \ubb38\uc11c \uc791\uc131 \uc911"}]