# "동네물어봐" 종합 기술 아키텍처 설계서

## 📋 목차
1. [아키텍처 개요](#-아키텍처-개요)
2. [시스템 아키텍처 다이어그램](#-시스템-아키텍처-다이어그램)
3. [마이크로서비스 아키텍처 설계](#-마이크로서비스-아키텍처-설계)
4. [클라우드 네이티브 아키텍처](#-클라우드-네이티브-아키텍처)
5. [확장성 설계 전략](#-확장성-설계-전략)
6. [고가용성 및 재해복구](#-고가용성-및-재해복구)
7. [성능 최적화 전략](#-성능-최적화-전략)
8. [기술 스택 선정](#-기술-스택-선정)
9. [개발 및 배포 파이프라인](#-개발-및-배포-파이프라인)
10. [비용 최적화 전략](#-비용-최적화-전략)

---

## 🏗️ 아키텍처 개요

### 설계 철학

"동네물어봐"는 제주도에서 시작하여 전국으로 확장하는 지역 기반 Q&A 커뮤니티 서비스로, 다음과 같은 핵심 원칙을 바탕으로 설계됩니다:

#### 1. 확장성 우선 설계 (Scalability First)
- **수평 확장 가능**: 트래픽 증가에 따른 서버 자동 스케일링
- **지역별 확장 대비**: 제주도 → 부산, 강릉 등 점진적 확장 고려
- **글로벌 확장 가능**: 향후 해외 진출시 멀티리전 지원

#### 2. 안정성 및 가용성 (Reliability & Availability)
- **99.9% 가용성 목표**: 연간 다운타임 8.76시간 이하
- **장애 허용 설계**: 부분 장애 발생시에도 서비스 지속
- **자동 복구**: 인프라 장애시 자동 페일오버

#### 3. 성능 최적화 (Performance Optimization)
- **10분 내 답변 목표**: 제주도 특성 반영한 실시간 응답 시스템
- **저지연 네트워크**: Edge CDN 활용으로 한국 전역 100ms 이하 응답
- **효율적 캐싱**: 다층 캐싱으로 DB 부하 최소화

#### 4. 비용 효율성 (Cost Efficiency)
- **단계별 비용 최적화**: MVP → 확장 단계별 인프라 비용 관리
- **서버리스 우선**: 트래픽 변동에 따른 자동 비용 조절
- **오픈소스 활용**: 라이선스 비용 최소화

### 아키텍처 목표

```mermaid
graph TB
    subgraph "Phase 1: MVP (0-1k users)"
        A[Monolithic Architecture]
        A --> B[Single Region Deployment]
        A --> C[Basic Monitoring]
    end

    subgraph "Phase 2: Growth (1k-10k users)"
        D[Microservices Migration]
        D --> E[Multi-AZ Deployment]
        D --> F[Advanced Monitoring]
    end

    subgraph "Phase 3: Scale (10k-100k users)"
        G[Multi-Region Architecture]
        G --> H[Global CDN]
        G --> I[Auto-scaling]
    end

    subgraph "Phase 4: Enterprise (100k+ users)"
        J[Global Multi-Cloud]
        J --> K[Edge Computing]
        J --> L[ML/AI Integration]
    end

    A --> D --> G --> J
```

---

## 🏛️ 시스템 아키텍처 다이어그램

### 전체 시스템 아키텍처

```mermaid
C4Context
    title System Context Diagram for "동네물어봐"

    Person(user, "일반 사용자", "제주 여행자 및 현지인")
    Person(admin, "관리자", "커뮤니티 운영진")
    Person(business, "제휴업체", "맛집, 숙소 사업자")

    System(dongne, "동네물어봐 시스템", "지역 기반 Q&A 커뮤니티 플랫폼")

    System_Ext(kakao, "카카오 서비스", "로그인, 맵, 알림")
    System_Ext(naver, "네이버 서비스", "로그인, 맵, 클라우드")
    System_Ext(google, "Google 서비스", "로그인, 맵, 클라우드")
    System_Ext(aws, "AWS", "클라우드 인프라")
    System_Ext(payment, "결제 시스템", "포인트 충전, 프리미엄")

    Rel(user, dongne, "질문/답변 작성", "HTTPS")
    Rel(admin, dongne, "관리 및 모니터링", "HTTPS")
    Rel(business, dongne, "업체 정보 관리", "HTTPS")

    Rel(dongne, kakao, "소셜 로그인, 지도 API")
    Rel(dongne, naver, "소셜 로그인, 지도 API")
    Rel(dongne, google, "소셜 로그인, 클라우드 서비스")
    Rel(dongne, aws, "인프라 및 서비스")
    Rel(dongne, payment, "결제 처리")
```

### 컨테이너 레벨 아키텍처

```mermaid
C4Container
    title Container Diagram for "동네물어봐"

    Person(user, "사용자")

    Container_Boundary(c1, "동네물어봐 시스템") {
        Container(webapp, "웹 애플리케이션", "Next.js", "반응형 웹 UI")
        Container(mobile, "모바일 앱", "React Native", "iOS/Android 앱")
        Container(api, "API Gateway", "Express.js", "API 라우팅 및 인증")

        Container(user_service, "사용자 서비스", "Node.js", "인증, 프로필 관리")
        Container(qa_service, "Q&A 서비스", "Node.js", "질문, 답변, 채택")
        Container(notification_service, "알림 서비스", "Node.js", "실시간 알림")
        Container(location_service, "위치 서비스", "Node.js", "GPS, 지역 관리")
        Container(search_service, "검색 서비스", "Node.js", "통합 검색")

        ContainerDb(postgres, "PostgreSQL", "관계형 DB", "주요 데이터 저장")
        ContainerDb(redis, "Redis", "캐시 DB", "세션, 캐시")
        ContainerDb(elasticsearch, "Elasticsearch", "검색 DB", "전문 검색")
        ContainerDb(s3, "AWS S3", "객체 스토리지", "이미지, 파일")
    }

    Container_Ext(kakao_api, "카카오 API")
    Container_Ext(monitoring, "모니터링", "DataDog/CloudWatch")

    Rel(user, webapp, "사용", "HTTPS")
    Rel(user, mobile, "사용", "HTTPS")

    Rel(webapp, api, "API 호출", "HTTPS")
    Rel(mobile, api, "API 호출", "HTTPS")

    Rel(api, user_service, "사용자 요청")
    Rel(api, qa_service, "Q&A 요청")
    Rel(api, notification_service, "알림 요청")
    Rel(api, location_service, "위치 요청")
    Rel(api, search_service, "검색 요청")

    Rel(user_service, postgres, "읽기/쓰기")
    Rel(qa_service, postgres, "읽기/쓰기")
    Rel(notification_service, redis, "읽기/쓰기")
    Rel(search_service, elasticsearch, "읽기/쓰기")

    Rel(api, kakao_api, "외부 API 호출")
    Rel(api, monitoring, "메트릭 전송")
```

### 배포 아키텍처

```mermaid
graph TB
    subgraph "사용자 레이어"
        WEB[웹 브라우저]
        MOBILE[모바일 앱]
        ADMIN[관리자 대시보드]
    end

    subgraph "CDN & 로드밸런서"
        CDN[CloudFront CDN]
        ALB[Application Load Balancer]
    end

    subgraph "애플리케이션 레이어 (Multi-AZ)"
        subgraph "AZ-1"
            WEB1[Next.js App]
            API1[API Server]
        end
        subgraph "AZ-2"
            WEB2[Next.js App]
            API2[API Server]
        end
        subgraph "AZ-3"
            WEB3[Next.js App]
            API3[API Server]
        end
    end

    subgraph "마이크로서비스 레이어"
        USER_SVC[User Service]
        QA_SVC[Q&A Service]
        NOTIF_SVC[Notification Service]
        LOC_SVC[Location Service]
        SEARCH_SVC[Search Service]
    end

    subgraph "데이터 레이어"
        subgraph "Primary DB"
            PG_MASTER[PostgreSQL Master]
        end
        subgraph "Read Replicas"
            PG_SLAVE1[PostgreSQL Slave 1]
            PG_SLAVE2[PostgreSQL Slave 2]
        end
        REDIS_CLUSTER[Redis Cluster]
        ES_CLUSTER[Elasticsearch Cluster]
        S3[AWS S3]
    end

    subgraph "외부 서비스"
        KAKAO[카카오 API]
        NAVER[네이버 API]
        GOOGLE[구글 API]
    end

    subgraph "모니터링 & 로깅"
        CLOUDWATCH[CloudWatch]
        DATADOG[DataDog]
        SENTRY[Sentry]
        ELK[ELK Stack]
    end

    WEB --> CDN
    MOBILE --> ALB
    ADMIN --> ALB

    CDN --> ALB
    ALB --> WEB1
    ALB --> WEB2
    ALB --> WEB3

    WEB1 --> API1
    WEB2 --> API2
    WEB3 --> API3

    API1 --> USER_SVC
    API1 --> QA_SVC
    API2 --> NOTIF_SVC
    API2 --> LOC_SVC
    API3 --> SEARCH_SVC

    USER_SVC --> PG_MASTER
    QA_SVC --> PG_SLAVE1
    LOC_SVC --> PG_SLAVE2

    NOTIF_SVC --> REDIS_CLUSTER
    SEARCH_SVC --> ES_CLUSTER

    API1 --> S3
    API2 --> S3
    API3 --> S3

    API1 --> KAKAO
    API1 --> NAVER
    API1 --> GOOGLE

    API1 --> CLOUDWATCH
    API2 --> DATADOG
    API3 --> SENTRY
```

---

## 🔧 마이크로서비스 아키텍처 설계

### 서비스 분할 전략

#### 1. 도메인 기반 분할 (Domain-Driven Design)

```typescript
// 서비스 경계 정의
interface ServiceBoundary {
  name: string;
  domain: string;
  responsibilities: string[];
  interfaces: APIEndpoint[];
  databases: Database[];
  dependencies: ServiceDependency[];
}

const services: ServiceBoundary[] = [
  {
    name: "user-service",
    domain: "User Management",
    responsibilities: [
      "사용자 인증 및 인가",
      "프로필 관리",
      "소셜 로그인 통합",
      "권한 관리"
    ],
    interfaces: [
      { method: "POST", path: "/auth/login", description: "로그인" },
      { method: "GET", path: "/users/:id", description: "사용자 정보 조회" },
      { method: "PUT", path: "/users/:id", description: "프로필 업데이트" }
    ],
    databases: ["postgres-users", "redis-sessions"],
    dependencies: ["external-oauth-providers"]
  },
  {
    name: "qa-service",
    domain: "Question & Answer",
    responsibilities: [
      "질문 생성, 수정, 삭제",
      "답변 생성, 수정, 삭제",
      "채택 시스템 관리",
      "포인트 적립 처리"
    ],
    interfaces: [
      { method: "POST", path: "/questions", description: "질문 등록" },
      { method: "POST", path: "/answers", description: "답변 등록" },
      { method: "PUT", path: "/answers/:id/accept", description: "답변 채택" }
    ],
    databases: ["postgres-qa"],
    dependencies: ["user-service", "notification-service"]
  },
  {
    name: "notification-service",
    domain: "Real-time Notifications",
    responsibilities: [
      "실시간 알림 전송",
      "푸시 알림 관리",
      "이메일 알림",
      "알림 설정 관리"
    ],
    interfaces: [
      { method: "POST", path: "/notifications", description: "알림 전송" },
      { method: "GET", path: "/notifications/:userId", description: "알림 목록" }
    ],
    databases: ["redis-notifications"],
    dependencies: ["user-service", "external-push-services"]
  },
  {
    name: "location-service",
    domain: "Geographic Services",
    responsibilities: [
      "위치 기반 검색",
      "지역 관리",
      "GPS 좌표 처리",
      "거리 계산"
    ],
    interfaces: [
      { method: "POST", path: "/locations", description: "위치 등록" },
      { method: "GET", path: "/locations/nearby", description: "주변 검색" }
    ],
    databases: ["postgres-geo"],
    dependencies: ["external-map-apis"]
  },
  {
    name: "search-service",
    domain: "Search & Discovery",
    responsibilities: [
      "통합 검색",
      "해시태그 관리",
      "검색 최적화",
      "트렌딩 분석"
    ],
    interfaces: [
      { method: "GET", path: "/search", description: "통합 검색" },
      { method: "GET", path: "/trending", description: "트렌딩 해시태그" }
    ],
    databases: ["elasticsearch"],
    dependencies: ["qa-service", "user-service"]
  }
];
```

#### 2. 서비스 간 통신 패턴

```typescript
// 이벤트 기반 통신 (Event-Driven Architecture)
interface EventPattern {
  eventType: string;
  publisher: string;
  subscribers: string[];
  payload: any;
  deliveryGuarantee: 'at-least-once' | 'exactly-once' | 'at-most-once';
}

const eventPatterns: EventPattern[] = [
  {
    eventType: "user.registered",
    publisher: "user-service",
    subscribers: ["notification-service", "analytics-service"],
    payload: {
      userId: "string",
      email: "string",
      createdAt: "timestamp"
    },
    deliveryGuarantee: "at-least-once"
  },
  {
    eventType: "question.created",
    publisher: "qa-service",
    subscribers: ["notification-service", "search-service", "location-service"],
    payload: {
      questionId: "string",
      userId: "string",
      location: "geopoint",
      hashtags: "string[]",
      urgency: "normal | urgent"
    },
    deliveryGuarantee: "exactly-once"
  },
  {
    eventType: "answer.accepted",
    publisher: "qa-service",
    subscribers: ["notification-service", "user-service"],
    payload: {
      answerId: "string",
      questionId: "string",
      answererId: "string",
      questionerId: "string",
      points: "number"
    },
    deliveryGuarantee: "exactly-once"
  }
];
```

#### 3. API Gateway 설계

```typescript
// API Gateway 라우팅 규칙
interface RouteRule {
  path: string;
  method: string;
  service: string;
  version: string;
  authentication: boolean;
  rateLimit: RateLimit;
  caching: CacheConfig;
}

const apiRoutes: RouteRule[] = [
  {
    path: "/api/v1/auth/*",
    method: "*",
    service: "user-service",
    version: "v1",
    authentication: false,
    rateLimit: { requests: 10, window: "1m" },
    caching: { enabled: false }
  },
  {
    path: "/api/v1/questions",
    method: "GET",
    service: "qa-service",
    version: "v1",
    authentication: false,
    rateLimit: { requests: 100, window: "1m" },
    caching: { enabled: true, ttl: "5m" }
  },
  {
    path: "/api/v1/questions",
    method: "POST",
    service: "qa-service",
    version: "v1",
    authentication: true,
    rateLimit: { requests: 5, window: "1m" },
    caching: { enabled: false }
  },
  {
    path: "/api/v1/search",
    method: "GET",
    service: "search-service",
    version: "v1",
    authentication: false,
    rateLimit: { requests: 50, window: "1m" },
    caching: { enabled: true, ttl: "10m" }
  }
];
```

#### 4. 서비스 메시 (Service Mesh) 구성

```yaml
# Istio 서비스 메시 설정
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: dongne-services
spec:
  hosts:
  - api.dongnemuleoboa.com
  http:
  - match:
    - uri:
        prefix: "/api/v1/auth"
    route:
    - destination:
        host: user-service
        port:
          number: 3001
    timeout: 30s
    retries:
      attempts: 3
      perTryTimeout: 10s
  - match:
    - uri:
        prefix: "/api/v1/questions"
    route:
    - destination:
        host: qa-service
        port:
          number: 3002
    timeout: 30s
  - match:
    - uri:
        prefix: "/api/v1/notifications"
    route:
    - destination:
        host: notification-service
        port:
          number: 3003
    timeout: 10s

---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: user-service-circuit-breaker
spec:
  host: user-service
  trafficPolicy:
    circuitBreaker:
      consecutiveErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
    loadBalancer:
      simple: LEAST_CONN
```

---

## ☁️ 클라우드 네이티브 아키텍처

### 컨테이너화 전략

#### 1. Docker 멀티스테이지 빌드

```dockerfile
# 사용자 서비스 Dockerfile
FROM node:18-alpine AS base
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build
RUN npm prune --production

FROM node:18-alpine AS runtime
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001
WORKDIR /app
COPY --from=build --chown=nextjs:nodejs /app/dist ./dist
COPY --from=build --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=build --chown=nextjs:nodejs /app/package.json ./package.json

USER nextjs
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["node", "dist/index.js"]
```

#### 2. Kubernetes 매니페스트

```yaml
# user-service 배포 설정
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  labels:
    app: user-service
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
        version: v1
    spec:
      containers:
      - name: user-service
        image: dongne/user-service:v1.0.0
        ports:
        - containerPort: 3000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: user-service-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-credentials
              key: url
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: jwt-secret
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
      volumes:
      - name: config-volume
        configMap:
          name: user-service-config

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 80
    targetPort: 3000
    protocol: TCP
  type: ClusterIP

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: user-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: user-service
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

#### 3. Helm 차트 구조

```yaml
# Chart.yaml
apiVersion: v2
name: dongne-services
description: 동네물어봐 마이크로서비스 Helm 차트
type: application
version: 1.0.0
appVersion: "1.0.0"

dependencies:
- name: postgresql
  version: 11.6.12
  repository: https://charts.bitnami.com/bitnami
  condition: postgresql.enabled
- name: redis
  version: 16.13.2
  repository: https://charts.bitnami.com/bitnami
  condition: redis.enabled
- name: elasticsearch
  version: 19.5.0
  repository: https://helm.elastic.co
  condition: elasticsearch.enabled

---
# values.yaml
global:
  imageRegistry: ""
  imagePullSecrets: []
  storageClass: ""

services:
  userService:
    enabled: true
    replicaCount: 3
    image:
      repository: dongne/user-service
      tag: "v1.0.0"
      pullPolicy: IfNotPresent
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "256Mi"
        cpu: "200m"
    autoscaling:
      enabled: true
      minReplicas: 3
      maxReplicas: 20
      targetCPUUtilizationPercentage: 70

  qaService:
    enabled: true
    replicaCount: 3
    image:
      repository: dongne/qa-service
      tag: "v1.0.0"
      pullPolicy: IfNotPresent

postgresql:
  enabled: true
  auth:
    postgresPassword: "changeme"
    database: "dongne_db"
  primary:
    persistence:
      enabled: true
      size: "50Gi"
  readReplicas:
    replicaCount: 2

redis:
  enabled: true
  architecture: "replication"
  auth:
    enabled: true
    password: "changeme"
  master:
    persistence:
      enabled: true
      size: "10Gi"

elasticsearch:
  enabled: true
  replicas: 3
  minimumMasterNodes: 2
  volumeClaimTemplate:
    accessModes: ["ReadWriteOnce"]
    resources:
      requests:
        storage: "30Gi"
```

### 서버리스 아키텍처 통합

#### 1. AWS Lambda 함수 (배치 작업용)

```typescript
// 트렌딩 해시태그 계산 Lambda
import { APIGatewayProxyHandler } from 'aws-lambda';
import { ElasticsearchClient } from '@aws-sdk/client-elasticsearch';

export const calculateTrendingTags: APIGatewayProxyHandler = async (event) => {
  const es = new ElasticsearchClient({ region: 'ap-northeast-2' });

  try {
    // 지난 24시간 해시태그 집계
    const response = await es.send({
      index: 'questions',
      body: {
        aggs: {
          trending_tags: {
            terms: {
              field: 'hashtags',
              size: 20
            },
            aggs: {
              recent_usage: {
                filter: {
                  range: {
                    created_at: {
                      gte: 'now-24h'
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

    // Redis에 캐시 저장
    const trendingTags = response.aggregations.trending_tags.buckets;
    await redis.setex('trending:tags:24h', 3600, JSON.stringify(trendingTags));

    return {
      statusCode: 200,
      body: JSON.stringify({ trendingTags })
    };
  } catch (error) {
    console.error('Error calculating trending tags:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error' })
    };
  }
};
```

#### 2. EventBridge 기반 이벤트 처리

```yaml
# serverless.yml
service: dongne-events

provider:
  name: aws
  runtime: nodejs18.x
  region: ap-northeast-2
  environment:
    ELASTICSEARCH_ENDPOINT: ${env:ELASTICSEARCH_ENDPOINT}
    REDIS_URL: ${env:REDIS_URL}

functions:
  processTrendingTags:
    handler: src/trending.calculateTrendingTags
    events:
      - schedule: rate(1 hour)

  processUserAnalytics:
    handler: src/analytics.processUserBehavior
    events:
      - eventBridge:
          pattern:
            source:
              - dongne.qa-service
            detail-type:
              - Question Created
              - Answer Created

  sendDailyDigest:
    handler: src/digest.sendDailyDigest
    events:
      - schedule: cron(0 9 * * ? *)

  processImageUpload:
    handler: src/images.processImageUpload
    events:
      - s3:
          bucket: dongne-uploads
          event: s3:ObjectCreated:*
          rules:
            - prefix: images/
            - suffix: .jpg
```

---

## 📈 확장성 설계 전략

### 1. 수평 확장 (Horizontal Scaling)

#### Auto Scaling 정책

```typescript
// 자동 스케일링 규칙 정의
interface ScalingPolicy {
  service: string;
  minInstances: number;
  maxInstances: number;
  targetMetrics: ScalingMetric[];
  scaleUpCooldown: number;
  scaleDownCooldown: number;
}

const scalingPolicies: ScalingPolicy[] = [
  {
    service: "qa-service",
    minInstances: 3,
    maxInstances: 50,
    targetMetrics: [
      { name: "cpu", target: 70, type: "percentage" },
      { name: "memory", target: 80, type: "percentage" },
      { name: "request_rate", target: 1000, type: "requests_per_minute" }
    ],
    scaleUpCooldown: 300, // 5분
    scaleDownCooldown: 600 // 10분
  },
  {
    service: "notification-service",
    minInstances: 2,
    maxInstances: 30,
    targetMetrics: [
      { name: "queue_depth", target: 100, type: "count" },
      { name: "message_processing_time", target: 1000, type: "milliseconds" }
    ],
    scaleUpCooldown: 120, // 2분 (알림은 빠른 확장 필요)
    scaleDownCooldown: 600
  }
];
```

#### 로드 밸런싱 전략

```yaml
# Application Load Balancer 설정
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: dongne-ingress
  annotations:
    kubernetes.io/ingress.class: "aws-load-balancer-controller"
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/load-balancer-attributes: |
      routing.http2.enabled=true,
      idle_timeout.timeout_seconds=60,
      access_logs.s3.enabled=true,
      access_logs.s3.bucket=dongne-alb-logs
    alb.ingress.kubernetes.io/ssl-redirect: '443'
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:ap-northeast-2:123456789:certificate/xxx
spec:
  rules:
  - host: api.dongnemuleoboa.com
    http:
      paths:
      - path: /api/v1/auth
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 80
      - path: /api/v1/questions
        pathType: Prefix
        backend:
          service:
            name: qa-service
            port:
              number: 80
      - path: /api/v1/search
        pathType: Prefix
        backend:
          service:
            name: search-service
            port:
              number: 80
```

### 2. 데이터베이스 확장 전략

#### Read Replica 구성

```typescript
// 데이터베이스 연결 관리자
class DatabaseManager {
  private masterConnection: Pool;
  private replicaConnections: Pool[];
  private replicaIndex = 0;

  constructor() {
    this.masterConnection = new Pool({
      host: process.env.DB_MASTER_HOST,
      port: 5432,
      database: 'dongne_db',
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });

    this.replicaConnections = [
      new Pool({
        host: process.env.DB_REPLICA1_HOST,
        port: 5432,
        database: 'dongne_db',
        user: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        max: 20,
      }),
      new Pool({
        host: process.env.DB_REPLICA2_HOST,
        port: 5432,
        database: 'dongne_db',
        user: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        max: 20,
      })
    ];
  }

  // 쓰기 작업은 마스터로
  async write(query: string, params: any[]): Promise<any> {
    return this.masterConnection.query(query, params);
  }

  // 읽기 작업은 레플리카로 (라운드 로빈)
  async read(query: string, params: any[]): Promise<any> {
    const replica = this.getNextReplica();
    try {
      return await replica.query(query, params);
    } catch (error) {
      // 레플리카 실패시 마스터로 폴백
      console.warn('Replica query failed, falling back to master:', error);
      return this.masterConnection.query(query, params);
    }
  }

  private getNextReplica(): Pool {
    const replica = this.replicaConnections[this.replicaIndex];
    this.replicaIndex = (this.replicaIndex + 1) % this.replicaConnections.length;
    return replica;
  }
}
```

#### 샤딩 전략 (멀티리전 확장 대비)

```typescript
// 지역별 데이터 샤딩
interface ShardConfig {
  regionCode: string;
  dbConfig: {
    host: string;
    port: number;
    database: string;
  };
  isActive: boolean;
}

class ShardManager {
  private shards: Map<string, DatabaseManager> = new Map();
  private defaultShard: DatabaseManager;

  constructor(shardConfigs: ShardConfig[]) {
    shardConfigs.forEach(config => {
      if (config.isActive) {
        const dbManager = new DatabaseManager(config.dbConfig);
        this.shards.set(config.regionCode, dbManager);
      }
    });

    // 제주도를 기본 샤드로 설정
    this.defaultShard = this.shards.get('jeju') || this.shards.values().next().value;
  }

  getShardByRegion(regionCode: string): DatabaseManager {
    return this.shards.get(regionCode) || this.defaultShard;
  }

  // 사용자 위치 기반 샤드 선택
  getShardByLocation(latitude: number, longitude: number): DatabaseManager {
    const regionCode = this.determineRegionByCoordinates(latitude, longitude);
    return this.getShardByRegion(regionCode);
  }

  private determineRegionByCoordinates(lat: number, lng: number): string {
    // 제주도 좌표 범위: 33.1-33.6, 126.1-126.9
    if (lat >= 33.1 && lat <= 33.6 && lng >= 126.1 && lng <= 126.9) {
      return 'jeju';
    }
    // 부산 좌표 범위 (향후 확장)
    if (lat >= 35.0 && lat <= 35.3 && lng >= 128.9 && lng <= 129.3) {
      return 'busan';
    }

    return 'default';
  }
}
```

### 3. CDN 및 캐싱 전략

#### 다층 캐싱 아키텍처

```typescript
// 캐싱 계층 관리자
class CacheManager {
  private l1Cache: NodeCache; // 메모리 캐시 (1분)
  private l2Cache: Redis;     // Redis 캐시 (1시간)
  private l3Cache: string;    // CDN 캐시 (1일)

  constructor() {
    this.l1Cache = new NodeCache({ stdTTL: 60 }); // 1분
    this.l2Cache = new Redis(process.env.REDIS_URL);
  }

  async get(key: string): Promise<any> {
    // L1 캐시 확인
    let value = this.l1Cache.get(key);
    if (value !== undefined) {
      return value;
    }

    // L2 캐시 확인
    const redisValue = await this.l2Cache.get(key);
    if (redisValue) {
      value = JSON.parse(redisValue);
      this.l1Cache.set(key, value); // L1에 복사
      return value;
    }

    return null;
  }

  async set(key: string, value: any, ttl?: number): Promise<void> {
    // L1 캐시 저장
    this.l1Cache.set(key, value, ttl || 60);

    // L2 캐시 저장
    await this.l2Cache.setex(key, ttl || 3600, JSON.stringify(value));
  }

  async invalidate(pattern: string): Promise<void> {
    // L1 캐시 무효화
    this.l1Cache.flushAll();

    // L2 캐시 무효화
    const keys = await this.l2Cache.keys(pattern);
    if (keys.length > 0) {
      await this.l2Cache.del(...keys);
    }
  }
}

// 캐싱 전략별 설정
const cacheStrategies = {
  questions: {
    key: (id: string) => `question:${id}`,
    ttl: 1800, // 30분
    strategy: 'cache-aside'
  },
  userProfiles: {
    key: (id: string) => `user:${id}`,
    ttl: 3600, // 1시간
    strategy: 'write-through'
  },
  searchResults: {
    key: (query: string) => `search:${Buffer.from(query).toString('base64')}`,
    ttl: 600, // 10분
    strategy: 'cache-aside'
  },
  trendingTags: {
    key: () => 'trending:tags',
    ttl: 900, // 15분
    strategy: 'refresh-ahead'
  }
};
```

---

## 🛡️ 고가용성 및 재해복구

### 1. Multi-AZ 배포

#### 가용영역별 리소스 분산

```yaml
# 지역별 배포 설정
apiVersion: v1
kind: ConfigMap
metadata:
  name: availability-zones
data:
  primary-az: "ap-northeast-2a"
  secondary-az: "ap-northeast-2b"
  tertiary-az: "ap-northeast-2c"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: qa-service-multi-az
spec:
  replicas: 6
  selector:
    matchLabels:
      app: qa-service
  template:
    metadata:
      labels:
        app: qa-service
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                app: qa-service
            topologyKey: "topology.kubernetes.io/zone"
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            preference:
              matchExpressions:
              - key: topology.kubernetes.io/zone
                operator: In
                values:
                - ap-northeast-2a
                - ap-northeast-2b
                - ap-northeast-2c
      containers:
      - name: qa-service
        image: dongne/qa-service:v1.0.0
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"
```

### 2. 데이터 백업 및 복구

#### 자동화된 백업 시스템

```typescript
// 백업 관리 시스템
class BackupManager {
  private s3Client: S3Client;
  private databases: DatabaseConnection[];

  constructor() {
    this.s3Client = new S3Client({ region: 'ap-northeast-2' });
    this.databases = [
      { name: 'postgres-master', type: 'postgresql' },
      { name: 'redis-cluster', type: 'redis' },
      { name: 'elasticsearch', type: 'elasticsearch' }
    ];
  }

  async createBackup(schedule: BackupSchedule): Promise<BackupResult[]> {
    const results: BackupResult[] = [];

    for (const db of this.databases) {
      try {
        const backupResult = await this.backupDatabase(db, schedule);
        results.push(backupResult);
      } catch (error) {
        console.error(`Backup failed for ${db.name}:`, error);
        results.push({
          database: db.name,
          success: false,
          error: error.message
        });
      }
    }

    return results;
  }

  private async backupDatabase(db: DatabaseConnection, schedule: BackupSchedule): Promise<BackupResult> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupKey = `backups/${db.name}/${schedule.type}/${timestamp}`;

    switch (db.type) {
      case 'postgresql':
        return this.backupPostgreSQL(db, backupKey);
      case 'redis':
        return this.backupRedis(db, backupKey);
      case 'elasticsearch':
        return this.backupElasticsearch(db, backupKey);
      default:
        throw new Error(`Unsupported database type: ${db.type}`);
    }
  }

  private async backupPostgreSQL(db: DatabaseConnection, backupKey: string): Promise<BackupResult> {
    // pg_dump를 사용한 PostgreSQL 백업
    const dumpCommand = `pg_dump ${process.env.DATABASE_URL} --format=custom --compress=9`;
    const backupStream = spawn('pg_dump', [
      process.env.DATABASE_URL!,
      '--format=custom',
      '--compress=9'
    ]);

    // S3에 스트리밍 업로드
    const uploadParams = {
      Bucket: 'dongne-backups',
      Key: `${backupKey}.dump`,
      Body: backupStream.stdout,
      StorageClass: 'GLACIER' as const
    };

    await this.s3Client.send(new PutObjectCommand(uploadParams));

    return {
      database: db.name,
      success: true,
      backupLocation: `s3://dongne-backups/${backupKey}.dump`,
      size: await this.getBackupSize(backupKey),
      timestamp: new Date()
    };
  }

  // 백업 스케줄 관리
  setupBackupSchedules(): void {
    const schedules: BackupSchedule[] = [
      {
        type: 'full',
        cron: '0 2 * * *', // 매일 새벽 2시
        retention: 30 // 30일 보관
      },
      {
        type: 'incremental',
        cron: '0 */6 * * *', // 6시간마다
        retention: 7 // 7일 보관
      },
      {
        type: 'transaction-log',
        cron: '*/15 * * * *', // 15분마다
        retention: 1 // 1일 보관
      }
    ];

    schedules.forEach(schedule => {
      cron.schedule(schedule.cron, async () => {
        await this.createBackup(schedule);
        await this.cleanupOldBackups(schedule);
      });
    });
  }
}
```

### 3. 장애 감지 및 자동 복구

#### Health Check 시스템

```typescript
// 서비스 헬스 체크 시스템
class HealthCheckManager {
  private services: ServiceEndpoint[];
  private alertManager: AlertManager;

  constructor() {
    this.services = [
      { name: 'user-service', url: 'http://user-service/health', timeout: 5000 },
      { name: 'qa-service', url: 'http://qa-service/health', timeout: 5000 },
      { name: 'notification-service', url: 'http://notification-service/health', timeout: 3000 },
      { name: 'postgres-master', url: 'postgres://master/health', timeout: 10000 },
      { name: 'redis-cluster', url: 'redis://cluster/health', timeout: 3000 }
    ];
    this.alertManager = new AlertManager();
  }

  async performHealthChecks(): Promise<HealthCheckResult[]> {
    const promises = this.services.map(service => this.checkService(service));
    return Promise.allSettled(promises).then(results =>
      results.map((result, index) => ({
        service: this.services[index].name,
        healthy: result.status === 'fulfilled' && result.value.healthy,
        responseTime: result.status === 'fulfilled' ? result.value.responseTime : null,
        error: result.status === 'rejected' ? result.reason : null,
        timestamp: new Date()
      }))
    );
  }

  private async checkService(service: ServiceEndpoint): Promise<ServiceHealth> {
    const startTime = Date.now();

    try {
      const response = await axios.get(service.url, {
        timeout: service.timeout,
        validateStatus: (status) => status < 500
      });

      return {
        healthy: response.status === 200,
        responseTime: Date.now() - startTime,
        details: response.data
      };
    } catch (error) {
      throw {
        healthy: false,
        responseTime: Date.now() - startTime,
        error: error.message
      };
    }
  }

  async handleUnhealthyService(service: string, error: any): Promise<void> {
    // 1. 즉시 알림 발송
    await this.alertManager.sendAlert({
      severity: 'critical',
      service,
      message: `Service ${service} is unhealthy: ${error}`,
      timestamp: new Date()
    });

    // 2. 자동 복구 시도
    await this.attemptAutoRecovery(service);

    // 3. 트래픽 재라우팅
    await this.rerouteTraffic(service);
  }

  private async attemptAutoRecovery(service: string): Promise<void> {
    const recoveryActions = {
      'user-service': async () => {
        // Pod 재시작
        await this.restartPods(service);
      },
      'postgres-master': async () => {
        // 마스터 장애시 슬레이브를 마스터로 승격
        await this.promoteSlaveToMaster();
      },
      'redis-cluster': async () => {
        // Redis 클러스터 재구성
        await this.reconfigureRedisCluster();
      }
    };

    const action = recoveryActions[service];
    if (action) {
      await action();
    }
  }
}
```

### 4. 재해복구 (Disaster Recovery)

#### Cross-Region 백업 및 복제

```yaml
# 재해복구 설정
apiVersion: v1
kind: ConfigMap
metadata:
  name: dr-config
data:
  primary-region: "ap-northeast-2"  # 서울
  dr-region: "ap-northeast-1"       # 도쿄
  rto: "4h"                         # Recovery Time Objective
  rpo: "1h"                         # Recovery Point Objective

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dr-sync-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dr-sync
  template:
    metadata:
      labels:
        app: dr-sync
    spec:
      containers:
      - name: dr-sync
        image: dongne/dr-sync:v1.0.0
        env:
        - name: PRIMARY_REGION
          value: "ap-northeast-2"
        - name: DR_REGION
          value: "ap-northeast-1"
        - name: SYNC_INTERVAL
          value: "3600" # 1시간마다 동기화
        command:
        - /bin/sh
        - -c
        - |
          while true; do
            echo "Starting DR sync..."

            # 데이터베이스 스냅샷을 DR 리전으로 복사
            aws rds copy-db-snapshot \
              --source-db-snapshot-identifier dongne-db-snapshot-$(date +%Y%m%d%H) \
              --target-db-snapshot-identifier dongne-db-dr-$(date +%Y%m%d%H) \
              --source-region ap-northeast-2 \
              --region ap-northeast-1

            # S3 데이터를 DR 리전으로 동기화
            aws s3 sync s3://dongne-uploads s3://dongne-uploads-dr --region ap-northeast-1

            # Elasticsearch 스냅샷을 DR 리전으로 복사
            curl -X PUT "elasticsearch-dr.ap-northeast-1.es.amazonaws.com/_snapshot/dr-repo/snapshot-$(date +%Y%m%d%H)" \
              -H 'Content-Type: application/json' \
              -d '{"indices": "*", "ignore_unavailable": true}'

            echo "DR sync completed"
            sleep $SYNC_INTERVAL
          done
```

---

## ⚡ 성능 최적화 전략

### 1. 데이터베이스 최적화

#### 인덱스 최적화 전략

```sql
-- 질문 검색 최적화 인덱스
CREATE INDEX CONCURRENTLY idx_questions_region_category_created
ON questions (region_code, category, created_at DESC);

CREATE INDEX CONCURRENTLY idx_questions_location_gist
ON questions USING GIST (location);

CREATE INDEX CONCURRENTLY idx_questions_hashtags_gin
ON questions USING GIN (hashtags);

CREATE INDEX CONCURRENTLY idx_questions_fulltext
ON questions USING GIN (to_tsvector('korean', title || ' ' || content));

-- 답변 검색 최적화
CREATE INDEX CONCURRENTLY idx_answers_question_created
ON answers (question_id, created_at DESC);

CREATE INDEX CONCURRENTLY idx_answers_user_accepted
ON answers (user_id, is_accepted, created_at DESC);

-- 사용자 활동 최적화
CREATE INDEX CONCURRENTLY idx_users_region_verified
ON users (region_code, is_local_verified, last_active_at DESC);

-- 포인트 거래 최적화
CREATE INDEX CONCURRENTLY idx_point_transactions_user_created
ON point_transactions (user_id, created_at DESC);

-- 파티셔닝을 통한 성능 개선
CREATE TABLE questions_partitioned (
    LIKE questions INCLUDING ALL
) PARTITION BY RANGE (created_at);

-- 월별 파티션 생성
CREATE TABLE questions_2024_01 PARTITION OF questions_partitioned
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE questions_2024_02 PARTITION OF questions_partitioned
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

#### 쿼리 최적화

```typescript
// 최적화된 질문 목록 조회
class OptimizedQuestionService {
  private readonly QUESTIONS_PER_PAGE = 20;

  async getQuestions(params: QuestionListParams): Promise<PaginatedQuestions> {
    const { region, category, hashtags, page = 1, sortBy = 'created_at' } = params;

    // 기본 쿼리 빌더
    let query = this.db
      .select([
        'q.id',
        'q.title',
        'q.content',
        'q.hashtags',
        'q.created_at',
        'q.urgency',
        'u.nickname',
        'u.region_code',
        'u.is_local_verified',
        // 답변 수를 서브쿼리로 효율적으로 조회
        this.db.raw(`(
          SELECT COUNT(*) FROM answers a
          WHERE a.question_id = q.id
        ) as answer_count`),
        // 채택된 답변 여부
        this.db.raw(`(
          SELECT EXISTS(
            SELECT 1 FROM answers a
            WHERE a.question_id = q.id AND a.is_accepted = true
          )
        ) as has_accepted_answer`)
      ])
      .from('questions as q')
      .join('users as u', 'q.user_id', 'u.id')
      .where('q.status', 'active')
      .limit(this.QUESTIONS_PER_PAGE)
      .offset((page - 1) * this.QUESTIONS_PER_PAGE);

    // 조건부 필터링 (인덱스 활용)
    if (region) {
      query = query.where('q.region_code', region);
    }

    if (category) {
      query = query.where('q.category', category);
    }

    if (hashtags?.length > 0) {
      query = query.where(this.db.raw('q.hashtags && ?', [hashtags]));
    }

    // 정렬 최적화
    switch (sortBy) {
      case 'created_at':
        query = query.orderBy('q.created_at', 'desc');
        break;
      case 'popularity':
        // 답변 수 + 좋아요 수 기반 정렬
        query = query.orderBy(
          this.db.raw(`(
            SELECT COUNT(*) FROM answers a WHERE a.question_id = q.id
          ) + (
            SELECT COUNT(*) FROM question_likes ql WHERE ql.question_id = q.id
          )`),
          'desc'
        );
        break;
      case 'urgent':
        query = query
          .orderBy('q.urgency', 'desc')
          .orderBy('q.created_at', 'desc');
        break;
    }

    const questions = await query;

    // 별도 쿼리로 총 개수 조회 (성능 최적화)
    const totalCount = await this.getCachedQuestionCount(params);

    return {
      questions,
      pagination: {
        current_page: page,
        per_page: this.QUESTIONS_PER_PAGE,
        total: totalCount,
        total_pages: Math.ceil(totalCount / this.QUESTIONS_PER_PAGE)
      }
    };
  }

  private async getCachedQuestionCount(params: QuestionListParams): Promise<number> {
    const cacheKey = `question_count:${JSON.stringify(params)}`;

    // 캐시에서 조회
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return parseInt(cached);
    }

    // DB에서 조회
    const result = await this.db('questions')
      .count('* as total')
      .where('status', 'active')
      .modify((query) => {
        if (params.region) query.where('region_code', params.region);
        if (params.category) query.where('category', params.category);
        if (params.hashtags?.length > 0) {
          query.where(this.db.raw('hashtags && ?', [params.hashtags]));
        }
      })
      .first();

    const count = result.total;

    // 5분간 캐시
    await this.cache.setex(cacheKey, 300, count.toString());

    return count;
  }
}
```

### 2. 애플리케이션 레벨 최적화

#### 연결 풀 최적화

```typescript
// 데이터베이스 연결 풀 설정
class OptimizedConnectionPool {
  private pools: Map<string, Pool> = new Map();

  constructor() {
    this.initializePools();
  }

  private initializePools(): void {
    // 마스터 DB 풀 (쓰기 작업용)
    this.pools.set('master', new Pool({
      host: process.env.DB_MASTER_HOST,
      port: 5432,
      database: 'dongne_db',
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,

      // 연결 풀 최적화 설정
      min: 5,                    // 최소 연결 수
      max: 20,                   // 최대 연결 수
      idleTimeoutMillis: 30000,  // 30초 후 유휴 연결 정리
      connectionTimeoutMillis: 2000, // 2초 연결 타임아웃

      // PostgreSQL 최적화 설정
      statement_timeout: 30000,   // 30초 쿼리 타임아웃
      query_timeout: 30000,
      application_name: 'dongne-api',

      // 연결 상태 검증
      keepAlive: true,
      keepAliveInitialDelayMillis: 10000,
    }));

    // 읽기 전용 레플리카 풀
    this.pools.set('replica', new Pool({
      host: process.env.DB_REPLICA_HOST,
      port: 5432,
      database: 'dongne_db',
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,

      min: 3,
      max: 30,  // 읽기는 더 많은 연결 허용
      idleTimeoutMillis: 60000,
      connectionTimeoutMillis: 2000,

      statement_timeout: 15000,  // 읽기는 더 짧은 타임아웃
      query_timeout: 15000,
      application_name: 'dongne-api-readonly',
    }));
  }

  getPool(type: 'master' | 'replica' = 'master'): Pool {
    return this.pools.get(type)!;
  }

  // 연결 풀 상태 모니터링
  getPoolStatus(): PoolStatus[] {
    return Array.from(this.pools.entries()).map(([name, pool]) => ({
      name,
      totalConnections: pool.totalCount,
      idleConnections: pool.idleCount,
      waitingClients: pool.waitingCount
    }));
  }
}
```

#### 비동기 처리 최적화

```typescript
// 백그라운드 작업 처리 시스템
class BackgroundJobProcessor {
  private queues: Map<string, Queue> = new Map();
  private workers: Map<string, Worker> = new Map();

  constructor() {
    this.initializeQueues();
    this.startWorkers();
  }

  private initializeQueues(): void {
    const queueConfigs = [
      {
        name: 'notification',
        concurrency: 10,
        priority: 'high',
        retryAttempts: 3
      },
      {
        name: 'email',
        concurrency: 5,
        priority: 'medium',
        retryAttempts: 5
      },
      {
        name: 'analytics',
        concurrency: 3,
        priority: 'low',
        retryAttempts: 2
      },
      {
        name: 'image-processing',
        concurrency: 2,
        priority: 'medium',
        retryAttempts: 3
      }
    ];

    queueConfigs.forEach(config => {
      const queue = new Queue(config.name, {
        redis: { host: process.env.REDIS_HOST, port: 6379 },
        defaultJobOptions: {
          attempts: config.retryAttempts,
          backoff: 'exponential',
          removeOnComplete: 100,
          removeOnFail: 50
        }
      });

      this.queues.set(config.name, queue);
    });
  }

  private startWorkers(): void {
    // 알림 처리 워커
    this.workers.set('notification', new Worker('notification', async (job) => {
      const { userId, notification } = job.data;
      await this.processNotification(userId, notification);
    }, {
      concurrency: 10,
      limiter: {
        max: 1000,
        duration: 60000 // 분당 1000개 제한
      }
    }));

    // 이메일 처리 워커
    this.workers.set('email', new Worker('email', async (job) => {
      const { email, subject, content } = job.data;
      await this.sendEmail(email, subject, content);
    }, {
      concurrency: 5,
      limiter: {
        max: 100,
        duration: 60000 // 분당 100개 제한
      }
    }));

    // 이미지 처리 워커
    this.workers.set('image-processing', new Worker('image-processing', async (job) => {
      const { imageUrl, options } = job.data;
      await this.processImage(imageUrl, options);
    }, {
      concurrency: 2 // CPU 집약적 작업이므로 낮은 동시성
    }));
  }

  async addJob(queueName: string, jobData: any, options?: JobOptions): Promise<void> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }

    await queue.add(jobData, {
      priority: options?.priority || 0,
      delay: options?.delay || 0,
      attempts: options?.attempts || 3
    });
  }

  // 배치 작업 처리
  async addBulkJobs(queueName: string, jobs: BulkJobData[]): Promise<void> {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Queue ${queueName} not found`);
    }

    const bulkJobs = jobs.map(job => ({
      name: job.name || 'bulk-job',
      data: job.data,
      opts: {
        priority: job.priority || 0,
        attempts: job.attempts || 3
      }
    }));

    await queue.addBulk(bulkJobs);
  }
}
```

### 3. 프론트엔드 최적화

#### React 성능 최적화

```typescript
// 메모이제이션을 활용한 컴포넌트 최적화
import { memo, useMemo, useCallback, useState, useEffect } from 'react';
import { useVirtualizer } from '@tanstack/react-virtual';

// 질문 목록 컴포넌트 최적화
const QuestionList = memo(({ questions, onQuestionClick }) => {
  const parentRef = useRef<HTMLDivElement>(null);

  // 가상 스크롤링으로 대량 데이터 처리
  const rowVirtualizer = useVirtualizer({
    count: questions.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 120, // 예상 높이
    overscan: 5 // 버퍼 아이템 수
  });

  const virtualItems = rowVirtualizer.getVirtualItems();

  return (
    <div ref={parentRef} className="h-96 overflow-auto">
      <div
        style={{
          height: `${rowVirtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative',
        }}
      >
        {virtualItems.map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualItem.size}px`,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            <QuestionItem
              question={questions[virtualItem.index]}
              onClick={onQuestionClick}
            />
          </div>
        ))}
      </div>
    </div>
  );
});

// 개별 질문 아이템 최적화
const QuestionItem = memo(({ question, onClick }) => {
  const handleClick = useCallback(() => {
    onClick(question.id);
  }, [question.id, onClick]);

  // 해시태그 렌더링 최적화
  const hashtagElements = useMemo(() => (
    question.hashtags.map(tag => (
      <span key={tag} className="hashtag">
        #{tag}
      </span>
    ))
  ), [question.hashtags]);

  return (
    <div className="question-item" onClick={handleClick}>
      <h3>{question.title}</h3>
      <p>{question.content.substring(0, 100)}...</p>
      <div className="hashtags">{hashtagElements}</div>
      <div className="meta">
        <span>{question.user.nickname}</span>
        <span>{formatTimeAgo(question.created_at)}</span>
      </div>
    </div>
  );
}, (prevProps, nextProps) => {
  // 커스텀 비교 함수로 불필요한 리렌더링 방지
  return (
    prevProps.question.id === nextProps.question.id &&
    prevProps.question.title === nextProps.question.title &&
    prevProps.question.content === nextProps.question.content
  );
});
```

#### 이미지 최적화

```typescript
// Next.js Image 컴포넌트 확장
import Image from 'next/image';
import { useState } from 'react';

const OptimizedImage = ({ src, alt, width, height, priority = false, ...props }) => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(false);

  // WebP 지원 확인 및 대체 이미지 제공
  const getOptimizedSrc = useCallback((originalSrc: string) => {
    if (originalSrc.includes('amazonaws.com')) {
      // S3 이미지의 경우 CloudFront 변환 활용
      return originalSrc.replace(/\.(jpg|jpeg|png)$/, '.webp');
    }
    return originalSrc;
  }, []);

  return (
    <div className={`image-container ${isLoading ? 'loading' : ''}`}>
      {isLoading && (
        <div className="image-skeleton" style={{ width, height }} />
      )}
      {!error && (
        <Image
          src={getOptimizedSrc(src)}
          alt={alt}
          width={width}
          height={height}
          priority={priority}
          loading={priority ? 'eager' : 'lazy'}
          quality={85} // 품질 최적화
          sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          onLoad={() => setIsLoading(false)}
          onError={() => {
            setError(true);
            setIsLoading(false);
          }}
          placeholder="blur"
          blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k="
          {...props}
        />
      )}
      {error && (
        <div className="image-error" style={{ width, height }}>
          <span>이미지를 불러올 수 없습니다</span>
        </div>
      )}
    </div>
  );
};

// 이미지 지연 로딩 훅
const useIntersectionObserver = (threshold = 0.1) => {
  const [isIntersecting, setIsIntersecting] = useState(false);
  const targetRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsIntersecting(true);
          observer.unobserve(entry.target);
        }
      },
      { threshold }
    );

    if (targetRef.current) {
      observer.observe(targetRef.current);
    }

    return () => observer.disconnect();
  }, [threshold]);

  return [targetRef, isIntersecting] as const;
};
```

---

## 🛠️ 기술 스택 선정

### 프론트엔드 기술 스택

```typescript
// 기술 스택 의사결정 매트릭스
interface TechStackDecision {
  technology: string;
  alternatives: string[];
  selectedReason: string;
  pros: string[];
  cons: string[];
  futureConsiderations: string[];
}

const frontendStack: TechStackDecision[] = [
  {
    technology: "Next.js 14 (App Router)",
    alternatives: ["React SPA", "Vue.js", "Angular", "SvelteKit"],
    selectedReason: "SSR/SSG 지원으로 SEO 최적화 및 초기 로딩 성능 향상",
    pros: [
      "서버사이드 렌더링으로 SEO 친화적",
      "이미지 최적화 자동화",
      "API Routes로 백엔드 로직 통합 가능",
      "Vercel 배포 최적화",
      "한국 커뮤니티 활발"
    ],
    cons: [
      "러닝 커브 존재",
      "번들 크기가 클 수 있음",
      "서버 자원 필요"
    ],
    futureConsiderations: [
      "React Server Components 활용",
      "Edge Runtime 최적화"
    ]
  },
  {
    technology: "TypeScript",
    alternatives: ["JavaScript", "Flow"],
    selectedReason: "대규모 프로젝트의 안정성 및 개발 생산성 향상",
    pros: [
      "컴파일 타임 에러 검출",
      "IDE 지원 강화",
      "리팩토링 안전성",
      "팀 협업 효율성"
    ],
    cons: [
      "초기 개발 속도 저하",
      "타입 정의 오버헤드"
    ],
    futureConsiderations: [
      "strict 모드 점진적 적용",
      "제네릭 타입 활용 확대"
    ]
  },
  {
    technology: "Tailwind CSS",
    alternatives: ["Styled Components", "Emotion", "Material-UI", "Chakra UI"],
    selectedReason: "빠른 UI 개발 및 일관된 디자인 시스템 구축",
    pros: [
      "빠른 프로토타이핑",
      "번들 크기 최적화",
      "디자인 토큰 표준화",
      "반응형 디자인 용이"
    ],
    cons: [
      "HTML 클래스 복잡성",
      "커스텀 디자인 제약"
    ],
    futureConsiderations: [
      "디자인 시스템 확장",
      "다크 모드 지원"
    ]
  }
];
```

### 백엔드 기술 스택

```typescript
const backendStack: TechStackDecision[] = [
  {
    technology: "Node.js 18 LTS",
    alternatives: ["Python Django", "Java Spring", "Go", "Rust"],
    selectedReason: "JavaScript 풀스택 개발로 팀 효율성 최대화",
    pros: [
      "프론트엔드와 언어 통일",
      "NPM 생태계 활용",
      "비동기 I/O 성능",
      "빠른 개발 속도",
      "한국 개발자 풀 풍부"
    ],
    cons: [
      "CPU 집약적 작업 성능 한계",
      "타입 안정성 부족 (TypeScript로 보완)"
    ],
    futureConsiderations: [
      "마이크로서비스별 언어 선택 고려",
      "성능 크리티컬 부분 Go/Rust 도입"
    ]
  },
  {
    technology: "Express.js + TypeScript",
    alternatives: ["Fastify", "Koa.js", "NestJS", "Hapi.js"],
    selectedReason: "검증된 안정성 및 풍부한 미들웨어 생태계",
    pros: [
      "성숙한 생태계",
      "유연한 아키텍처",
      "광범위한 커뮤니티 지원",
      "미들웨어 풍부"
    ],
    cons: [
      "보일러플레이트 코드 많음",
      "구조적 제약 부족"
    ],
    futureConsiderations: [
      "API 서비스별 Fastify 고려",
      "GraphQL 서버 별도 구축"
    ]
  },
  {
    technology: "PostgreSQL 15",
    alternatives: ["MySQL", "MongoDB", "CockroachDB"],
    selectedReason: "ACID 보장 및 고급 기능 지원으로 데이터 무결성 확보",
    pros: [
      "ACID 트랜잭션 보장",
      "JSON 지원 (NoSQL 유연성)",
      "고급 인덱싱 지원",
      "지리정보 시스템 지원",
      "읽기 성능 우수"
    ],
    cons: [
      "수평 확장 복잡성",
      "메모리 사용량 높음"
    ],
    futureConsiderations: [
      "읽기 레플리카 확장",
      "샤딩 전략 수립"
    ]
  }
];
```

### 데이터베이스 및 캐싱

```typescript
const dataStack: TechStackDecision[] = [
  {
    technology: "Redis Cluster",
    alternatives: ["Memcached", "Hazelcast", "DragonflyDB"],
    selectedReason: "다양한 데이터 구조 지원 및 고가용성 클러스터링",
    pros: [
      "다양한 데이터 타입 지원",
      "Pub/Sub 메시징",
      "Lua 스크립트 지원",
      "클러스터 모드 고가용성",
      "한국 클라우드 지원 우수"
    ],
    cons: [
      "메모리 기반 비용",
      "복잡한 클러스터 관리"
    ],
    futureConsiderations: [
      "Redis 7.0 신기능 활용",
      "Redis Modules 도입"
    ]
  },
  {
    technology: "Elasticsearch 8",
    alternatives: ["Apache Solr", "MeiliSearch", "Algolia"],
    selectedReason: "한국어 검색 최적화 및 실시간 분석 기능",
    pros: [
      "한국어 형태소 분석",
      "실시간 검색 및 집계",
      "확장성 우수",
      "시각화 도구 풍부",
      "오픈소스"
    ],
    cons: [
      "자원 사용량 높음",
      "복잡한 클러스터 관리",
      "라이선스 이슈 (상용 기능)"
    ],
    futureConsiderations: [
      "OpenSearch 대안 검토",
      "Vector 검색 활용"
    ]
  }
];
```

### 클라우드 및 인프라

```typescript
const infrastructureStack: TechStackDecision[] = [
  {
    technology: "AWS (Primary) + 네이버 클라우드 (Hybrid)",
    alternatives: ["Google Cloud", "Azure", "네이버 클라우드 단독"],
    selectedReason: "글로벌 표준 + 한국 특화 서비스 조합으로 최적화",
    pros: [
      "AWS: 글로벌 표준, 풍부한 서비스",
      "네이버: 한국 최적화, 카카오/네이버 API 연동",
      "멀티 클라우드 위험 분산",
      "비용 최적화 가능"
    ],
    cons: [
      "복잡한 관리",
      "네트워크 레이턴시",
      "통합 모니터링 어려움"
    ],
    futureConsiderations: [
      "주요 서비스 AWS 집중",
      "CDN 네이버 클라우드 활용"
    ]
  },
  {
    technology: "Docker + Kubernetes",
    alternatives: ["Docker Swarm", "AWS ECS", "서버리스 전환"],
    selectedReason: "컨테이너 오케스트레이션 표준으로 확장성 및 이식성 확보",
    pros: [
      "환경 일관성",
      "자동 스케일링",
      "무중단 배포",
      "리소스 효율성",
      "멀티 클라우드 지원"
    ],
    cons: [
      "학습 곡선 가파름",
      "운영 복잡성",
      "초기 설정 비용"
    ],
    futureConsiderations: [
      "Serverless 전환 검토",
      "Edge Computing 도입"
    ]
  }
];
```

---

## 🚀 개발 및 배포 파이프라인

### CI/CD 파이프라인 설계

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: dongne

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Run type checking
      run: npm run type-check

    - name: Run unit tests
      run: npm run test:unit
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379

    - name: Run integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379

    - name: Generate test coverage
      run: npm run test:coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        token: ${{ secrets.CODECOV_TOKEN }}

  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Run security audit
      run: npm audit --audit-level high

    - name: Run SAST with CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: javascript

    - name: Run SAST analysis
      uses: github/codeql-action/analyze@v2

  build-and-push:
    needs: [test, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    strategy:
      matrix:
        service: [user-service, qa-service, notification-service, search-service]

    steps:
    - uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: ./services/${{ matrix.service }}
        file: ./services/${{ matrix.service }}/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-2

    - name: Deploy to EKS Staging
      run: |
        aws eks update-kubeconfig --region ap-northeast-2 --name dongne-staging
        helm upgrade --install dongne-staging ./helm/dongne \
          --namespace staging \
          --create-namespace \
          --set global.environment=staging \
          --set global.imageTag=${GITHUB_SHA:0:7} \
          --wait --timeout=600s

    - name: Run smoke tests
      run: |
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=dongne --timeout=300s -n staging
        npm run test:smoke -- --baseUrl=https://staging.dongnemuleoboa.com

  deploy-production:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-2

    - name: Deploy to EKS Production
      run: |
        aws eks update-kubeconfig --region ap-northeast-2 --name dongne-production

        # Blue-Green 배포
        helm upgrade --install dongne-green ./helm/dongne \
          --namespace production \
          --set global.environment=production \
          --set global.imageTag=${GITHUB_SHA:0:7} \
          --set ingress.className=green \
          --wait --timeout=600s

        # Health check
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=dongne,version=green --timeout=300s -n production

        # Traffic switch
        kubectl patch ingress dongne-ingress -n production --type=merge -p='{"spec":{"ingressClassName":"green"}}'

        # Cleanup old version
        sleep 300
        helm uninstall dongne-blue -n production || true

    - name: Run production smoke tests
      run: |
        npm run test:smoke -- --baseUrl=https://dongnemuleoboa.com

    - name: Notify deployment success
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        text: '✅ Production deployment successful'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

### 환경별 설정 관리

```typescript
// 환경별 설정 관리 시스템
interface EnvironmentConfig {
  name: string;
  database: DatabaseConfig;
  redis: RedisConfig;
  external: ExternalServiceConfig;
  monitoring: MonitoringConfig;
  scaling: ScalingConfig;
}

const environments: Record<string, EnvironmentConfig> = {
  development: {
    name: 'development',
    database: {
      host: 'localhost',
      port: 5432,
      database: 'dongne_dev',
      ssl: false,
      poolSize: 5,
      logQueries: true
    },
    redis: {
      host: 'localhost',
      port: 6379,
      cluster: false,
      password: null
    },
    external: {
      kakaoApi: {
        clientId: process.env.KAKAO_CLIENT_ID_DEV,
        redirectUri: 'http://localhost:3000/auth/kakao/callback'
      },
      awsS3: {
        bucket: 'dongne-uploads-dev',
        region: 'ap-northeast-2'
      }
    },
    monitoring: {
      logLevel: 'debug',
      enableMetrics: true,
      enableTracing: true
    },
    scaling: {
      minReplicas: 1,
      maxReplicas: 3,
      targetCPU: 80
    }
  },
  staging: {
    name: 'staging',
    database: {
      host: process.env.DB_HOST_STAGING,
      port: 5432,
      database: 'dongne_staging',
      ssl: true,
      poolSize: 10,
      logQueries: false
    },
    redis: {
      host: process.env.REDIS_HOST_STAGING,
      port: 6379,
      cluster: true,
      password: process.env.REDIS_PASSWORD
    },
    external: {
      kakaoApi: {
        clientId: process.env.KAKAO_CLIENT_ID_STAGING,
        redirectUri: 'https://staging.dongnemuleoboa.com/auth/kakao/callback'
      },
      awsS3: {
        bucket: 'dongne-uploads-staging',
        region: 'ap-northeast-2'
      }
    },
    monitoring: {
      logLevel: 'info',
      enableMetrics: true,
      enableTracing: true
    },
    scaling: {
      minReplicas: 2,
      maxReplicas: 10,
      targetCPU: 70
    }
  },
  production: {
    name: 'production',
    database: {
      host: process.env.DB_HOST_PROD,
      port: 5432,
      database: 'dongne_prod',
      ssl: true,
      poolSize: 20,
      logQueries: false
    },
    redis: {
      host: process.env.REDIS_HOST_PROD,
      port: 6379,
      cluster: true,
      password: process.env.REDIS_PASSWORD
    },
    external: {
      kakaoApi: {
        clientId: process.env.KAKAO_CLIENT_ID_PROD,
        redirectUri: 'https://dongnemuleoboa.com/auth/kakao/callback'
      },
      awsS3: {
        bucket: 'dongne-uploads-prod',
        region: 'ap-northeast-2'
      }
    },
    monitoring: {
      logLevel: 'warn',
      enableMetrics: true,
      enableTracing: false
    },
    scaling: {
      minReplicas: 3,
      maxReplicas: 50,
      targetCPU: 70
    }
  }
};

// 환경 설정 로더
export class ConfigLoader {
  private static instance: ConfigLoader;
  private config: EnvironmentConfig;

  private constructor() {
    const env = process.env.NODE_ENV || 'development';
    this.config = environments[env];

    if (!this.config) {
      throw new Error(`Invalid environment: ${env}`);
    }

    this.validateConfig();
  }

  static getInstance(): ConfigLoader {
    if (!ConfigLoader.instance) {
      ConfigLoader.instance = new ConfigLoader();
    }
    return ConfigLoader.instance;
  }

  getConfig(): EnvironmentConfig {
    return this.config;
  }

  private validateConfig(): void {
    const required = [
      'database.host',
      'redis.host',
      'external.kakaoApi.clientId'
    ];

    for (const path of required) {
      const value = this.getNestedValue(this.config, path);
      if (!value) {
        throw new Error(`Missing required config: ${path}`);
      }
    }
  }

  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }
}
```

---

## 💰 비용 최적화 전략

### 1. 단계별 비용 계획

```typescript
// 비용 최적화 전략
interface CostOptimizationStrategy {
  phase: string;
  expectedUsers: number;
  estimatedMonthlyCost: number;
  costBreakdown: CostBreakdown;
  optimizations: Optimization[];
}

const costStrategy: CostOptimizationStrategy[] = [
  {
    phase: "MVP (0-1K users)",
    expectedUsers: 1000,
    estimatedMonthlyCost: 200, // USD
    costBreakdown: {
      compute: 80,    // ECS Fargate
      database: 50,   // RDS t3.micro
      storage: 20,    // S3 Standard
      cdn: 10,        // CloudFront
      monitoring: 20, // CloudWatch
      other: 20       // 기타
    },
    optimizations: [
      "AWS 프리티어 최대 활용",
      "Spot Instance 사용",
      "S3 Intelligent Tiering",
      "CloudWatch 로그 보존 기간 최적화"
    ]
  },
  {
    phase: "Growth (1K-10K users)",
    expectedUsers: 10000,
    estimatedMonthlyCost: 800,
    costBreakdown: {
      compute: 300,   // ECS Fargate + Auto Scaling
      database: 200,  // RDS t3.medium + Read Replica
      storage: 100,   // S3 + EBS
      cdn: 50,        // CloudFront
      monitoring: 80, // DataDog + CloudWatch
      other: 70       // 백업, 보안 등
    },
    optimizations: [
      "Reserved Instance 도입",
      "Database 연결 풀링 최적화",
      "이미지 압축 및 WebP 변환",
      "캐싱 레이어 강화"
    ]
  },
  {
    phase: "Scale (10K-100K users)",
    expectedUsers: 100000,
    estimatedMonthlyCost: 3000,
    costBreakdown: {
      compute: 1200,  // Multi-AZ ECS + Auto Scaling
      database: 800,  // RDS r5.large + Multi-AZ
      storage: 300,   // S3 + EBS + EFS
      cdn: 200,       // CloudFront + Edge Locations
      monitoring: 300, // 고급 모니터링
      other: 200      // 보안, 백업, 기타
    },
    optimizations: [
      "마이크로서비스 별 최적화",
      "데이터베이스 샤딩",
      "서버리스 함수 활용",
      "비용 모니터링 자동화"
    ]
  }
];
```

### 2. 자동 비용 최적화

```typescript
// 자동 비용 최적화 시스템
class CostOptimizer {
  private cloudWatchClient: CloudWatchClient;
  private ec2Client: EC2Client;
  private rdsClient: RDSClient;

  constructor() {
    this.cloudWatchClient = new CloudWatchClient({ region: 'ap-northeast-2' });
    this.ec2Client = new EC2Client({ region: 'ap-northeast-2' });
    this.rdsClient = new RDSClient({ region: 'ap-northeast-2' });
  }

  async optimizeResources(): Promise<OptimizationResult[]> {
    const results: OptimizationResult[] = [];

    // 1. 미사용 리소스 식별
    results.push(...await this.identifyUnusedResources());

    // 2. 오버프로비저닝된 리소스 최적화
    results.push(...await this.optimizeOverProvisionedResources());

    // 3. 스토리지 클래스 최적화
    results.push(...await this.optimizeStorageClasses());

    // 4. Reserved Instance 권장사항
    results.push(...await this.generateRIRecommendations());

    return results;
  }

  private async identifyUnusedResources(): Promise<OptimizationResult[]> {
    const results: OptimizationResult[] = [];

    // 미사용 EBS 볼륨 식별
    const volumes = await this.ec2Client.send(new DescribeVolumesCommand({
      Filters: [{ Name: 'status', Values: ['available'] }]
    }));

    for (const volume of volumes.Volumes || []) {
      if (this.isVolumeUnused(volume)) {
        results.push({
          type: 'unused_ebs_volume',
          resource: volume.VolumeId,
          potentialSavings: this.calculateEBSSavings(volume),
          recommendation: `Delete unused EBS volume ${volume.VolumeId}`,
          risk: 'low'
        });
      }
    }

    // 미사용 로드 밸런서 식별
    const loadBalancers = await this.elbClient.send(new DescribeLoadBalancersCommand({}));

    for (const lb of loadBalancers.LoadBalancers || []) {
      const targets = await this.getLoadBalancerTargets(lb.LoadBalancerArn);
      if (targets.length === 0) {
        results.push({
          type: 'unused_load_balancer',
          resource: lb.LoadBalancerName,
          potentialSavings: 20, // 월 $20 절약
          recommendation: `Remove unused load balancer ${lb.LoadBalancerName}`,
          risk: 'medium'
        });
      }
    }

    return results;
  }

  private async optimizeOverProvisionedResources(): Promise<OptimizationResult[]> {
    const results: OptimizationResult[] = [];

    // CPU 사용률이 낮은 RDS 인스턴스 식별
    const dbInstances = await this.rdsClient.send(new DescribeDBInstancesCommand({}));

    for (const instance of dbInstances.DBInstances || []) {
      const cpuUtilization = await this.getAverageCPUUtilization(
        instance.DBInstanceIdentifier!,
        'AWS/RDS'
      );

      if (cpuUtilization < 20) { // 평균 CPU 사용률 20% 미만
        const currentClass = instance.DBInstanceClass!;
        const recommendedClass = this.getDowngradedInstanceClass(currentClass);

        if (recommendedClass) {
          results.push({
            type: 'rds_right_sizing',
            resource: instance.DBInstanceIdentifier!,
            potentialSavings: this.calculateRDSSavings(currentClass, recommendedClass),
            recommendation: `Downgrade RDS instance from ${currentClass} to ${recommendedClass}`,
            risk: 'medium'
          });
        }
      }
    }

    return results;
  }

  private async optimizeStorageClasses(): Promise<OptimizationResult[]> {
    const results: OptimizationResult[] = [];

    // S3 객체의 액세스 패턴 분석
    const s3Analytics = await this.analyzeS3AccessPatterns();

    for (const bucket of s3Analytics) {
      if (bucket.infrequentlyAccessedObjects > 0) {
        results.push({
          type: 's3_storage_class_optimization',
          resource: bucket.name,
          potentialSavings: bucket.potentialSavings,
          recommendation: `Move ${bucket.infrequentlyAccessedObjects} objects to IA storage class`,
          risk: 'low'
        });
      }
    }

    return results;
  }

  // 비용 모니터링 및 알림
  async setupCostAlerts(): Promise<void> {
    const budgetParams = {
      Budget: {
        BudgetName: 'dongne-monthly-budget',
        BudgetLimit: {
          Amount: '1000',
          Unit: 'USD'
        },
        TimeUnit: 'MONTHLY',
        BudgetType: 'COST',
        CostFilters: {
          Service: ['Amazon Elastic Compute Cloud', 'Amazon Relational Database Service']
        }
      },
      NotificationsWithSubscribers: [
        {
          Notification: {
            NotificationType: 'ACTUAL',
            ComparisonOperator: 'GREATER_THAN',
            Threshold: 80, // 80% 임계점
            ThresholdType: 'PERCENTAGE'
          },
          Subscribers: [
            {
              Address: 'admin@dongnemuleoboa.com',
              SubscriptionType: 'EMAIL'
            }
          ]
        }
      ]
    };

    await this.budgetsClient.send(new CreateBudgetCommand(budgetParams));
  }
}
```

### 3. 서버리스 우선 전략

```yaml
# 서버리스 비용 최적화 설정
service: dongne-serverless-functions

provider:
  name: aws
  runtime: nodejs18.x
  region: ap-northeast-2
  memorySize: 256  # 기본 메모리 (비용 최적화)
  timeout: 30      # 타임아웃 최적화

  # 비용 최적화를 위한 환경 변수
  environment:
    NODE_ENV: production
    AWS_NODEJS_CONNECTION_REUSE_ENABLED: 1

functions:
  # 이미지 처리 (CPU 집약적 작업)
  processImage:
    handler: src/images/process.handler
    memorySize: 1024  # 이미지 처리용 메모리 증가
    timeout: 300      # 5분 타임아웃
    events:
      - s3:
          bucket: dongne-uploads
          event: s3:ObjectCreated:*
          rules:
            - prefix: images/
    # Reserved Concurrency로 비용 제어
    reservedConcurrency: 5

  # 알림 발송 (가벼운 작업)
  sendNotification:
    handler: src/notifications/send.handler
    memorySize: 128   # 최소 메모리로 비용 절약
    timeout: 10       # 짧은 타임아웃
    events:
      - sqs:
          arn: arn:aws:sqs:ap-northeast-2:123456789:notification-queue
          batchSize: 10  # 배치 처리로 비용 최적화
    reservedConcurrency: 10

  # 데이터 집계 (스케줄 기반)
  aggregateData:
    handler: src/analytics/aggregate.handler
    memorySize: 512
    timeout: 900      # 15분 (최대)
    events:
      - schedule: cron(0 2 * * ? *)  # 매일 새벽 2시 (저렴한 시간대)

# 비용 최적화를 위한 플러그인
plugins:
  - serverless-bundle           # 번들 크기 최적화
  - serverless-plugin-warmup    # 콜드 스타트 최적화
  - serverless-plugin-split-stacks # 스택 분할로 배포 속도 향상

custom:
  # Lambda 최적화 설정
  bundle:
    minify: true
    sourcemaps: false
    caching: true

  # Warmup 설정 (비용 대비 성능 향상)
  warmup:
    default:
      enabled: true
      events:
        - schedule: rate(5 minutes)
      concurrency: 1
      prewarm: true
```

이 종합 기술 아키텍처 문서는 "동네물어봐" 서비스의 확장성과 안정성을 고려한 포괄적인 시스템 설계 가이드를 제공합니다. 각 단계별로 점진적으로 확장할 수 있는 구조로 설계되어 있으며, 비용 효율성과 성능 최적화를 동시에 고려했습니다.