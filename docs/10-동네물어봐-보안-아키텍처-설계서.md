# "ë™ë„¤ë¬¼ì–´ë´" ë³´ì•ˆ ì•„í‚¤í…ì²˜ ì„¤ê³„ì„œ

## ğŸ“‹ ëª©ì°¨
1. [ë³´ì•ˆ ì•„í‚¤í…ì²˜ ê°œìš”](#-ë³´ì•ˆ-ì•„í‚¤í…ì²˜-ê°œìš”)
2. [Zero Trust ë³´ì•ˆ ëª¨ë¸](#-zero-trust-ë³´ì•ˆ-ëª¨ë¸)
3. [OWASP ê¸°ë°˜ ë³´ì•ˆ ê²€ì¦](#-owasp-ê¸°ë°˜-ë³´ì•ˆ-ê²€ì¦)
4. [ë°ì´í„° ë³´í˜¸ ë° ì•”í˜¸í™”](#-ë°ì´í„°-ë³´í˜¸-ë°-ì•”í˜¸í™”)
5. [ê°œì¸ì •ë³´ë³´í˜¸ ë° GDPR ì¤€ìˆ˜](#-ê°œì¸ì •ë³´ë³´í˜¸-ë°-gdpr-ì¤€ìˆ˜)
6. [API ë³´ì•ˆ](#-api-ë³´ì•ˆ)
7. [ì¸í”„ë¼ ë³´ì•ˆ](#-ì¸í”„ë¼-ë³´ì•ˆ)
8. [ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…](#-ë³´ì•ˆ-ëª¨ë‹ˆí„°ë§-ë°-ë¡œê¹…)
9. [ì¸ì‹œë˜íŠ¸ ëŒ€ì‘](#-ì¸ì‹œë˜íŠ¸-ëŒ€ì‘)
10. [ë³´ì•ˆ ê°ì‚¬ ë° ì»´í”Œë¼ì´ì–¸ìŠ¤](#-ë³´ì•ˆ-ê°ì‚¬-ë°-ì»´í”Œë¼ì´ì–¸ìŠ¤)

---

## ğŸ›¡ï¸ ë³´ì•ˆ ì•„í‚¤í…ì²˜ ê°œìš”

### ë³´ì•ˆ ì„¤ê³„ ì›ì¹™

#### 1. ì‹¬ì¸µ ë°©ì–´ (Defense in Depth)

```mermaid
graph TB
    subgraph "ì™¸ë¶€ ê³µê²©ì"
        ATTACKER[ğŸ­ ê³µê²©ì]
    end

    subgraph "Layer 1: ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ"
        FIREWALL[ğŸ”¥ ë°©í™”ë²½]
        WAF[ğŸ›¡ï¸ WAF]
        DDOS[âš¡ DDoS ë³´í˜¸]
        CDN[ğŸŒ CDN ë³´ì•ˆ]
    end

    subgraph "Layer 2: ì• í”Œë¦¬ì¼€ì´ì…˜ ë³´ì•ˆ"
        API_GATEWAY[ğŸšª API Gateway]
        RATE_LIMIT[ğŸ“Š Rate Limiting]
        AUTH[ğŸ” ì¸ì¦/ì¸ê°€]
        INPUT_VAL[âœ… ì…ë ¥ ê²€ì¦]
    end

    subgraph "Layer 3: ë°ì´í„° ë³´ì•ˆ"
        ENCRYPTION[ğŸ”’ ì•”í˜¸í™”]
        ACCESS_CTRL[ğŸ« ì ‘ê·¼ ì œì–´]
        DATA_MASK[ğŸ‘¤ ë°ì´í„° ë§ˆìŠ¤í‚¹]
        BACKUP_SEC[ğŸ’¾ ë°±ì—… ë³´ì•ˆ]
    end

    subgraph "Layer 4: ì¸í”„ë¼ ë³´ì•ˆ"
        CONTAINER_SEC[ğŸ“¦ ì»¨í…Œì´ë„ˆ ë³´ì•ˆ]
        NETWORK_SEG[ğŸ”— ë„¤íŠ¸ì›Œí¬ ë¶„í• ]
        SECRETS_MGMT[ğŸ—ï¸ ì‹œí¬ë¦¿ ê´€ë¦¬]
        MONITORING[ğŸ‘ï¸ ëª¨ë‹ˆí„°ë§]
    end

    subgraph "ë‚´ë¶€ ì‹œìŠ¤í…œ"
        DATABASE[(ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤)]
        APP_SERVERS[ğŸ–¥ï¸ ì• í”Œë¦¬ì¼€ì´ì…˜]
        MICROSERVICES[âš™ï¸ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤]
    end

    ATTACKER --> FIREWALL
    FIREWALL --> WAF
    WAF --> DDOS
    DDOS --> CDN
    CDN --> API_GATEWAY

    API_GATEWAY --> RATE_LIMIT
    RATE_LIMIT --> AUTH
    AUTH --> INPUT_VAL
    INPUT_VAL --> ENCRYPTION

    ENCRYPTION --> ACCESS_CTRL
    ACCESS_CTRL --> DATA_MASK
    DATA_MASK --> BACKUP_SEC
    BACKUP_SEC --> CONTAINER_SEC

    CONTAINER_SEC --> NETWORK_SEG
    NETWORK_SEG --> SECRETS_MGMT
    SECRETS_MGMT --> MONITORING
    MONITORING --> DATABASE

    DATABASE --> APP_SERVERS
    APP_SERVERS --> MICROSERVICES
```

#### 2. ìµœì†Œ ê¶Œí•œ ì›ì¹™ (Principle of Least Privilege)

```typescript
// ë³´ì•ˆ ì •ì±… ë§¤íŠ¸ë¦­ìŠ¤
interface SecurityPolicyMatrix {
  userType: UserType;
  resources: ResourceAccess[];
  networkAccess: NetworkPolicy;
  dataAccess: DataAccessPolicy;
  auditLevel: AuditLevel;
}

const securityPolicies: SecurityPolicyMatrix[] = [
  {
    userType: 'guest',
    resources: [
      { resource: 'questions', permissions: ['read'] },
      { resource: 'answers', permissions: ['read'] },
      { resource: 'search', permissions: ['read'] }
    ],
    networkAccess: {
      allowedIPs: ['*'],
      rateLimits: { requests: 100, window: '1hour' },
      blockedRegions: ['suspicious_regions']
    },
    dataAccess: {
      personalData: false,
      sensitiveData: false,
      publicData: true
    },
    auditLevel: 'basic'
  },

  {
    userType: 'authenticated_user',
    resources: [
      { resource: 'questions', permissions: ['read', 'create', 'update_own'] },
      { resource: 'answers', permissions: ['read', 'create', 'update_own'] },
      { resource: 'profile', permissions: ['read_own', 'update_own'] },
      { resource: 'notifications', permissions: ['read_own'] }
    ],
    networkAccess: {
      allowedIPs: ['*'],
      rateLimits: { requests: 500, window: '1hour' },
      blockedRegions: []
    },
    dataAccess: {
      personalData: true,  // ë³¸ì¸ ë°ì´í„°ë§Œ
      sensitiveData: false,
      publicData: true
    },
    auditLevel: 'standard'
  },

  {
    userType: 'local_verified',
    resources: [
      { resource: 'questions', permissions: ['read', 'create', 'update_own', 'moderate_local'] },
      { resource: 'answers', permissions: ['read', 'create', 'update_own'] },
      { resource: 'users', permissions: ['verify_local'] },
      { resource: 'analytics', permissions: ['read_regional'] }
    ],
    networkAccess: {
      allowedIPs: ['*'],
      rateLimits: { requests: 1000, window: '1hour' },
      blockedRegions: []
    },
    dataAccess: {
      personalData: true,
      sensitiveData: false,
      publicData: true
    },
    auditLevel: 'enhanced'
  },

  {
    userType: 'admin',
    resources: [
      { resource: '*', permissions: ['*'] }
    ],
    networkAccess: {
      allowedIPs: ['admin_whitelist'],
      rateLimits: { requests: 5000, window: '1hour' },
      requireVPN: true,
      require2FA: true
    },
    dataAccess: {
      personalData: true,
      sensitiveData: true,
      publicData: true
    },
    auditLevel: 'comprehensive'
  }
];
```

#### 3. ë³´ì•ˆ ìœ„í—˜ í‰ê°€ ë§¤íŠ¸ë¦­ìŠ¤

```typescript
// ìœ„í—˜ í‰ê°€ ì‹œìŠ¤í…œ
interface SecurityRiskAssessment {
  category: string;
  threats: ThreatAssessment[];
  impact: 'low' | 'medium' | 'high' | 'critical';
  likelihood: 'low' | 'medium' | 'high';
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  mitigations: SecurityMitigation[];
}

const riskAssessments: SecurityRiskAssessment[] = [
  {
    category: 'Data Breach',
    threats: [
      { name: 'SQL Injection', severity: 'high', probability: 'medium' },
      { name: 'Unauthorized Access', severity: 'critical', probability: 'medium' },
      { name: 'Data Exfiltration', severity: 'critical', probability: 'low' }
    ],
    impact: 'critical',
    likelihood: 'medium',
    riskLevel: 'high',
    mitigations: [
      { type: 'preventive', description: 'Parameterized queries, input validation' },
      { type: 'detective', description: 'Database activity monitoring' },
      { type: 'corrective', description: 'Incident response procedures' }
    ]
  },

  {
    category: 'Account Takeover',
    threats: [
      { name: 'Credential Stuffing', severity: 'high', probability: 'high' },
      { name: 'Session Hijacking', severity: 'medium', probability: 'low' },
      { name: 'Social Engineering', severity: 'medium', probability: 'medium' }
    ],
    impact: 'high',
    likelihood: 'high',
    riskLevel: 'high',
    mitigations: [
      { type: 'preventive', description: 'Multi-factor authentication, password policies' },
      { type: 'detective', description: 'Anomaly detection, login monitoring' },
      { type: 'corrective', description: 'Account lockout, notification systems' }
    ]
  },

  {
    category: 'Service Disruption',
    threats: [
      { name: 'DDoS Attack', severity: 'medium', probability: 'high' },
      { name: 'Resource Exhaustion', severity: 'medium', probability: 'medium' },
      { name: 'Infrastructure Failure', severity: 'high', probability: 'low' }
    ],
    impact: 'medium',
    likelihood: 'medium',
    riskLevel: 'medium',
    mitigations: [
      { type: 'preventive', description: 'CDN protection, rate limiting' },
      { type: 'detective', description: 'Performance monitoring, alerting' },
      { type: 'corrective', description: 'Auto-scaling, failover procedures' }
    ]
  }
];
```

---

## ğŸ”’ Zero Trust ë³´ì•ˆ ëª¨ë¸

### Zero Trust ì•„í‚¤í…ì²˜ êµ¬í˜„

#### 1. ì‹ ì› í™•ì¸ ë° ê²€ì¦

```typescript
// Zero Trust ì‹ ì› ê²€ì¦ ì‹œìŠ¤í…œ
export class ZeroTrustIdentityVerifier {
  private deviceFingerprinting: DeviceFingerprintService;
  private riskAnalyzer: RiskAnalyzer;
  private trustScore: TrustScoreCalculator;

  constructor() {
    this.deviceFingerprinting = new DeviceFingerprintService();
    this.riskAnalyzer = new RiskAnalyzer();
    this.trustScore = new TrustScoreCalculator();
  }

  async verifyIdentity(
    request: AuthenticationRequest
  ): Promise<IdentityVerificationResult> {
    const verificationSteps: VerificationStep[] = [];

    // 1. ê¸°ë³¸ ì¸ì¦ í™•ì¸
    const basicAuth = await this.verifyBasicAuthentication(request);
    verificationSteps.push({
      step: 'basic_authentication',
      status: basicAuth.isValid ? 'passed' : 'failed',
      details: basicAuth.details
    });

    if (!basicAuth.isValid) {
      return this.createFailedResult(verificationSteps, 'Basic authentication failed');
    }

    // 2. ì¥ì¹˜ ì‹ ë¢°ì„± ê²€ì¦
    const deviceTrust = await this.verifyDeviceTrust(request);
    verificationSteps.push({
      step: 'device_trust',
      status: deviceTrust.trustLevel > 0.5 ? 'passed' : 'warning',
      details: deviceTrust
    });

    // 3. í–‰ë™ íŒ¨í„´ ë¶„ì„
    const behaviorAnalysis = await this.analyzeBehaviorPattern(request);
    verificationSteps.push({
      step: 'behavior_analysis',
      status: behaviorAnalysis.isNormal ? 'passed' : 'warning',
      details: behaviorAnalysis
    });

    // 4. ì§€ë¦¬ì  ìœ„ì¹˜ ê²€ì¦
    const locationVerification = await this.verifyLocation(request);
    verificationSteps.push({
      step: 'location_verification',
      status: locationVerification.isValid ? 'passed' : 'warning',
      details: locationVerification
    });

    // 5. ìœ„í—˜ ì ìˆ˜ ê³„ì‚°
    const riskScore = await this.calculateRiskScore(request, {
      deviceTrust,
      behaviorAnalysis,
      locationVerification
    });

    // 6. ì‹ ë¢° ì ìˆ˜ ê³„ì‚°
    const trustScore = await this.trustScore.calculate({
      userId: request.userId,
      deviceFingerprint: deviceTrust.fingerprint,
      behaviorScore: behaviorAnalysis.score,
      locationScore: locationVerification.score,
      historicalData: await this.getHistoricalTrustData(request.userId)
    });

    // 7. ì¶”ê°€ ê²€ì¦ í•„ìš” ì—¬ë¶€ ê²°ì •
    const additionalVerification = this.requiresAdditionalVerification(
      riskScore,
      trustScore
    );

    return {
      isVerified: riskScore.level !== 'high' && trustScore > 0.6,
      trustScore,
      riskScore,
      verificationSteps,
      additionalVerification,
      recommendations: this.generateRecommendations(riskScore, trustScore)
    };
  }

  private async verifyBasicAuthentication(
    request: AuthenticationRequest
  ): Promise<BasicAuthResult> {
    try {
      // JWT í† í° ê²€ì¦
      const tokenVerification = await this.verifyJWTToken(request.token);

      // í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸
      const isTokenRevoked = await this.checkTokenRevocation(request.token);

      // ì‚¬ìš©ì ê³„ì • ìƒíƒœ í™•ì¸
      const userStatus = await this.checkUserAccountStatus(request.userId);

      return {
        isValid: tokenVerification.isValid && !isTokenRevoked && userStatus.isActive,
        details: {
          tokenValid: tokenVerification.isValid,
          tokenRevoked: isTokenRevoked,
          accountActive: userStatus.isActive,
          lastLogin: userStatus.lastLogin
        }
      };
    } catch (error) {
      return {
        isValid: false,
        details: { error: error.message }
      };
    }
  }

  private async verifyDeviceTrust(
    request: AuthenticationRequest
  ): Promise<DeviceTrustResult> {
    // ì¥ì¹˜ í•‘ê±°í”„ë¦°íŒ…
    const fingerprint = await this.deviceFingerprinting.generate({
      userAgent: request.userAgent,
      ipAddress: request.ipAddress,
      screenResolution: request.deviceInfo?.screenResolution,
      timezone: request.deviceInfo?.timezone,
      language: request.deviceInfo?.language,
      plugins: request.deviceInfo?.plugins
    });

    // ì•Œë ¤ì§„ ì¥ì¹˜ í™•ì¸
    const knownDevice = await this.checkKnownDevice(request.userId, fingerprint);

    // ì¥ì¹˜ ìœ„í—˜ ì ìˆ˜ ê³„ì‚°
    const riskFactors = {
      isNewDevice: !knownDevice,
      hasVPN: await this.detectVPN(request.ipAddress),
      isTor: await this.detectTor(request.ipAddress),
      isProxy: await this.detectProxy(request.ipAddress),
      suspiciousUserAgent: this.analyzeuserAgent(request.userAgent),
      geoAnomaly: await this.detectGeoAnomaly(request.userId, request.ipAddress)
    };

    const trustLevel = this.calculateDeviceTrustLevel(riskFactors);

    return {
      fingerprint,
      isKnownDevice: knownDevice,
      trustLevel,
      riskFactors,
      recommendations: this.getDeviceRecommendations(riskFactors, trustLevel)
    };
  }

  private async analyzeBehaviorPattern(
    request: AuthenticationRequest
  ): Promise<BehaviorAnalysisResult> {
    const userId = request.userId;
    const currentTime = new Date();

    // ì‚¬ìš©ìì˜ ê³¼ê±° í–‰ë™ íŒ¨í„´ ì¡°íšŒ
    const historicalBehavior = await this.getHistoricalBehavior(userId);

    // í˜„ì¬ í–‰ë™ê³¼ ë¹„êµ ë¶„ì„
    const patterns = {
      loginTime: this.analyzeLoginTimePattern(currentTime, historicalBehavior.loginTimes),
      sessionDuration: this.analyzeSessionDuration(request, historicalBehavior.sessions),
      actionFrequency: await this.analyzeActionFrequency(userId, currentTime),
      navigationPattern: await this.analyzeNavigationPattern(userId, request.path),
      typingPattern: await this.analyzeTypingPattern(userId, request.typingData)
    };

    // ì´ìƒ íƒì§€
    const anomalies = this.detectAnomalies(patterns, historicalBehavior);

    // í–‰ë™ ì ìˆ˜ ê³„ì‚°
    const behaviorScore = this.calculateBehaviorScore(patterns, anomalies);

    return {
      isNormal: anomalies.length === 0 && behaviorScore > 0.7,
      score: behaviorScore,
      patterns,
      anomalies,
      confidence: this.calculateConfidence(historicalBehavior.sampleSize)
    };
  }

  private requiresAdditionalVerification(
    riskScore: RiskScore,
    trustScore: number
  ): AdditionalVerification | null {
    if (riskScore.level === 'high' || trustScore < 0.4) {
      return {
        type: 'multi_factor',
        methods: ['email_code', 'sms_code', 'authenticator_app'],
        reason: 'High risk score or low trust score',
        timeout: 300 // 5ë¶„
      };
    }

    if (riskScore.level === 'medium' || trustScore < 0.6) {
      return {
        type: 'email_verification',
        methods: ['email_code'],
        reason: 'Medium risk score',
        timeout: 600 // 10ë¶„
      };
    }

    return null;
  }
}
```

#### 2. ë„¤íŠ¸ì›Œí¬ ë§ˆì´í¬ë¡œì„¸ê·¸ë©˜í…Œì´ì…˜

```typescript
// ë„¤íŠ¸ì›Œí¬ ì„¸ê·¸ë©˜í…Œì´ì…˜ ì •ì±…
export class NetworkMicroSegmentation {
  private policies: SegmentationPolicy[] = [];
  private firewall: FirewallManager;

  constructor() {
    this.initializePolicies();
    this.firewall = new FirewallManager();
  }

  private initializePolicies(): void {
    this.policies = [
      {
        name: 'web_to_api',
        source: { segment: 'web_tier', services: ['frontend'] },
        destination: { segment: 'api_tier', services: ['api_gateway'] },
        protocol: 'HTTPS',
        ports: [443],
        rules: [
          { action: 'allow', condition: 'authenticated_users' },
          { action: 'rate_limit', condition: 'guest_users', limit: '100/hour' },
          { action: 'deny', condition: 'blocked_ips' }
        ]
      },

      {
        name: 'api_to_services',
        source: { segment: 'api_tier', services: ['api_gateway'] },
        destination: { segment: 'app_tier', services: ['user_service', 'qa_service'] },
        protocol: 'HTTP',
        ports: [3000],
        rules: [
          { action: 'allow', condition: 'valid_api_token' },
          { action: 'deny', condition: 'default' }
        ]
      },

      {
        name: 'services_to_database',
        source: { segment: 'app_tier', services: ['user_service', 'qa_service'] },
        destination: { segment: 'data_tier', services: ['postgresql', 'redis'] },
        protocol: 'TCP',
        ports: [5432, 6379],
        rules: [
          { action: 'allow', condition: 'service_account_auth' },
          { action: 'encrypt', condition: 'all_traffic' },
          { action: 'audit', condition: 'all_connections' }
        ]
      },

      {
        name: 'admin_access',
        source: { segment: 'admin_tier', services: ['admin_console'] },
        destination: { segment: '*', services: ['*'] },
        protocol: '*',
        ports: '*',
        rules: [
          { action: 'require_vpn', condition: 'all_access' },
          { action: 'require_2fa', condition: 'all_access' },
          { action: 'audit', condition: 'all_actions' },
          { action: 'time_limited', condition: 'session_duration', limit: '8hours' }
        ]
      }
    ];
  }

  async enforceSegmentation(): Promise<void> {
    for (const policy of this.policies) {
      await this.applyPolicy(policy);
    }
  }

  private async applyPolicy(policy: SegmentationPolicy): Promise<void> {
    // Kubernetes Network Policy ìƒì„±
    const k8sNetworkPolicy = this.generateK8sNetworkPolicy(policy);
    await this.applyK8sPolicy(k8sNetworkPolicy);

    // ë°©í™”ë²½ ê·œì¹™ ìƒì„±
    const firewallRules = this.generateFirewallRules(policy);
    await this.firewall.applyRules(firewallRules);

    // ê°ì‚¬ ë¡œê·¸ ì„¤ì •
    await this.setupAuditLogging(policy);
  }

  private generateK8sNetworkPolicy(policy: SegmentationPolicy): any {
    return {
      apiVersion: 'networking.k8s.io/v1',
      kind: 'NetworkPolicy',
      metadata: {
        name: `policy-${policy.name}`,
        namespace: 'dongne-production'
      },
      spec: {
        podSelector: {
          matchLabels: {
            segment: policy.destination.segment
          }
        },
        policyTypes: ['Ingress', 'Egress'],
        ingress: [{
          from: [{
            namespaceSelector: {
              matchLabels: {
                segment: policy.source.segment
              }
            }
          }],
          ports: policy.ports.map(port => ({
            protocol: policy.protocol,
            port: port
          }))
        }],
        egress: [{
          to: [{}], // ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  egress í—ˆìš©
          ports: [{
            protocol: 'TCP',
            port: 53 // DNS
          }]
        }]
      }
    };
  }
}
```

#### 3. ë™ì  ì ‘ê·¼ ì œì–´

```typescript
// ë™ì  ì ‘ê·¼ ì œì–´ ì—”ì§„
export class DynamicAccessControl {
  private policyEngine: PolicyEngine;
  private contextCollector: ContextCollector;
  private decisionLogger: DecisionLogger;

  constructor() {
    this.policyEngine = new PolicyEngine();
    this.contextCollector = new ContextCollector();
    this.decisionLogger = new DecisionLogger();
  }

  async evaluateAccess(
    request: AccessRequest
  ): Promise<AccessDecision> {
    const startTime = Date.now();

    try {
      // 1. ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘
      const context = await this.contextCollector.collect(request);

      // 2. ì •ì±… í‰ê°€
      const policyEvaluation = await this.policyEngine.evaluate(request, context);

      // 3. ìœ„í—˜ í‰ê°€
      const riskAssessment = await this.assessRisk(request, context);

      // 4. ë™ì  ì¡°ê±´ í™•ì¸
      const dynamicConditions = await this.checkDynamicConditions(request, context);

      // 5. ìµœì¢… ê²°ì •
      const decision = this.makeAccessDecision(
        policyEvaluation,
        riskAssessment,
        dynamicConditions
      );

      // 6. ê²°ì • ë¡œê¹…
      await this.logAccessDecision(request, context, decision, Date.now() - startTime);

      return decision;

    } catch (error) {
      console.error('Access evaluation error:', error);

      // ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ì ìœ¼ë¡œ ì ‘ê·¼ ê±°ë¶€
      const denyDecision: AccessDecision = {
        decision: 'deny',
        reason: 'Evaluation error',
        timestamp: new Date(),
        requestId: request.id
      };

      await this.logAccessDecision(request, null, denyDecision, Date.now() - startTime);
      return denyDecision;
    }
  }

  private async checkDynamicConditions(
    request: AccessRequest,
    context: AccessContext
  ): Promise<DynamicConditionResult[]> {
    const conditions: DynamicConditionCheck[] = [
      // ì‹œê°„ ê¸°ë°˜ ì¡°ê±´
      {
        name: 'business_hours',
        check: () => this.isBusinessHours(context.timestamp),
        impact: 'medium'
      },

      // ìœ„ì¹˜ ê¸°ë°˜ ì¡°ê±´
      {
        name: 'geo_restriction',
        check: async () => await this.checkGeoRestriction(context.clientIP, request.resource),
        impact: 'high'
      },

      // ë™ì‹œ ì„¸ì…˜ ì œí•œ
      {
        name: 'concurrent_sessions',
        check: async () => await this.checkConcurrentSessions(request.userId),
        impact: 'medium'
      },

      // ë¦¬ì†ŒìŠ¤ ë¶€í•˜ í™•ì¸
      {
        name: 'resource_load',
        check: async () => await this.checkResourceLoad(request.resource),
        impact: 'low'
      },

      // ë³´ì•ˆ ìœ„í˜‘ ê°ì§€
      {
        name: 'threat_detection',
        check: async () => await this.checkThreatIndicators(context),
        impact: 'critical'
      }
    ];

    const results: DynamicConditionResult[] = [];

    for (const condition of conditions) {
      try {
        const result = await condition.check();
        results.push({
          name: condition.name,
          passed: result,
          impact: condition.impact,
          timestamp: new Date()
        });
      } catch (error) {
        results.push({
          name: condition.name,
          passed: false,
          impact: condition.impact,
          error: error.message,
          timestamp: new Date()
        });
      }
    }

    return results;
  }

  private makeAccessDecision(
    policyEvaluation: PolicyEvaluationResult,
    riskAssessment: RiskAssessmentResult,
    dynamicConditions: DynamicConditionResult[]
  ): AccessDecision {
    // ì •ì±… ìœ„ë°˜ ì‹œ ê±°ë¶€
    if (!policyEvaluation.allowed) {
      return {
        decision: 'deny',
        reason: `Policy violation: ${policyEvaluation.reason}`,
        timestamp: new Date()
      };
    }

    // í¬ë¦¬í‹°ì»¬ ì¡°ê±´ ì‹¤íŒ¨ ì‹œ ê±°ë¶€
    const criticalFailures = dynamicConditions.filter(
      condition => condition.impact === 'critical' && !condition.passed
    );

    if (criticalFailures.length > 0) {
      return {
        decision: 'deny',
        reason: `Critical condition failed: ${criticalFailures[0].name}`,
        timestamp: new Date()
      };
    }

    // ê³ ìœ„í—˜ ì‹œ ì¶”ê°€ ì¸ì¦ ìš”êµ¬
    if (riskAssessment.level === 'high') {
      return {
        decision: 'conditional',
        reason: 'High risk detected',
        conditions: {
          additionalAuthentication: {
            type: 'multi_factor',
            timeout: 300
          }
        },
        timestamp: new Date()
      };
    }

    // ì¤‘ê°„ ìœ„í—˜ ë˜ëŠ” ì¡°ê±´ë¶€ ì‹¤íŒ¨ ì‹œ ì œí•œì  í—ˆìš©
    const mediumRiskConditions = dynamicConditions.filter(
      condition => ['high', 'medium'].includes(condition.impact) && !condition.passed
    );

    if (riskAssessment.level === 'medium' || mediumRiskConditions.length > 0) {
      return {
        decision: 'allow',
        reason: 'Medium risk - limited access',
        limitations: {
          sessionTimeout: 1800, // 30ë¶„ ì œí•œ
          actionLimits: {
            questionsPerHour: 5,
            answersPerHour: 10
          },
          monitoringLevel: 'enhanced'
        },
        timestamp: new Date()
      };
    }

    // ê¸°ë³¸ í—ˆìš©
    return {
      decision: 'allow',
      reason: 'All conditions satisfied',
      timestamp: new Date()
    };
  }

  private async checkThreatIndicators(context: AccessContext): Promise<boolean> {
    const indicators = await Promise.all([
      this.checkIPReputation(context.clientIP),
      this.checkAnomalousPatterns(context.userAgent, context.requestPattern),
      this.checkKnownAttackSignatures(context.request),
      this.checkBrutForceAttempts(context.userId, context.clientIP)
    ]);

    // í•˜ë‚˜ë¼ë„ ìœ„í˜‘ì´ ê°ì§€ë˜ë©´ false ë°˜í™˜
    return !indicators.some(indicator => indicator.isThreat);
  }
}
```

---

## ğŸ” OWASP ê¸°ë°˜ ë³´ì•ˆ ê²€ì¦

### OWASP Top 10 ëŒ€ì‘ ë°©ì•ˆ

#### 1. A01 - Broken Access Control ëŒ€ì‘

```typescript
// ì ‘ê·¼ ì œì–´ ê²€ì¦ ì‹œìŠ¤í…œ
export class AccessControlValidator {
  private rbac: RBACManager;
  private abac: ABACManager;
  private auditLogger: AuditLogger;

  constructor() {
    this.rbac = new RBACManager();
    this.abac = new ABACManager();
    this.auditLogger = new AuditLogger();
  }

  // ìˆ˜ì§ ê¶Œí•œ ìƒìŠ¹ ë°©ì§€
  async validateVerticalAccess(
    user: User,
    requestedResource: string,
    action: string
  ): Promise<AccessValidationResult> {
    try {
      // 1. ì—­í•  ê¸°ë°˜ ê¶Œí•œ í™•ì¸
      const roleBasedAccess = await this.rbac.hasPermission(
        user.roles,
        `${requestedResource}:${action}`
      );

      if (!roleBasedAccess) {
        await this.auditLogger.logAccessViolation({
          userId: user.id,
          type: 'vertical_privilege_escalation_attempt',
          resource: requestedResource,
          action,
          timestamp: new Date()
        });

        return {
          allowed: false,
          reason: 'Insufficient role permissions',
          violation: 'vertical_privilege_escalation'
        };
      }

      // 2. ì†ì„± ê¸°ë°˜ ì¶”ê°€ ê²€ì¦
      const attributeBasedAccess = await this.abac.evaluate({
        subject: user,
        resource: requestedResource,
        action,
        environment: {
          time: new Date(),
          ip: user.currentSession?.ipAddress,
          device: user.currentSession?.deviceInfo
        }
      });

      return {
        allowed: attributeBasedAccess.decision === 'permit',
        reason: attributeBasedAccess.reason,
        obligations: attributeBasedAccess.obligations
      };

    } catch (error) {
      await this.auditLogger.logError({
        type: 'access_control_error',
        userId: user.id,
        error: error.message,
        timestamp: new Date()
      });

      // ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ì ìœ¼ë¡œ ì ‘ê·¼ ê±°ë¶€
      return {
        allowed: false,
        reason: 'Access control evaluation failed'
      };
    }
  }

  // ìˆ˜í‰ ê¶Œí•œ ìƒìŠ¹ ë°©ì§€
  async validateHorizontalAccess(
    user: User,
    resourceOwnerId: string,
    resourceType: string,
    action: string
  ): Promise<AccessValidationResult> {
    // 1. ë³¸ì¸ ë¦¬ì†ŒìŠ¤ í™•ì¸
    if (user.id === resourceOwnerId) {
      return { allowed: true, reason: 'Resource owner access' };
    }

    // 2. ê³µìœ  ë¦¬ì†ŒìŠ¤ í™•ì¸
    const sharedAccess = await this.checkSharedAccess(
      user.id,
      resourceOwnerId,
      resourceType,
      action
    );

    if (sharedAccess.isShared) {
      return { allowed: true, reason: 'Shared resource access' };
    }

    // 3. ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
    const isAdmin = user.roles.includes('admin') || user.roles.includes('moderator');
    if (isAdmin) {
      await this.auditLogger.logAdminAccess({
        adminId: user.id,
        targetResourceId: resourceOwnerId,
        resourceType,
        action,
        timestamp: new Date()
      });

      return { allowed: true, reason: 'Administrative access' };
    }

    // 4. ìœ„ë°˜ ë¡œê¹…
    await this.auditLogger.logAccessViolation({
      userId: user.id,
      type: 'horizontal_privilege_escalation_attempt',
      targetResourceId: resourceOwnerId,
      resourceType,
      action,
      timestamp: new Date()
    });

    return {
      allowed: false,
      reason: 'Cannot access other user\'s resources',
      violation: 'horizontal_privilege_escalation'
    };
  }

  // ì§ì ‘ ê°ì²´ ì°¸ì¡° ë³´ì•ˆ
  async validateDirectObjectReference(
    user: User,
    objectId: string,
    objectType: string
  ): Promise<ObjectReferenceValidation> {
    // 1. ê°ì²´ ì¡´ì¬ í™•ì¸
    const objectExists = await this.verifyObjectExists(objectId, objectType);
    if (!objectExists) {
      return {
        isValid: false,
        reason: 'Object not found',
        shouldRevealExistence: false // ì •ë³´ ë…¸ì¶œ ë°©ì§€
      };
    }

    // 2. ì†Œìœ ê¶Œ í™•ì¸
    const ownership = await this.verifyObjectOwnership(user.id, objectId, objectType);

    // 3. ì ‘ê·¼ ê¶Œí•œ í™•ì¸
    const accessPermission = await this.checkObjectAccess(user, objectId, objectType);

    const isValid = ownership.isOwner || accessPermission.hasAccess;

    if (!isValid) {
      await this.auditLogger.logDirectObjectReferenceAttempt({
        userId: user.id,
        objectId,
        objectType,
        timestamp: new Date()
      });
    }

    return {
      isValid,
      reason: isValid ? 'Access granted' : 'Access denied',
      shouldRevealExistence: isValid || ownership.isOwner,
      metadata: {
        isOwner: ownership.isOwner,
        hasSharedAccess: accessPermission.hasAccess,
        accessLevel: accessPermission.level
      }
    };
  }

  // ì„¸ì…˜ ê´€ë¦¬ ë³´ì•ˆ
  async validateSessionSecurity(sessionToken: string): Promise<SessionValidation> {
    try {
      // 1. ì„¸ì…˜ í† í° ê²€ì¦
      const session = await this.validateSessionToken(sessionToken);
      if (!session.isValid) {
        return {
          isValid: false,
          reason: 'Invalid session token',
          action: 'redirect_to_login'
        };
      }

      // 2. ì„¸ì…˜ ê³ ì • ê³µê²© ë°©ì§€
      const fixationCheck = await this.checkSessionFixation(session);
      if (fixationCheck.isFixationAttempt) {
        await this.invalidateSession(sessionToken);
        return {
          isValid: false,
          reason: 'Session fixation detected',
          action: 'force_reauth'
        };
      }

      // 3. ë™ì‹œ ì„¸ì…˜ ì œí•œ
      const concurrentSessions = await this.checkConcurrentSessions(session.userId);
      if (concurrentSessions.exceedsLimit) {
        return {
          isValid: false,
          reason: 'Too many concurrent sessions',
          action: 'terminate_oldest_session'
        };
      }

      // 4. ì„¸ì…˜ í™œë™ ê²€ì¦
      const activityCheck = await this.validateSessionActivity(session);
      if (!activityCheck.isLegitimate) {
        await this.flagSuspiciousActivity(session);
        return {
          isValid: false,
          reason: 'Suspicious session activity',
          action: 'require_additional_auth'
        };
      }

      return {
        isValid: true,
        reason: 'Session valid',
        session: session
      };

    } catch (error) {
      console.error('Session validation error:', error);
      return {
        isValid: false,
        reason: 'Session validation failed',
        action: 'redirect_to_login'
      };
    }
  }
}
```

#### 2. A02 - Cryptographic Failures ëŒ€ì‘

```typescript
// ì•”í˜¸í™” ê´€ë¦¬ ì‹œìŠ¤í…œ
export class CryptographicManager {
  private encryptionConfig: EncryptionConfig;
  private keyManager: KeyManager;
  private hashManager: HashManager;

  constructor() {
    this.encryptionConfig = this.initializeEncryptionConfig();
    this.keyManager = new KeyManager();
    this.hashManager = new HashManager();
  }

  private initializeEncryptionConfig(): EncryptionConfig {
    return {
      // ëŒ€ì¹­ ì•”í˜¸í™” (ë°ì´í„° ì•”í˜¸í™”)
      symmetric: {
        algorithm: 'aes-256-gcm',
        keySize: 256,
        ivSize: 12,
        tagSize: 16
      },

      // ë¹„ëŒ€ì¹­ ì•”í˜¸í™” (í‚¤ êµí™˜)
      asymmetric: {
        algorithm: 'rsa',
        keySize: 4096,
        padding: 'oaep',
        hash: 'sha256'
      },

      // í•´ì‹œ í•¨ìˆ˜
      hashing: {
        algorithm: 'argon2id',
        saltSize: 32,
        iterations: 3,
        memory: 65536, // 64MB
        parallelism: 4
      },

      // TLS ì„¤ì •
      tls: {
        minVersion: 'TLSv1.3',
        cipherSuites: [
          'TLS_AES_256_GCM_SHA384',
          'TLS_CHACHA20_POLY1305_SHA256',
          'TLS_AES_128_GCM_SHA256'
        ],
        curves: ['prime256v1', 'secp384r1'],
        dhParamSize: 4096
      }
    };
  }

  // ê°œì¸ì •ë³´ ì•”í˜¸í™”
  async encryptPersonalData(
    data: string,
    dataType: 'email' | 'phone' | 'address' | 'name'
  ): Promise<EncryptedData> {
    try {
      // ë°ì´í„° íƒ€ì…ë³„ í‚¤ ì„ íƒ
      const keyId = await this.keyManager.getDataEncryptionKey(dataType);
      const key = await this.keyManager.getKey(keyId);

      // ì´ˆê¸°í™” ë²¡í„° ìƒì„±
      const iv = crypto.randomBytes(this.encryptionConfig.symmetric.ivSize);

      // ì•”í˜¸í™”
      const cipher = crypto.createCipher(this.encryptionConfig.symmetric.algorithm, key);
      cipher.setAAD(Buffer.from(dataType)); // ì¶”ê°€ ì¸ì¦ ë°ì´í„°

      let encrypted = cipher.update(data, 'utf8');
      encrypted = Buffer.concat([encrypted, cipher.final()]);

      const authTag = cipher.getAuthTag();

      return {
        encryptedData: encrypted.toString('base64'),
        iv: iv.toString('base64'),
        authTag: authTag.toString('base64'),
        keyId,
        algorithm: this.encryptionConfig.symmetric.algorithm,
        timestamp: new Date()
      };

    } catch (error) {
      console.error('Data encryption error:', error);
      throw new CryptographicError('Failed to encrypt personal data');
    }
  }

  // ê°œì¸ì •ë³´ ë³µí˜¸í™”
  async decryptPersonalData(encryptedData: EncryptedData): Promise<string> {
    try {
      const key = await this.keyManager.getKey(encryptedData.keyId);

      const decipher = crypto.createDecipher(encryptedData.algorithm, key);
      decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'base64'));
      decipher.setAAD(Buffer.from('email')); // ë°ì´í„° íƒ€ì…ì— ë”°ë¼ ì¡°ì • í•„ìš”

      let decrypted = decipher.update(
        Buffer.from(encryptedData.encryptedData, 'base64')
      );
      decrypted = Buffer.concat([decrypted, decipher.final()]);

      return decrypted.toString('utf8');

    } catch (error) {
      console.error('Data decryption error:', error);
      throw new CryptographicError('Failed to decrypt personal data');
    }
  }

  // ë¹„ë°€ë²ˆí˜¸ í•´ì‹±
  async hashPassword(password: string): Promise<HashedPassword> {
    try {
      // ë¹„ë°€ë²ˆí˜¸ ê°•ë„ ê²€ì¦
      const strengthCheck = this.validatePasswordStrength(password);
      if (!strengthCheck.isStrong) {
        throw new Error(`Weak password: ${strengthCheck.weaknesses.join(', ')}`);
      }

      // ì†”íŠ¸ ìƒì„±
      const salt = crypto.randomBytes(this.encryptionConfig.hashing.saltSize);

      // Argon2id í•´ì‹±
      const hash = await argon2.hash(password, {
        type: argon2.argon2id,
        salt,
        timeCost: this.encryptionConfig.hashing.iterations,
        memoryCost: this.encryptionConfig.hashing.memory,
        parallelism: this.encryptionConfig.hashing.parallelism,
        hashLength: 64
      });

      return {
        hash,
        salt: salt.toString('base64'),
        algorithm: 'argon2id',
        config: {
          iterations: this.encryptionConfig.hashing.iterations,
          memory: this.encryptionConfig.hashing.memory,
          parallelism: this.encryptionConfig.hashing.parallelism
        },
        createdAt: new Date()
      };

    } catch (error) {
      console.error('Password hashing error:', error);
      throw new CryptographicError('Failed to hash password');
    }
  }

  // ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
  async verifyPassword(
    password: string,
    hashedPassword: HashedPassword
  ): Promise<PasswordVerificationResult> {
    try {
      const isValid = await argon2.verify(hashedPassword.hash, password);

      // í•´ì‹œ ì„¤ì • ì—…ë°ì´íŠ¸ í•„ìš” ì—¬ë¶€ í™•ì¸
      const needsRehash = this.needsPasswordRehash(hashedPassword);

      return {
        isValid,
        needsRehash,
        timeTaken: Date.now() // íƒ€ì´ë° ê³µê²© ë°©ì§€ë¥¼ ìœ„í•œ ì¼ì •í•œ ì‹œê°„ ì†Œìš”
      };

    } catch (error) {
      console.error('Password verification error:', error);

      // íƒ€ì´ë° ê³µê²© ë°©ì§€ë¥¼ ìœ„í•´ ì¼ì • ì‹œê°„ ëŒ€ê¸°
      await new Promise(resolve => setTimeout(resolve, 100));

      return {
        isValid: false,
        needsRehash: false,
        timeTaken: Date.now()
      };
    }
  }

  // í† í° ìƒì„± (CSRF, API í‚¤ ë“±)
  generateSecureToken(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex');
  }

  // ì•”í˜¸í•™ì ìœ¼ë¡œ ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±
  generateSecureRandom(min: number, max: number): number {
    const range = max - min + 1;
    const bytesNeeded = Math.ceil(Math.log2(range) / 8);
    const maxValid = Math.floor(256 ** bytesNeeded / range) * range - 1;

    let random;
    do {
      const randomBytes = crypto.randomBytes(bytesNeeded);
      random = randomBytes.readUIntBE(0, bytesNeeded);
    } while (random > maxValid);

    return min + (random % range);
  }

  private validatePasswordStrength(password: string): PasswordStrengthResult {
    const weaknesses: string[] = [];

    if (password.length < 12) {
      weaknesses.push('Too short (minimum 12 characters)');
    }

    if (!/[a-z]/.test(password)) {
      weaknesses.push('Missing lowercase letter');
    }

    if (!/[A-Z]/.test(password)) {
      weaknesses.push('Missing uppercase letter');
    }

    if (!/\d/.test(password)) {
      weaknesses.push('Missing number');
    }

    if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
      weaknesses.push('Missing special character');
    }

    // ì¼ë°˜ì ì¸ íŒ¨í„´ ê²€ì‚¬
    if (/(.)\1{2,}/.test(password)) {
      weaknesses.push('Contains repeated characters');
    }

    if (/123|abc|qwe/i.test(password)) {
      weaknesses.push('Contains sequential characters');
    }

    return {
      isStrong: weaknesses.length === 0,
      weaknesses,
      score: Math.max(0, 100 - (weaknesses.length * 20))
    };
  }

  private needsPasswordRehash(hashedPassword: HashedPassword): boolean {
    // í˜„ì¬ ì„¤ì •ê³¼ ë¹„êµ
    const currentConfig = this.encryptionConfig.hashing;
    const passwordConfig = hashedPassword.config;

    return (
      passwordConfig.iterations < currentConfig.iterations ||
      passwordConfig.memory < currentConfig.memory ||
      passwordConfig.parallelism < currentConfig.parallelism
    );
  }
}
```

#### 3. A03 - Injection ëŒ€ì‘

```typescript
// ì£¼ì… ê³µê²© ë°©ì§€ ì‹œìŠ¤í…œ
export class InjectionPrevention {
  private sqlSanitizer: SQLSanitizer;
  private noSQLSanitizer: NoSQLSanitizer;
  private xssPrevention: XSSPrevention;
  private commandInjectionPrevention: CommandInjectionPrevention;

  constructor() {
    this.sqlSanitizer = new SQLSanitizer();
    this.noSQLSanitizer = new NoSQLSanitizer();
    this.xssPrevention = new XSSPrevention();
    this.commandInjectionPrevention = new CommandInjectionPrevention();
  }

  // SQL ì¸ì ì…˜ ë°©ì§€
  async sanitizeSQL(
    query: string,
    params: any[],
    context: QueryContext
  ): Promise<SanitizedQuery> {
    try {
      // 1. íŒŒë¼ë¯¸í„°í™”ëœ ì¿¼ë¦¬ ê²€ì¦
      const isParameterized = this.validateParameterizedQuery(query, params);
      if (!isParameterized) {
        throw new SecurityError('Non-parameterized query detected');
      }

      // 2. ìœ„í—˜í•œ í‚¤ì›Œë“œ ê²€ì‚¬
      const dangerousPatterns = this.detectDangerousPatterns(query);
      if (dangerousPatterns.length > 0) {
        await this.logSecurityIncident({
          type: 'sql_injection_attempt',
          patterns: dangerousPatterns,
          query: query.substring(0, 100), // ì¼ë¶€ë§Œ ë¡œê¹…
          userId: context.userId,
          timestamp: new Date()
        });

        throw new SecurityError('Potentially dangerous SQL patterns detected');
      }

      // 3. íŒŒë¼ë¯¸í„° ê°’ ê²€ì¦
      const sanitizedParams = await this.sanitizeParameters(params, context);

      // 4. ì¿¼ë¦¬ ë³µì¡ë„ ê²€ì‚¬
      const complexityCheck = this.analyzeQueryComplexity(query);
      if (complexityCheck.isTooComplex) {
        throw new SecurityError('Query too complex');
      }

      return {
        query,
        params: sanitizedParams,
        isValid: true,
        sanitizationApplied: sanitizedParams !== params
      };

    } catch (error) {
      console.error('SQL sanitization error:', error);
      throw error;
    }
  }

  // NoSQL ì¸ì ì…˜ ë°©ì§€ (MongoDB ë“±)
  sanitizeNoSQL(input: any, context: NoSQLContext): any {
    if (typeof input === 'string') {
      return this.sanitizeString(input);
    }

    if (Array.isArray(input)) {
      return input.map(item => this.sanitizeNoSQL(item, context));
    }

    if (input && typeof input === 'object') {
      const sanitized: any = {};

      for (const [key, value] of Object.entries(input)) {
        // ìœ„í—˜í•œ ì—°ì‚°ì ì°¨ë‹¨
        if (key.startsWith('$') && !this.isAllowedOperator(key, context)) {
          throw new SecurityError(`Dangerous NoSQL operator: ${key}`);
        }

        // ì¬ê·€ì  ê²€ì¦
        sanitized[this.sanitizeKey(key)] = this.sanitizeNoSQL(value, context);
      }

      return sanitized;
    }

    return input;
  }

  // XSS ë°©ì§€
  preventXSS(
    input: string,
    context: XSSContext = { allowedTags: [], outputContext: 'html' }
  ): string {
    try {
      // HTML íƒœê·¸ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê²€ì¦
      if (context.allowedTags.length > 0) {
        return this.sanitizeHTML(input, context.allowedTags);
      }

      // ì»¨í…ìŠ¤íŠ¸ë³„ ì¸ì½”ë”©
      switch (context.outputContext) {
        case 'html':
          return this.htmlEncode(input);
        case 'javascript':
          return this.javascriptEncode(input);
        case 'css':
          return this.cssEncode(input);
        case 'url':
          return this.urlEncode(input);
        default:
          return this.htmlEncode(input);
      }

    } catch (error) {
      console.error('XSS prevention error:', error);
      // ì˜¤ë¥˜ ì‹œ ëª¨ë“  íŠ¹ìˆ˜ ë¬¸ì ì œê±°
      return input.replace(/[<>'"&]/g, '');
    }
  }

  // ëª…ë ¹ì–´ ì£¼ì… ë°©ì§€
  preventCommandInjection(input: string, context: CommandContext): string {
    // ìœ„í—˜í•œ ë¬¸ì/íŒ¨í„´ ê²€ì‚¬
    const dangerousPatterns = [
      /[;&|`$(){}[\]]/,          // ì…¸ ë©”íƒ€ë¬¸ì
      /\.\./,                    // ë””ë ‰í† ë¦¬ ìˆœíšŒ
      /\/etc\/passwd/,           // ì‹œìŠ¤í…œ íŒŒì¼ ì ‘ê·¼
      /cmd\.exe|powershell/i,    // Windows ëª…ë ¹ì–´
      /\/bin\/|\/usr\/bin\//,    // Unix ëª…ë ¹ì–´ ê²½ë¡œ
    ];

    for (const pattern of dangerousPatterns) {
      if (pattern.test(input)) {
        throw new SecurityError('Command injection attempt detected');
      }
    }

    // í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ ê²€ì¦
    if (context.allowedChars) {
      const allowedPattern = new RegExp(`^[${context.allowedChars}]+$`);
      if (!allowedPattern.test(input)) {
        throw new SecurityError('Input contains disallowed characters');
      }
    }

    return input;
  }

  // LDAP ì¸ì ì…˜ ë°©ì§€
  sanitizeLDAP(input: string): string {
    // LDAP íŠ¹ìˆ˜ ë¬¸ì ì´ìŠ¤ì¼€ì´í”„
    const escapeMap: { [key: string]: string } = {
      '\\': '\\5c',
      '*': '\\2a',
      '(': '\\28',
      ')': '\\29',
      '\0': '\\00'
    };

    return input.replace(/[\\*()]/g, char => escapeMap[char] || char);
  }

  private validateParameterizedQuery(query: string, params: any[]): boolean {
    // íŒŒë¼ë¯¸í„° í”Œë ˆì´ìŠ¤í™€ë” ê°œìˆ˜ í™•ì¸
    const placeholderCount = (query.match(/\$\d+|\?/g) || []).length;
    return placeholderCount === params.length && placeholderCount > 0;
  }

  private detectDangerousPatterns(query: string): string[] {
    const patterns = [
      // SQL ì¸ì ì…˜ íŒ¨í„´
      /union\s+select/i,
      /or\s+1\s*=\s*1/i,
      /drop\s+table/i,
      /exec\s*\(/i,
      /insert\s+into.*values/i,
      /delete\s+from/i,
      /update.*set/i,
      // ì‹œê°„ ê¸°ë°˜ ê³µê²©
      /sleep\s*\(/i,
      /waitfor\s+delay/i,
      /benchmark\s*\(/i,
      // ë¶ˆë¦° ê¸°ë°˜ ê³µê²©
      /and\s+\(select/i,
      /or\s+\(select/i,
      // ëŒ“ê¸€ ê¸°ë°˜ ìš°íšŒ
      /\/\*.*\*\//,
      /--.*$/m,
      /#.*$/m
    ];

    const detected: string[] = [];
    for (const pattern of patterns) {
      if (pattern.test(query)) {
        detected.push(pattern.source);
      }
    }

    return detected;
  }

  private async sanitizeParameters(
    params: any[],
    context: QueryContext
  ): Promise<any[]> {
    return Promise.all(params.map(async (param, index) => {
      if (typeof param === 'string') {
        // ë¬¸ìì—´ ê¸¸ì´ ì œí•œ
        if (param.length > context.maxStringLength) {
          throw new SecurityError(`Parameter ${index} too long`);
        }

        // íŠ¹ìˆ˜ ë¬¸ì ê²€ì¦
        if (context.allowedCharsPattern && !context.allowedCharsPattern.test(param)) {
          throw new SecurityError(`Parameter ${index} contains invalid characters`);
        }

        return param;
      }

      if (typeof param === 'number') {
        // ìˆ«ì ë²”ìœ„ ê²€ì¦
        if (context.numberRange) {
          if (param < context.numberRange.min || param > context.numberRange.max) {
            throw new SecurityError(`Parameter ${index} out of range`);
          }
        }

        return param;
      }

      // ê¸°íƒ€ íƒ€ì… ê²€ì¦
      return param;
    }));
  }

  private htmlEncode(input: string): string {
    const htmlEntities: { [key: string]: string } = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    };

    return input.replace(/[&<>"'\/]/g, char => htmlEntities[char]);
  }

  private javascriptEncode(input: string): string {
    return input.replace(/[<>"'&\\]/g, char => {
      return '\\x' + char.charCodeAt(0).toString(16).padStart(2, '0');
    });
  }

  private sanitizeHTML(input: string, allowedTags: string[]): string {
    // DOMPurify ë˜ëŠ” ìœ ì‚¬í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© ê¶Œì¥
    const allowedTagsRegex = new RegExp(
      `<(?!\/?(${allowedTags.join('|')})(?:\\s|>))[^>]+>`,
      'gi'
    );

    return input.replace(allowedTagsRegex, '');
  }
}
```

---

## ğŸ” ë°ì´í„° ë³´í˜¸ ë° ì•”í˜¸í™”

### ë°ì´í„° ë¶„ë¥˜ ë° ë³´í˜¸ ì „ëµ

#### 1. ë°ì´í„° ë¶„ë¥˜ ì‹œìŠ¤í…œ

```typescript
// ë°ì´í„° ë¶„ë¥˜ ë° ë³´í˜¸ ë§¤ë‹ˆì €
export class DataClassificationManager {
  private classificationRules: DataClassificationRule[] = [];
  private protectionPolicies: ProtectionPolicy[] = [];

  constructor() {
    this.initializeClassificationRules();
    this.initializeProtectionPolicies();
  }

  private initializeClassificationRules(): void {
    this.classificationRules = [
      {
        name: 'personal_identifiable_information',
        level: 'restricted',
        patterns: [
          /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/, // ì´ë©”ì¼
          /^\d{3}-\d{4}-\d{4}$/, // ì „í™”ë²ˆí˜¸
          /^\d{6}-\d{7}$/, // ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸
          /^[ê°€-í£]{2,5}$/  // í•œêµ­ ì´ë¦„
        ],
        fields: ['email', 'phone', 'name', 'ssn'],
        retentionPeriod: 2555, // 7ë…„ (ì¼)
        requiresConsent: true,
        allowedOperations: ['read', 'update'],
        encryptionRequired: true,
        auditRequired: true
      },

      {
        name: 'sensitive_business_data',
        level: 'confidential',
        patterns: [
          /payment/i,
          /credit/i,
          /bank/i,
          /financial/i
        ],
        fields: ['payment_info', 'transaction_id', 'bank_account'],
        retentionPeriod: 1825, // 5ë…„
        requiresConsent: true,
        allowedOperations: ['read'],
        encryptionRequired: true,
        auditRequired: true
      },

      {
        name: 'public_content',
        level: 'public',
        patterns: [],
        fields: ['question_title', 'answer_content', 'hashtags'],
        retentionPeriod: -1, // ë¬´ì œí•œ
        requiresConsent: false,
        allowedOperations: ['read', 'create', 'update', 'delete'],
        encryptionRequired: false,
        auditRequired: false
      },

      {
        name: 'internal_operations',
        level: 'internal',
        patterns: [
          /log/i,
          /metric/i,
          /analytics/i
        ],
        fields: ['access_logs', 'performance_metrics', 'usage_analytics'],
        retentionPeriod: 90, // 90ì¼
        requiresConsent: false,
        allowedOperations: ['read', 'create'],
        encryptionRequired: false,
        auditRequired: true
      }
    ];
  }

  private initializeProtectionPolicies(): void {
    this.protectionPolicies = [
      {
        classification: 'restricted',
        encryption: {
          atRest: {
            required: true,
            algorithm: 'aes-256-gcm',
            keyRotationPeriod: 90 // ì¼
          },
          inTransit: {
            required: true,
            minTLSVersion: 'TLSv1.3',
            certificateValidation: true
          },
          inProcessing: {
            required: true,
            useSecureEnclaves: true,
            minimizeExposure: true
          }
        },
        access: {
          authentication: 'multi_factor',
          authorization: 'attribute_based',
          sessionTimeout: 1800, // 30ë¶„
          concurrentSessions: 1
        },
        audit: {
          logAllAccess: true,
          logDataChanges: true,
          retentionPeriod: 2555, // 7ë…„
          realTimeMonitoring: true
        },
        backup: {
          encryptionRequired: true,
          geographicRestrictions: ['KR'], // í•œêµ­ ë‚´ì—ë§Œ
          retentionPeriod: 2555,
          testRestoreProcedure: true
        }
      },

      {
        classification: 'confidential',
        encryption: {
          atRest: {
            required: true,
            algorithm: 'aes-256-gcm',
            keyRotationPeriod: 180
          },
          inTransit: {
            required: true,
            minTLSVersion: 'TLSv1.2',
            certificateValidation: true
          },
          inProcessing: {
            required: false,
            useSecureEnclaves: false,
            minimizeExposure: true
          }
        },
        access: {
          authentication: 'single_factor',
          authorization: 'role_based',
          sessionTimeout: 3600, // 1ì‹œê°„
          concurrentSessions: 3
        },
        audit: {
          logAllAccess: true,
          logDataChanges: true,
          retentionPeriod: 1825, // 5ë…„
          realTimeMonitoring: false
        }
      }
    ];
  }

  // ë°ì´í„° ìë™ ë¶„ë¥˜
  async classifyData(
    fieldName: string,
    value: any,
    context: DataContext
  ): Promise<DataClassification> {
    const classifications: DataClassificationResult[] = [];

    for (const rule of this.classificationRules) {
      const confidence = this.calculateClassificationConfidence(
        fieldName,
        value,
        rule
      );

      if (confidence > 0.7) {
        classifications.push({
          rule: rule.name,
          level: rule.level,
          confidence,
          matchedPatterns: this.getMatchedPatterns(value, rule.patterns),
          appliedProtections: this.getApplicableProtections(rule.level)
        });
      }
    }

    // ê°€ì¥ ë†’ì€ ë³´ì•ˆ ìˆ˜ì¤€ ì„ íƒ
    const highestClassification = classifications.sort(
      (a, b) => this.getSecurityLevel(b.level) - this.getSecurityLevel(a.level)
    )[0];

    return {
      fieldName,
      classification: highestClassification?.level || 'public',
      confidence: highestClassification?.confidence || 1.0,
      protectionRequirements: this.getProtectionRequirements(
        highestClassification?.level || 'public'
      ),
      timestamp: new Date()
    };
  }

  // ë°ì´í„° ë³´í˜¸ ì ìš©
  async applyDataProtection(
    data: any,
    classification: DataClassification
  ): Promise<ProtectedData> {
    const policy = this.getProtectionPolicy(classification.classification);
    const protectedData: any = { ...data };

    // 1. ì•”í˜¸í™” ì ìš©
    if (policy.encryption.atRest.required) {
      protectedData.encryptedFields = await this.encryptSensitiveFields(
        data,
        classification,
        policy.encryption.atRest.algorithm
      );
    }

    // 2. ë§ˆìŠ¤í‚¹ ì ìš© (ë¡œê¹…ìš©)
    protectedData.maskedForLogging = this.maskSensitiveData(data, classification);

    // 3. ì ‘ê·¼ ì œì–´ ë©”íƒ€ë°ì´í„° ì¶”ê°€
    protectedData.accessControl = {
      requiredRoles: this.getRequiredRoles(classification.classification),
      allowedOperations: this.getAllowedOperations(classification.classification),
      sessionRequirements: policy.access
    };

    // 4. ê°ì‚¬ ë¡œê·¸ ìƒì„±
    if (policy.audit.logAllAccess) {
      await this.createAuditLog({
        action: 'data_protection_applied',
        dataClassification: classification.classification,
        fieldName: classification.fieldName,
        timestamp: new Date()
      });
    }

    return {
      originalData: data,
      protectedData,
      classification,
      protectionPolicy: policy,
      appliedAt: new Date()
    };
  }

  // ê°œì¸ì •ë³´ ìµëª…í™”
  async anonymizePersonalData(
    data: any,
    anonymizationLevel: 'partial' | 'full' | 'pseudonymization'
  ): Promise<AnonymizedData> {
    const anonymizedData: any = { ...data };
    const anonymizationLog: AnonymizationRecord[] = [];

    for (const [key, value] of Object.entries(data)) {
      const classification = await this.classifyData(key, value, {});

      if (classification.classification === 'restricted') {
        const anonymizedValue = await this.anonymizeField(
          key,
          value,
          anonymizationLevel
        );

        anonymizedData[key] = anonymizedValue.value;
        anonymizationLog.push({
          fieldName: key,
          originalType: typeof value,
          anonymizationMethod: anonymizedValue.method,
          isReversible: anonymizedValue.isReversible,
          timestamp: new Date()
        });
      }
    }

    return {
      anonymizedData,
      anonymizationLog,
      level: anonymizationLevel,
      isReversible: anonymizationLevel === 'pseudonymization',
      createdAt: new Date()
    };
  }

  private async anonymizeField(
    fieldName: string,
    value: any,
    level: string
  ): Promise<AnonymizedField> {
    switch (level) {
      case 'partial':
        return this.partialAnonymization(fieldName, value);
      case 'full':
        return this.fullAnonymization(fieldName, value);
      case 'pseudonymization':
        return this.pseudonymization(fieldName, value);
      default:
        throw new Error(`Unsupported anonymization level: ${level}`);
    }
  }

  private partialAnonymization(fieldName: string, value: string): AnonymizedField {
    if (fieldName === 'email') {
      const [local, domain] = value.split('@');
      const maskedLocal = local.substring(0, 2) + '*'.repeat(local.length - 2);
      return {
        value: `${maskedLocal}@${domain}`,
        method: 'partial_masking',
        isReversible: false
      };
    }

    if (fieldName === 'phone') {
      return {
        value: value.substring(0, 3) + '-****-' + value.substring(8),
        method: 'partial_masking',
        isReversible: false
      };
    }

    if (fieldName === 'name') {
      return {
        value: value.charAt(0) + '*'.repeat(value.length - 1),
        method: 'partial_masking',
        isReversible: false
      };
    }

    return {
      value: '*'.repeat(value.length),
      method: 'full_masking',
      isReversible: false
    };
  }

  private async pseudonymization(
    fieldName: string,
    value: string
  ): Promise<AnonymizedField> {
    // ì•”í˜¸í™” ê¸°ë°˜ ì˜ì‚¬ì‹ë³„ì ìƒì„±
    const pseudonym = await this.generatePseudonym(value);

    return {
      value: pseudonym,
      method: 'pseudonymization',
      isReversible: true
    };
  }

  private async generatePseudonym(value: string): Promise<string> {
    const key = await this.getPseudonymizationKey();
    const hmac = crypto.createHmac('sha256', key);
    hmac.update(value);
    return hmac.digest('hex');
  }
}
```

#### 2. ì•”í˜¸í™” í‚¤ ê´€ë¦¬

```typescript
// ì•”í˜¸í™” í‚¤ ê´€ë¦¬ ì‹œìŠ¤í…œ
export class KeyManagementService {
  private hsmClient: HSMClient;
  private keyStore: KeyStore;
  private keyRotationScheduler: KeyRotationScheduler;

  constructor() {
    this.hsmClient = new HSMClient();
    this.keyStore = new KeyStore();
    this.keyRotationScheduler = new KeyRotationScheduler();
  }

  // ë§ˆìŠ¤í„° í‚¤ ìƒì„±
  async generateMasterKey(
    keyId: string,
    keySpec: KeySpecification
  ): Promise<MasterKey> {
    try {
      // HSMì—ì„œ ë§ˆìŠ¤í„° í‚¤ ìƒì„±
      const masterKey = await this.hsmClient.generateKey({
        keyId,
        keyType: keySpec.keyType,
        keyLength: keySpec.keyLength,
        keyUsage: keySpec.keyUsage,
        extractable: false, // ë§ˆìŠ¤í„° í‚¤ëŠ” ì¶”ì¶œ ë¶ˆê°€
        attributes: {
          encrypt: true,
          decrypt: true,
          wrapKey: true,
          unwrapKey: true
        }
      });

      // í‚¤ ë©”íƒ€ë°ì´í„° ì €ì¥
      await this.keyStore.storeMasterKeyMetadata({
        keyId,
        keyType: keySpec.keyType,
        keyLength: keySpec.keyLength,
        createdAt: new Date(),
        rotationPeriod: keySpec.rotationPeriod,
        status: 'active',
        hsmKeyId: masterKey.hsmKeyId
      });

      // í‚¤ íšŒì „ ìŠ¤ì¼€ì¤„ë§
      await this.scheduleKeyRotation(keyId, keySpec.rotationPeriod);

      return {
        keyId,
        hsmKeyId: masterKey.hsmKeyId,
        status: 'active',
        createdAt: new Date()
      };

    } catch (error) {
      console.error('Master key generation failed:', error);
      throw new KeyManagementError('Failed to generate master key');
    }
  }

  // ë°ì´í„° ì•”í˜¸í™” í‚¤ ìƒì„±
  async generateDataEncryptionKey(
    masterKeyId: string,
    context: KeyContext
  ): Promise<DataEncryptionKey> {
    try {
      // ë¡œì»¬ì—ì„œ ë°ì´í„° ì•”í˜¸í™” í‚¤ ìƒì„±
      const dek = crypto.randomBytes(32); // 256-bit í‚¤

      // ë§ˆìŠ¤í„° í‚¤ë¡œ DEK ì•”í˜¸í™”
      const encryptedDEK = await this.hsmClient.encrypt({
        keyId: masterKeyId,
        plaintext: dek,
        encryptionContext: context
      });

      const dekId = this.generateKeyId();

      // ì•”í˜¸í™”ëœ DEK ì €ì¥
      await this.keyStore.storeEncryptedDEK({
        dekId,
        masterKeyId,
        encryptedDEK: encryptedDEK.ciphertext,
        encryptionContext: context,
        createdAt: new Date(),
        status: 'active'
      });

      return {
        dekId,
        masterKeyId,
        plaintextKey: dek,
        encryptedKey: encryptedDEK.ciphertext,
        createdAt: new Date()
      };

    } catch (error) {
      console.error('DEK generation failed:', error);
      throw new KeyManagementError('Failed to generate data encryption key');
    }
  }

  // í‚¤ íšŒì „
  async rotateKey(keyId: string): Promise<KeyRotationResult> {
    try {
      const keyMetadata = await this.keyStore.getKeyMetadata(keyId);
      if (!keyMetadata) {
        throw new Error(`Key ${keyId} not found`);
      }

      // ìƒˆ í‚¤ ìƒì„±
      const newKey = await this.generateMasterKey(
        `${keyId}_v${keyMetadata.version + 1}`,
        {
          keyType: keyMetadata.keyType,
          keyLength: keyMetadata.keyLength,
          keyUsage: keyMetadata.keyUsage,
          rotationPeriod: keyMetadata.rotationPeriod
        }
      );

      // ê¸°ì¡´ í‚¤ë¥¼ rotation_pending ìƒíƒœë¡œ ë³€ê²½
      await this.keyStore.updateKeyStatus(keyId, 'rotation_pending');

      // ìƒˆ í‚¤ë¥¼ active ìƒíƒœë¡œ ì„¤ì •
      await this.keyStore.updateKeyStatus(newKey.keyId, 'active');

      // ë°ì´í„° ì¬ì•”í˜¸í™” ì‘ì—… ì‹œì‘
      await this.scheduleDataReencryption(keyId, newKey.keyId);

      // ê¸°ì¡´ í‚¤ì˜ íê¸° ìŠ¤ì¼€ì¤„ë§ (ì¬ì•”í˜¸í™” ì™„ë£Œ í›„)
      await this.scheduleKeyDecommission(keyId, 30); // 30ì¼ í›„ íê¸°

      return {
        oldKeyId: keyId,
        newKeyId: newKey.keyId,
        rotationStarted: new Date(),
        reencryptionRequired: true,
        decommissionDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
      };

    } catch (error) {
      console.error('Key rotation failed:', error);
      throw new KeyManagementError('Failed to rotate key');
    }
  }

  // í‚¤ íê¸°
  async decommissionKey(keyId: string): Promise<void> {
    try {
      // í‚¤ ì‚¬ìš© ì—¬ë¶€ í™•ì¸
      const keyUsage = await this.checkKeyUsage(keyId);
      if (keyUsage.isInUse) {
        throw new Error(`Key ${keyId} is still in use, cannot decommission`);
      }

      // HSMì—ì„œ í‚¤ ì‚­ì œ
      await this.hsmClient.deleteKey(keyId);

      // ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸
      await this.keyStore.updateKeyStatus(keyId, 'decommissioned');

      // ê°ì‚¬ ë¡œê·¸
      await this.auditLogger.log({
        action: 'key_decommissioned',
        keyId,
        timestamp: new Date()
      });

    } catch (error) {
      console.error('Key decommission failed:', error);
      throw new KeyManagementError('Failed to decommission key');
    }
  }

  // í‚¤ ë³µêµ¬ (ì¬í•´ ë³µêµ¬ìš©)
  async recoverKey(
    keyId: string,
    recoveryData: KeyRecoveryData
  ): Promise<RecoveredKey> {
    try {
      // ë³µêµ¬ ë°ì´í„° ê²€ì¦
      const isValidRecovery = await this.validateRecoveryData(recoveryData);
      if (!isValidRecovery) {
        throw new Error('Invalid recovery data');
      }

      // í‚¤ ë³µêµ¬
      const recoveredKey = await this.hsmClient.recoverKey({
        keyId,
        recoveryShares: recoveryData.shares,
        threshold: recoveryData.threshold
      });

      // ë³µêµ¬ëœ í‚¤ ê²€ì¦
      const isValidKey = await this.validateRecoveredKey(recoveredKey);
      if (!isValidKey) {
        throw new Error('Recovered key validation failed');
      }

      // í‚¤ ë©”íƒ€ë°ì´í„° ë³µì›
      await this.keyStore.restoreKeyMetadata(keyId, recoveryData.metadata);

      // ê°ì‚¬ ë¡œê·¸
      await this.auditLogger.log({
        action: 'key_recovered',
        keyId,
        recoveredBy: recoveryData.recoveredBy,
        timestamp: new Date()
      });

      return {
        keyId,
        recoveredAt: new Date(),
        status: 'recovered'
      };

    } catch (error) {
      console.error('Key recovery failed:', error);
      throw new KeyManagementError('Failed to recover key');
    }
  }

  // í‚¤ ë°±ì—…
  async backupKey(keyId: string, backupLocation: string): Promise<KeyBackup> {
    try {
      const keyMetadata = await this.keyStore.getKeyMetadata(keyId);
      if (!keyMetadata) {
        throw new Error(`Key ${keyId} not found`);
      }

      // HSMì—ì„œ í‚¤ ë°±ì—… ìƒì„±
      const backupData = await this.hsmClient.backupKey(keyId);

      // ë°±ì—… ì•”í˜¸í™”
      const encryptedBackup = await this.encryptBackup(backupData);

      // ë°±ì—… ì €ì¥
      const backupId = await this.storeBackup(encryptedBackup, backupLocation);

      return {
        backupId,
        keyId,
        backupLocation,
        createdAt: new Date(),
        encryptionAlgorithm: 'aes-256-gcm'
      };

    } catch (error) {
      console.error('Key backup failed:', error);
      throw new KeyManagementError('Failed to backup key');
    }
  }

  private async scheduleKeyRotation(keyId: string, rotationPeriod: number): Promise<void> {
    const rotationDate = new Date(Date.now() + rotationPeriod * 24 * 60 * 60 * 1000);

    await this.keyRotationScheduler.schedule({
      keyId,
      rotationDate,
      notificationDate: new Date(rotationDate.getTime() - 7 * 24 * 60 * 60 * 1000), // 7ì¼ ì „ ì•Œë¦¼
      callback: () => this.rotateKey(keyId)
    });
  }

  private generateKeyId(): string {
    return `dek_${Date.now()}_${crypto.randomBytes(8).toString('hex')}`;
  }
}
```

ì´ ë³´ì•ˆ ì•„í‚¤í…ì²˜ ì„¤ê³„ì„œëŠ” "ë™ë„¤ë¬¼ì–´ë´" ì„œë¹„ìŠ¤ì˜ í¬ê´„ì ì¸ ë³´ì•ˆ ì²´ê³„ë¥¼ êµ¬ì¶•í•˜ê¸° ìœ„í•œ ìƒì„¸í•œ ê°€ì´ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤. Zero Trust ëª¨ë¸ ì ìš©, OWASP ê¸°ë°˜ ë³´ì•ˆ ê²€ì¦, ê³ ê¸‰ ì•”í˜¸í™” ì‹œìŠ¤í…œì„ í†µí•´ ë‹¤ì¸µ ë³´ì•ˆ ë°©ì–´ì²´ê³„ë¥¼ êµ¬ì¶•í•˜ì—¬ ì‚¬ìš©ì ë°ì´í„°ì™€ ì„œë¹„ìŠ¤ë¥¼ ì•ˆì „í•˜ê²Œ ë³´í˜¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.