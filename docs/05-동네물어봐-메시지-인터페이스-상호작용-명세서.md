# "ë™ë„¤ë¬¼ì–´ë´" ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ ì¸í„°í˜ì´ìŠ¤ ìƒí˜¸ì‘ìš© ëª…ì„¸ì„œ

## ğŸ“‹ ëª©ì°¨
1. [ë©”ì‹œì§€ UI ë””ìì¸ ì‹œìŠ¤í…œ](#-ë©”ì‹œì§€-ui-ë””ìì¸-ì‹œìŠ¤í…œ)
2. [ì‹¤ì‹œê°„ ìƒí˜¸ì‘ìš© íŒ¨í„´](#-ì‹¤ì‹œê°„-ìƒí˜¸ì‘ìš©-íŒ¨í„´)
3. [í„°ì¹˜ ë° ì œìŠ¤ì²˜ ì¸í„°í˜ì´ìŠ¤](#-í„°ì¹˜-ë°-ì œìŠ¤ì²˜-ì¸í„°í˜ì´ìŠ¤)
4. [ìŒì„± ë° ë©€í‹°ë¯¸ë””ì–´ ì…ë ¥](#-ìŒì„±-ë°-ë©€í‹°ë¯¸ë””ì–´-ì…ë ¥)
5. [í•´ì‹œíƒœê·¸ ì‹œìŠ¤í…œ ìƒí˜¸ì‘ìš©](#-í•´ì‹œíƒœê·¸-ì‹œìŠ¤í…œ-ìƒí˜¸ì‘ìš©)
6. [ì• ë‹ˆë©”ì´ì…˜ ë° í”¼ë“œë°±](#-ì• ë‹ˆë©”ì´ì…˜-ë°-í”¼ë“œë°±)
7. [ì ‘ê·¼ì„± ë° ì‚¬ìš©ì„±](#-ì ‘ê·¼ì„±-ë°-ì‚¬ìš©ì„±)

---

## ğŸ’¬ ë©”ì‹œì§€ UI ë””ìì¸ ì‹œìŠ¤í…œ

### ê¸°ë³¸ ë””ìì¸ ì›ì¹™
- **ì¹œìˆ™í•¨**: ì¹´ì¹´ì˜¤í†¡, ì¸ìŠ¤íƒ€ê·¸ë¨ DMê³¼ ìœ ì‚¬í•œ ì¸í„°í˜ì´ìŠ¤
- **ëª…í™•ì„±**: ì§ˆë¬¸ê³¼ ë‹µë³€ì˜ ì‹œê°ì  êµ¬ë¶„
- **íš¨ìœ¨ì„±**: ìµœì†Œí•œì˜ íƒ­ìœ¼ë¡œ ëª©ì  ë‹¬ì„±
- **ì¼ê´€ì„±**: í”Œë«í¼ ê°„ ë™ì¼í•œ ìƒí˜¸ì‘ìš© íŒ¨í„´

### ë©”ì‹œì§€ ë²„ë¸” ë””ìì¸ ëª…ì„¸

#### ì§ˆë¬¸ ë©”ì‹œì§€ (ì˜¤ë¥¸ìª½ ì •ë ¬)

```css
/* ì§ˆë¬¸ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ */
.message-bubble.question {
  margin-left: 60px;
  margin-right: 16px;
  margin-bottom: 16px;
  align-self: flex-end;
}

.question-bubble {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 20px 20px 6px 20px;
  padding: 12px 16px;
  max-width: 70%;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
  position: relative;
}

.question-bubble::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: -6px;
  width: 0;
  height: 0;
  border: 6px solid transparent;
  border-top-color: #764ba2;
}

/* ì§ˆë¬¸ ë‚´ìš© */
.question-content {
  font-size: 16px;
  line-height: 1.4;
  margin-bottom: 8px;
}

/* í•´ì‹œíƒœê·¸ ìŠ¤íƒ€ì¼ */
.question-hashtags {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 8px;
}

.hashtag {
  background: rgba(255, 255, 255, 0.2);
  color: white;
  font-size: 12px;
  padding: 2px 6px;
  border-radius: 10px;
  font-weight: 500;
}
```

#### ë‹µë³€ ë©”ì‹œì§€ (ì™¼ìª½ ì •ë ¬)

```css
/* ë‹µë³€ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ */
.message-bubble.answer {
  margin-left: 16px;
  margin-right: 60px;
  margin-bottom: 16px;
  align-self: flex-start;
}

.answer-bubble {
  background: #ffffff;
  color: #333333;
  border: 1px solid #e0e0e0;
  border-radius: 20px 20px 20px 6px;
  padding: 12px 16px;
  max-width: 70%;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  position: relative;
}

.answer-bubble::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: -6px;
  width: 0;
  height: 0;
  border: 6px solid transparent;
  border-top-color: #ffffff;
}

/* í˜„ì§€ì¸ ë°°ì§€ê°€ ìˆëŠ” ë‹µë³€ */
.answer-bubble.local-verified {
  border-color: #ff9500;
  box-shadow: 0 2px 8px rgba(255, 149, 0, 0.2);
}

.answer-bubble.local-verified::before {
  content: 'ğŸ ';
  position: absolute;
  top: -8px;
  left: 12px;
  background: #ff9500;
  color: white;
  font-size: 12px;
  padding: 2px 6px;
  border-radius: 10px;
}
```

### ë©”ì‹œì§€ ë©”íƒ€ ì •ë³´

```typescript
// ë©”ì‹œì§€ ë©”íƒ€ ì •ë³´ ì»´í¬ë„ŒíŠ¸
interface MessageMetaProps {
  user: User;
  timestamp: Date;
  status?: 'sending' | 'sent' | 'delivered' | 'read';
  location?: Location;
  urgency?: 'normal' | 'high' | 'urgent';
}

const MessageMeta: React.FC<MessageMetaProps> = ({
  user,
  timestamp,
  status,
  location,
  urgency
}) => {
  return (
    <div className="message-meta">
      <UserProfile user={user} size="small" />
      <MessageInfo>
        <span className="username">{user.nickname}</span>
        {user.isLocalVerified && <VerificationBadge />}
        <span className="timestamp">{formatTimeAgo(timestamp)}</span>
        {location && <LocationTag location={location} />}
        {urgency && urgency !== 'normal' && (
          <UrgencyIndicator level={urgency} />
        )}
      </MessageInfo>
      {status && <MessageStatus status={status} />}
    </div>
  );
};
```

---

## âš¡ ì‹¤ì‹œê°„ ìƒí˜¸ì‘ìš© íŒ¨í„´

### íƒ€ì´í•‘ ì¸ë””ì¼€ì´í„°

#### ì‹œê°ì  ë””ìì¸

```css
/* íƒ€ì´í•‘ ì¸ë””ì¼€ì´í„° */
.typing-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  margin: 8px 16px 8px 16px;
  background: #f5f5f5;
  border-radius: 20px;
  animation: fadeIn 0.3s ease-in-out;
}

.typing-avatar {
  width: 24px;
  height: 24px;
  border-radius: 12px;
  border: 2px solid #ffffff;
}

.typing-text {
  font-size: 14px;
  color: #666666;
  margin-right: 8px;
}

.typing-dots {
  display: flex;
  gap: 3px;
}

.typing-dot {
  width: 4px;
  height: 4px;
  background: #999999;
  border-radius: 50%;
  animation: typing 1.4s infinite ease-in-out;
}

.typing-dot:nth-child(1) { animation-delay: -0.32s; }
.typing-dot:nth-child(2) { animation-delay: -0.16s; }
.typing-dot:nth-child(3) { animation-delay: 0s; }

@keyframes typing {
  0%, 80%, 100% {
    transform: scale(0.8);
    opacity: 0.5;
  }
  40% {
    transform: scale(1);
    opacity: 1;
  }
}
```

#### íƒ€ì´í•‘ ìƒíƒœ ê´€ë¦¬

```typescript
// íƒ€ì´í•‘ ìƒíƒœ ê´€ë¦¬ í›…
const useTypingIndicator = (questionId: string) => {
  const [typingUsers, setTypingUsers] = useState<TypingUser[]>([]);
  const { socket } = useSocket();
  const typingTimeoutRef = useRef<NodeJS.Timeout>();

  const startTyping = useCallback(() => {
    socket?.emit('typing_start', { questionId });

    // 3ì´ˆ í›„ ìë™ìœ¼ë¡œ íƒ€ì´í•‘ ì¤‘ì§€
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    typingTimeoutRef.current = setTimeout(() => {
      socket?.emit('typing_stop', { questionId });
    }, 3000);
  }, [socket, questionId]);

  const stopTyping = useCallback(() => {
    socket?.emit('typing_stop', { questionId });
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
  }, [socket, questionId]);

  useEffect(() => {
    socket?.on('user_typing', (data) => {
      if (data.questionId === questionId) {
        setTypingUsers(prev => [
          ...prev.filter(u => u.userId !== data.userId),
          data
        ]);
      }
    });

    socket?.on('user_stop_typing', (data) => {
      if (data.questionId === questionId) {
        setTypingUsers(prev =>
          prev.filter(u => u.userId !== data.userId)
        );
      }
    });

    return () => {
      socket?.off('user_typing');
      socket?.off('user_stop_typing');
    };
  }, [socket, questionId]);

  return { typingUsers, startTyping, stopTyping };
};
```

### ì‹¤ì‹œê°„ ë©”ì‹œì§€ ìˆ˜ì‹ 

```typescript
// ì‹¤ì‹œê°„ ë©”ì‹œì§€ ìˆ˜ì‹  ì²˜ë¦¬
const useRealTimeMessages = (questionId: string) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const { socket } = useSocket();
  const audioRef = useRef<HTMLAudioElement>();

  useEffect(() => {
    // ìƒˆ ë‹µë³€ ìˆ˜ì‹ 
    socket?.on('new_answer', (answer: Answer) => {
      if (answer.questionId === questionId) {
        setMessages(prev => [...prev, answer]);

        // ì•Œë¦¼ìŒ ì¬ìƒ (ì‚¬ìš©ì ì„¤ì •ì— ë”°ë¼)
        if (audioRef.current && isNotificationEnabled()) {
          audioRef.current.play();
        }

        // ì‹œìŠ¤í…œ ì•Œë¦¼ í‘œì‹œ
        showNotification('ìƒˆ ë‹µë³€ì´ ë„ì°©í–ˆìŠµë‹ˆë‹¤!', {
          body: answer.content.substring(0, 100),
          icon: answer.user.profileImage
        });
      }
    });

    // ë‹µë³€ ì±„íƒ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
    socket?.on('answer_accepted', (data) => {
      if (data.questionId === questionId) {
        setMessages(prev =>
          prev.map(msg =>
            msg.id === data.answerId
              ? { ...msg, isAccepted: true }
              : msg
          )
        );
      }
    });

    return () => {
      socket?.off('new_answer');
      socket?.off('answer_accepted');
    };
  }, [socket, questionId]);

  return messages;
};
```

### ì½ìŒ ìƒíƒœ í‘œì‹œ

```typescript
// ì½ìŒ ìƒíƒœ ì»´í¬ë„ŒíŠ¸
const ReadStatus: React.FC<{ status: MessageStatus }> = ({ status }) => {
  const getStatusIcon = () => {
    switch (status) {
      case 'sending':
        return <SpinnerIcon className="animate-spin" />;
      case 'sent':
        return <CheckIcon className="text-gray-400" />;
      case 'delivered':
        return <DoubleCheckIcon className="text-gray-400" />;
      case 'read':
        return <DoubleCheckIcon className="text-blue-500" />;
      default:
        return null;
    }
  };

  return (
    <div className="read-status">
      {getStatusIcon()}
    </div>
  );
};

// ì½ìŒ ìƒíƒœ ì¶”ì 
const useReadStatus = (messageId: string) => {
  const [status, setStatus] = useState<MessageStatus>('sending');
  const { socket } = useSocket();

  useEffect(() => {
    // ë©”ì‹œì§€ ì „ì†¡ ì™„ë£Œ
    socket?.on('message_sent', (data) => {
      if (data.messageId === messageId) {
        setStatus('sent');
      }
    });

    // ë©”ì‹œì§€ ì½ìŒ í™•ì¸
    socket?.on('message_read', (data) => {
      if (data.messageId === messageId) {
        setStatus('read');
      }
    });

    return () => {
      socket?.off('message_sent');
      socket?.off('message_read');
    };
  }, [socket, messageId]);

  return status;
};
```

---

## ğŸ‘† í„°ì¹˜ ë° ì œìŠ¤ì²˜ ì¸í„°í˜ì´ìŠ¤

### ìŠ¤ì™€ì´í”„ ì œìŠ¤ì²˜

#### ìŠ¤ì™€ì´í”„ ì•¡ì…˜ ì •ì˜

```typescript
// ìŠ¤ì™€ì´í”„ ì œìŠ¤ì²˜ í›…
const useSwipeGestures = (
  onSwipeLeft?: () => void,
  onSwipeRight?: () => void,
  threshold: number = 50
) => {
  const [startX, setStartX] = useState(0);
  const [startY, setStartY] = useState(0);

  const handleTouchStart = (e: TouchEvent) => {
    setStartX(e.touches[0].clientX);
    setStartY(e.touches[0].clientY);
  };

  const handleTouchEnd = (e: TouchEvent) => {
    const endX = e.changedTouches[0].clientX;
    const endY = e.changedTouches[0].clientY;
    const deltaX = endX - startX;
    const deltaY = endY - startY;

    // ìˆ˜ì§ ìŠ¤í¬ë¡¤ì´ ìš°ì„ ì¸ ê²½ìš° ì œìŠ¤ì²˜ ë¬´ì‹œ
    if (Math.abs(deltaY) > Math.abs(deltaX)) return;

    if (Math.abs(deltaX) > threshold) {
      if (deltaX > 0) {
        onSwipeRight?.();
      } else {
        onSwipeLeft?.();
      }
    }
  };

  return {
    onTouchStart: handleTouchStart,
    onTouchEnd: handleTouchEnd
  };
};

// ë©”ì‹œì§€ ìŠ¤ì™€ì´í”„ ì•¡ì…˜
const MessageSwipeActions: React.FC<MessageSwipeActionsProps> = ({
  message,
  onLike,
  onReply,
  onBookmark
}) => {
  const swipeHandlers = useSwipeGestures(
    () => onLike?.(message.id),      // ì™¼ìª½ ìŠ¤ì™€ì´í”„: ì¢‹ì•„ìš”
    () => onBookmark?.(message.id)   // ì˜¤ë¥¸ìª½ ìŠ¤ì™€ì´í”„: ë¶ë§ˆí¬
  );

  return (
    <div className="message-swipe-container" {...swipeHandlers}>
      <SwipeAction position="left" action="like">
        <HeartIcon />
      </SwipeAction>

      <MessageBubble message={message} />

      <SwipeAction position="right" action="bookmark">
        <BookmarkIcon />
      </SwipeAction>
    </div>
  );
};
```

### ê¸¸ê²Œ ëˆ„ë¥´ê¸° (Long Press)

```typescript
// ê¸¸ê²Œ ëˆ„ë¥´ê¸° í›…
const useLongPress = (
  onLongPress: () => void,
  delay: number = 500
) => {
  const timeoutRef = useRef<NodeJS.Timeout>();
  const isLongPress = useRef(false);

  const start = useCallback(() => {
    isLongPress.current = false;
    timeoutRef.current = setTimeout(() => {
      isLongPress.current = true;
      onLongPress();
    }, delay);
  }, [onLongPress, delay]);

  const clear = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
  }, []);

  const clickHandler = useCallback(() => {
    // ê¸¸ê²Œ ëˆ„ë¥¸ ê²½ìš° í´ë¦­ ì´ë²¤íŠ¸ ë¬´ì‹œ
    return !isLongPress.current;
  }, []);

  return {
    onMouseDown: start,
    onMouseUp: clear,
    onMouseLeave: clear,
    onTouchStart: start,
    onTouchEnd: clear,
    onClick: clickHandler
  };
};

// ë‹µë³€ ì•¡ì…˜ ë©”ë‰´
const AnswerActionMenu: React.FC<AnswerActionMenuProps> = ({
  answer,
  onAccept,
  onSave,
  onShare,
  onReport
}) => {
  const [showMenu, setShowMenu] = useState(false);

  const longPressHandlers = useLongPress(() => {
    setShowMenu(true);
  });

  return (
    <>
      <div className="answer-bubble" {...longPressHandlers}>
        {/* ë‹µë³€ ë‚´ìš© */}
      </div>

      {showMenu && (
        <ActionMenu
          onClose={() => setShowMenu(false)}
          actions={[
            {
              icon: 'âœ…',
              label: 'ì´ ë‹µë³€ì´ ë„ì›€ëì–´ìš”!',
              action: () => onAccept(answer.id),
              primary: true
            },
            {
              icon: 'ğŸ’¾',
              label: 'ë‚˜ì¤‘ì— ì°¸ê³ í•˜ê¸°',
              action: () => onSave(answer.id)
            },
            {
              icon: 'ğŸ“¤',
              label: 'ê³µìœ í•˜ê¸°',
              action: () => onShare(answer.id)
            },
            {
              icon: 'âš ï¸',
              label: 'ì‹ ê³ í•˜ê¸°',
              action: () => onReport(answer.id),
              destructive: true
            }
          ]}
        />
      )}
    </>
  );
};
```

### í„°ì¹˜ í”¼ë“œë°±

```css
/* í„°ì¹˜ í”¼ë“œë°± ì• ë‹ˆë©”ì´ì…˜ */
.touch-feedback {
  position: relative;
  overflow: hidden;
}

.touch-feedback::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.6s, height 0.6s;
}

.touch-feedback:active::before {
  width: 300px;
  height: 300px;
}

/* ë²„íŠ¼ í„°ì¹˜ ìŠ¤ì¼€ì¼ íš¨ê³¼ */
.touch-scale {
  transition: transform 0.1s ease-in-out;
}

.touch-scale:active {
  transform: scale(0.95);
}

/* í–…í‹± í”¼ë“œë°± í´ë˜ìŠ¤ */
.haptic-light { /* ê°€ë²¼ìš´ ì§„ë™ */ }
.haptic-medium { /* ì¤‘ê°„ ì§„ë™ */ }
.haptic-heavy { /* ê°•í•œ ì§„ë™ */ }
```

---

## ğŸ¤ ìŒì„± ë° ë©€í‹°ë¯¸ë””ì–´ ì…ë ¥

### ìŒì„± ì…ë ¥ ì¸í„°í˜ì´ìŠ¤

#### ìŒì„± ë…¹ìŒ ë²„íŠ¼

```typescript
// ìŒì„± ì…ë ¥ ì»´í¬ë„ŒíŠ¸
const VoiceInputButton: React.FC<VoiceInputProps> = ({
  onTranscript,
  onError,
  language = 'ko-KR'
}) => {
  const {
    isRecording,
    transcript,
    startRecording,
    stopRecording,
    clearTranscript
  } = useSpeechRecognition({
    onResult: onTranscript,
    onError,
    language
  });

  return (
    <div className="voice-input-container">
      <VoiceButton
        isRecording={isRecording}
        onPress={startRecording}
        onRelease={stopRecording}
      />

      {isRecording && (
        <VoiceRecordingIndicator />
      )}

      {transcript && (
        <VoiceTranscriptDisplay
          text={transcript}
          onEdit={(text) => onTranscript(text)}
          onClear={clearTranscript}
        />
      )}
    </div>
  );
};

const VoiceButton: React.FC<VoiceButtonProps> = ({
  isRecording,
  onPress,
  onRelease
}) => {
  const longPressHandlers = useLongPress(onPress, 100);

  return (
    <button
      className={`voice-button ${isRecording ? 'recording' : ''}`}
      {...longPressHandlers}
      onMouseUp={onRelease}
      onTouchEnd={onRelease}
    >
      <MicIcon className={isRecording ? 'recording' : ''} />
      {isRecording ? 'ë…¹ìŒ ì¤‘...' : 'ê¸¸ê²Œ ëˆŒëŸ¬ì„œ ìŒì„± ì…ë ¥'}
    </button>
  );
};
```

#### ìŒì„± ì‹œê°í™”

```css
/* ìŒì„± ë…¹ìŒ ì‹œê°í™” */
.voice-recording-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: 16px;
  background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
  border-radius: 20px;
  color: white;
}

.voice-wave {
  width: 3px;
  background: white;
  border-radius: 2px;
  animation: voice-wave 1s ease-in-out infinite alternate;
}

.voice-wave:nth-child(1) { height: 10px; animation-delay: 0.1s; }
.voice-wave:nth-child(2) { height: 20px; animation-delay: 0.2s; }
.voice-wave:nth-child(3) { height: 15px; animation-delay: 0.3s; }
.voice-wave:nth-child(4) { height: 25px; animation-delay: 0.4s; }
.voice-wave:nth-child(5) { height: 12px; animation-delay: 0.5s; }

@keyframes voice-wave {
  0% { height: 5px; }
  100% { height: 25px; }
}

.recording-timer {
  font-family: monospace;
  font-size: 18px;
  font-weight: bold;
  margin-left: 12px;
}
```

### ì´ë¯¸ì§€ ë° íŒŒì¼ ì—…ë¡œë“œ

```typescript
// ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë¯¸ì§€ ì—…ë¡œë“œ
const ImageUpload: React.FC<ImageUploadProps> = ({
  maxFiles = 5,
  maxSize = 5 * 1024 * 1024, // 5MB
  onUpload
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [files, setFiles] = useState<File[]>([]);

  const handleDragOver = (e: DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const handleDrop = (e: DragEvent) => {
    e.preventDefault();
    setIsDragging(false);

    const droppedFiles = Array.from(e.dataTransfer?.files || []);
    const imageFiles = droppedFiles.filter(file =>
      file.type.startsWith('image/')
    );

    if (imageFiles.length + files.length > maxFiles) {
      alert(`ìµœëŒ€ ${maxFiles}ê°œê¹Œì§€ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
      return;
    }

    setFiles(prev => [...prev, ...imageFiles].slice(0, maxFiles));
  };

  return (
    <div
      className={`image-upload ${isDragging ? 'dragging' : ''}`}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <ImagePreviewGrid files={files} onRemove={removeFile} />

      <UploadArea
        isDragging={isDragging}
        hasFiles={files.length > 0}
        onFileSelect={handleFileSelect}
      />
    </div>
  );
};

const ImagePreviewGrid = ({ files, onRemove }: Props) => (
  <div className="image-preview-grid">
    {files.map((file, index) => (
      <ImagePreview
        key={index}
        file={file}
        onRemove={() => onRemove(index)}
      />
    ))}
  </div>
);
```

---

## ğŸ·ï¸ í•´ì‹œíƒœê·¸ ì‹œìŠ¤í…œ ìƒí˜¸ì‘ìš©

### ì‹¤ì‹œê°„ í•´ì‹œíƒœê·¸ íŒŒì‹±

```typescript
// ì‹¤ì‹œê°„ í•´ì‹œíƒœê·¸ íŒŒì‹± ë° í•˜ì´ë¼ì´íŒ…
const HashtagInput: React.FC<HashtagInputProps> = ({
  value,
  onChange,
  placeholder
}) => {
  const [text, setText] = useState(value);
  const [cursorPosition, setCursorPosition] = useState(0);
  const [suggestions, setSuggestions] = useState<string[]>([]);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  const parseHashtags = (text: string) => {
    const hashtagRegex = /#[\wê°€-í£]+/g;
    return text.match(hashtagRegex) || [];
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);
    setCursorPosition(e.target.selectionStart);

    // ì‹¤ì‹œê°„ í•´ì‹œíƒœê·¸ ì¶”ì¶œ
    const hashtags = parseHashtags(newText);
    onChange(hashtags);

    // í˜„ì¬ ì»¤ì„œ ìœ„ì¹˜ì˜ í•´ì‹œíƒœê·¸ ê²€ì‚¬
    const currentWord = getCurrentWord(newText, e.target.selectionStart);
    if (currentWord.startsWith('#')) {
      fetchHashtagSuggestions(currentWord).then(setSuggestions);
    } else {
      setSuggestions([]);
    }
  };

  const renderHighlightedText = () => {
    return text.replace(/#[\wê°€-í£]+/g, (match) =>
      `<span class="hashtag-highlight">${match}</span>`
    );
  };

  return (
    <div className="hashtag-input-container">
      {/* ë³´ì´ì§€ ì•ŠëŠ” í•˜ì´ë¼ì´íŠ¸ ë ˆì´ì–´ */}
      <div
        className="highlight-layer"
        dangerouslySetInnerHTML={{ __html: renderHighlightedText() }}
      />

      {/* ì‹¤ì œ ì…ë ¥ í•„ë“œ */}
      <textarea
        ref={inputRef}
        value={text}
        onChange={handleInputChange}
        placeholder={placeholder}
        className="hashtag-input"
      />

      {/* í•´ì‹œíƒœê·¸ ì œì•ˆ */}
      {suggestions.length > 0 && (
        <HashtagSuggestions
          suggestions={suggestions}
          onSelect={insertSuggestion}
        />
      )}
    </div>
  );
};
```

### í•´ì‹œíƒœê·¸ ìë™ ì™„ì„±

```typescript
// í•´ì‹œíƒœê·¸ ìë™ ì™„ì„± ì‹œìŠ¤í…œ
const HashtagAutocomplete: React.FC<AutocompleteProps> = ({
  query,
  onSelect,
  maxSuggestions = 5
}) => {
  const [suggestions, setSuggestions] = useState<HashtagSuggestion[]>([]);
  const [selectedIndex, setSelectedIndex] = useState(0);

  useEffect(() => {
    if (query.length < 2) {
      setSuggestions([]);
      return;
    }

    const fetchSuggestions = async () => {
      try {
        const response = await api.get('/hashtags/suggest', {
          params: { query, limit: maxSuggestions }
        });
        setSuggestions(response.data);
      } catch (error) {
        console.error('Failed to fetch hashtag suggestions:', error);
      }
    };

    const debounced = debounce(fetchSuggestions, 200);
    debounced();
  }, [query, maxSuggestions]);

  const handleKeyDown = (e: KeyboardEvent) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev =>
          Math.min(prev + 1, suggestions.length - 1)
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => Math.max(prev - 1, 0));
        break;
      case 'Enter':
      case 'Tab':
        e.preventDefault();
        if (suggestions[selectedIndex]) {
          onSelect(suggestions[selectedIndex].text);
        }
        break;
      case 'Escape':
        setSuggestions([]);
        break;
    }
  };

  return (
    <div className="hashtag-autocomplete" onKeyDown={handleKeyDown}>
      {suggestions.map((suggestion, index) => (
        <HashtagSuggestionItem
          key={suggestion.id}
          suggestion={suggestion}
          isSelected={index === selectedIndex}
          onClick={() => onSelect(suggestion.text)}
        />
      ))}
    </div>
  );
};

const HashtagSuggestionItem = ({ suggestion, isSelected, onClick }: Props) => (
  <div
    className={`hashtag-suggestion ${isSelected ? 'selected' : ''}`}
    onClick={onClick}
  >
    <span className="hashtag-text">{suggestion.text}</span>
    <span className="hashtag-category">{suggestion.category}</span>
    <span className="hashtag-count">{suggestion.usageCount}íšŒ ì‚¬ìš©</span>
  </div>
);
```

### ì¸ê¸° í•´ì‹œíƒœê·¸ ìœ„ì ¯

```typescript
// íŠ¸ë Œë”© í•´ì‹œíƒœê·¸ ìœ„ì ¯
const TrendingHashtags: React.FC = () => {
  const [trendingTags, setTrendingTags] = useState<TrendingTag[]>([]);
  const [timeRange, setTimeRange] = useState<'1h' | '24h' | '7d'>('24h');

  useEffect(() => {
    fetchTrendingHashtags(timeRange).then(setTrendingTags);
  }, [timeRange]);

  return (
    <div className="trending-hashtags">
      <div className="trending-header">
        <h3>ğŸ”¥ ì§€ê¸ˆ ëœ¨ëŠ” íƒœê·¸</h3>
        <TimeRangeSelector value={timeRange} onChange={setTimeRange} />
      </div>

      <div className="trending-cloud">
        {trendingTags.map((tag, index) => (
          <TrendingHashtagChip
            key={tag.text}
            tag={tag}
            rank={index + 1}
            size={calculateTagSize(tag.score, index)}
          />
        ))}
      </div>
    </div>
  );
};

const TrendingHashtagChip = ({ tag, rank, size }: Props) => (
  <span
    className={`trending-tag ${size}`}
    style={{
      fontSize: `${0.8 + (tag.score / 100)}rem`,
      opacity: Math.max(0.6, 1 - (rank * 0.1))
    }}
  >
    {tag.text}
    <span className="trend-indicator">
      {tag.trend > 0 ? 'ğŸ“ˆ' : tag.trend < 0 ? 'ğŸ“‰' : 'â¡ï¸'}
    </span>
  </span>
);
```

---

## ğŸ¨ ì• ë‹ˆë©”ì´ì…˜ ë° í”¼ë“œë°±

### ë©”ì‹œì§€ ì „ì†¡ ì• ë‹ˆë©”ì´ì…˜

```css
/* ë©”ì‹œì§€ ì „ì†¡ ì• ë‹ˆë©”ì´ì…˜ */
@keyframes message-send {
  0% {
    transform: translateY(20px);
    opacity: 0;
    scale: 0.9;
  }
  50% {
    transform: translateY(-5px);
    scale: 1.02;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
    scale: 1;
  }
}

.message-bubble.sending {
  animation: message-send 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* ë‹µë³€ ìˆ˜ì‹  ì• ë‹ˆë©”ì´ì…˜ */
@keyframes message-receive {
  0% {
    transform: translateX(-30px);
    opacity: 0;
  }
  100% {
    transform: translateX(0);
    opacity: 1;
  }
}

.message-bubble.receiving {
  animation: message-receive 0.3s ease-out;
}

/* ì¢‹ì•„ìš” ì• ë‹ˆë©”ì´ì…˜ */
@keyframes like-animation {
  0% {
    transform: scale(1);
  }
  15% {
    transform: scale(1.3);
  }
  30% {
    transform: scale(0.9);
  }
  45% {
    transform: scale(1.1);
  }
  60% {
    transform: scale(0.95);
  }
  100% {
    transform: scale(1);
  }
}

.like-button.liked {
  animation: like-animation 0.6s ease-in-out;
  color: #ff6b6b;
}
```

### ë¡œë”© ìƒíƒœ ì• ë‹ˆë©”ì´ì…˜

```typescript
// ìŠ¤ì¼ˆë ˆí†¤ ë¡œë”© ì»´í¬ë„ŒíŠ¸
const MessageSkeleton: React.FC = () => (
  <div className="message-skeleton">
    <div className="skeleton-avatar" />
    <div className="skeleton-content">
      <div className="skeleton-line long" />
      <div className="skeleton-line medium" />
      <div className="skeleton-line short" />
    </div>
  </div>
);

// í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜
const PulseLoader: React.FC<{ size?: 'small' | 'medium' | 'large' }> = ({
  size = 'medium'
}) => (
  <div className={`pulse-loader ${size}`}>
    <div className="pulse-dot" />
    <div className="pulse-dot" />
    <div className="pulse-dot" />
  </div>
);
```

### ì„±ê³µ/ì˜¤ë¥˜ í”¼ë“œë°±

```typescript
// í† ìŠ¤íŠ¸ ì•Œë¦¼ ì‹œìŠ¤í…œ
const useToast = () => {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const showToast = useCallback((message: string, type: ToastType = 'info') => {
    const id = Date.now().toString();
    const toast: Toast = { id, message, type };

    setToasts(prev => [...prev, toast]);

    // 3ì´ˆ í›„ ìë™ ì œê±°
    setTimeout(() => {
      setToasts(prev => prev.filter(t => t.id !== id));
    }, 3000);
  }, []);

  return { toasts, showToast };
};

const ToastContainer: React.FC<{ toasts: Toast[] }> = ({ toasts }) => (
  <div className="toast-container">
    {toasts.map(toast => (
      <ToastMessage
        key={toast.id}
        toast={toast}
        onClose={() => removeToast(toast.id)}
      />
    ))}
  </div>
);

const ToastMessage: React.FC<{ toast: Toast }> = ({ toast, onClose }) => (
  <div className={`toast toast-${toast.type}`}>
    <ToastIcon type={toast.type} />
    <span className="toast-message">{toast.message}</span>
    <button className="toast-close" onClick={onClose}>Ã—</button>
  </div>
);
```

---

## â™¿ ì ‘ê·¼ì„± ë° ì‚¬ìš©ì„±

### í‚¤ë³´ë“œ ë‚´ë¹„ê²Œì´ì…˜

```typescript
// í‚¤ë³´ë“œ ë‚´ë¹„ê²Œì´ì…˜ í›…
const useKeyboardNavigation = (items: string[], onSelect: (id: string) => void) => {
  const [selectedIndex, setSelectedIndex] = useState(0);

  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => (prev + 1) % items.length);
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => (prev - 1 + items.length) % items.length);
        break;
      case 'Enter':
        e.preventDefault();
        onSelect(items[selectedIndex]);
        break;
      case 'Escape':
        setSelectedIndex(0);
        break;
    }
  }, [items, selectedIndex, onSelect]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);

  return selectedIndex;
};
```

### ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›

```typescript
// ARIA ë ˆì´ë¸” ë° ì„¤ëª…
const MessageBubble: React.FC<MessageBubbleProps> = ({ message, type }) => (
  <div
    className={`message-bubble ${type}`}
    role="article"
    aria-label={`${message.user.nickname}ë‹˜ì˜ ${type === 'question' ? 'ì§ˆë¬¸' : 'ë‹µë³€'}`}
    aria-describedby={`message-${message.id}-content`}
  >
    <div
      id={`message-${message.id}-content`}
      className="message-content"
    >
      {message.content}
    </div>

    <div
      className="message-meta"
      aria-label={`${formatTimeAgo(message.timestamp)}ì— ì‘ì„±ë¨`}
    >
      <time dateTime={message.timestamp.toISOString()}>
        {formatTimeAgo(message.timestamp)}
      </time>
    </div>
  </div>
);

// ë¼ì´ë¸Œ ë¦¬ì „ (ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì•Œë¦¼)
const LiveRegion: React.FC<{ announcements: string[] }> = ({ announcements }) => (
  <div
    aria-live="polite"
    aria-atomic="true"
    className="sr-only"
  >
    {announcements.map((announcement, index) => (
      <div key={index}>{announcement}</div>
    ))}
  </div>
);
```

### ê³ ëŒ€ë¹„ ëª¨ë“œ ë° ë‹¤í¬ í…Œë§ˆ

```css
/* ê³ ëŒ€ë¹„ ëª¨ë“œ */
@media (prefers-contrast: high) {
  .message-bubble {
    border: 2px solid currentColor;
  }

  .hashtag {
    border: 1px solid currentColor;
    background: transparent;
  }
}

/* ë‹¤í¬ í…Œë§ˆ */
@media (prefers-color-scheme: dark) {
  .message-bubble.answer {
    background: #2a2a2a;
    color: #ffffff;
    border-color: #404040;
  }

  .message-bubble.question {
    background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
  }

  .typing-indicator {
    background: #4a5568;
  }
}

/* í°íŠ¸ í¬ê¸° ë°˜ì‘í˜• (ì‚¬ìš©ì ì„¤ì • ë°˜ì˜) */
.message-content {
  font-size: 1rem; /* ê¸°ë³¸ê°’ */
}

@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
```

---

ì´ ëª…ì„¸ì„œëŠ” ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ ì¸í„°í˜ì´ìŠ¤ì˜ ëª¨ë“  ìƒí˜¸ì‘ìš© íŒ¨í„´ì„ ìƒì„¸í•˜ê²Œ ì •ì˜í•˜ì—¬, ê°œë°œíŒ€ì´ ì¼ê´€ë˜ê³  ì§ê´€ì ì¸ ì‚¬ìš©ì ê²½í—˜ì„ êµ¬í˜„í•  ìˆ˜ ìˆë„ë¡ ì•ˆë‚´í•©ë‹ˆë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ê¸°ìˆ  ë¬¸ì„œë¥¼ ì‘ì„±í•˜ê² ìŠµë‹ˆë‹¤.