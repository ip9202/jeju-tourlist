# "동네물어봐" 메시지 스타일 인터페이스 상호작용 명세서

## 📋 목차
1. [메시지 UI 디자인 시스템](#-메시지-ui-디자인-시스템)
2. [실시간 상호작용 패턴](#-실시간-상호작용-패턴)
3. [터치 및 제스처 인터페이스](#-터치-및-제스처-인터페이스)
4. [음성 및 멀티미디어 입력](#-음성-및-멀티미디어-입력)
5. [해시태그 시스템 상호작용](#-해시태그-시스템-상호작용)
6. [애니메이션 및 피드백](#-애니메이션-및-피드백)
7. [접근성 및 사용성](#-접근성-및-사용성)

---

## 💬 메시지 UI 디자인 시스템

### 기본 디자인 원칙
- **친숙함**: 카카오톡, 인스타그램 DM과 유사한 인터페이스
- **명확성**: 질문과 답변의 시각적 구분
- **효율성**: 최소한의 탭으로 목적 달성
- **일관성**: 플랫폼 간 동일한 상호작용 패턴

### 메시지 버블 디자인 명세

#### 질문 메시지 (오른쪽 정렬)

```css
/* 질문 메시지 스타일 */
.message-bubble.question {
  margin-left: 60px;
  margin-right: 16px;
  margin-bottom: 16px;
  align-self: flex-end;
}

.question-bubble {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 20px 20px 6px 20px;
  padding: 12px 16px;
  max-width: 70%;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
  position: relative;
}

.question-bubble::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: -6px;
  width: 0;
  height: 0;
  border: 6px solid transparent;
  border-top-color: #764ba2;
}

/* 질문 내용 */
.question-content {
  font-size: 16px;
  line-height: 1.4;
  margin-bottom: 8px;
}

/* 해시태그 스타일 */
.question-hashtags {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 8px;
}

.hashtag {
  background: rgba(255, 255, 255, 0.2);
  color: white;
  font-size: 12px;
  padding: 2px 6px;
  border-radius: 10px;
  font-weight: 500;
}
```

#### 답변 메시지 (왼쪽 정렬)

```css
/* 답변 메시지 스타일 */
.message-bubble.answer {
  margin-left: 16px;
  margin-right: 60px;
  margin-bottom: 16px;
  align-self: flex-start;
}

.answer-bubble {
  background: #ffffff;
  color: #333333;
  border: 1px solid #e0e0e0;
  border-radius: 20px 20px 20px 6px;
  padding: 12px 16px;
  max-width: 70%;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  position: relative;
}

.answer-bubble::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: -6px;
  width: 0;
  height: 0;
  border: 6px solid transparent;
  border-top-color: #ffffff;
}

/* 현지인 배지가 있는 답변 */
.answer-bubble.local-verified {
  border-color: #ff9500;
  box-shadow: 0 2px 8px rgba(255, 149, 0, 0.2);
}

.answer-bubble.local-verified::before {
  content: '🏠';
  position: absolute;
  top: -8px;
  left: 12px;
  background: #ff9500;
  color: white;
  font-size: 12px;
  padding: 2px 6px;
  border-radius: 10px;
}
```

### 메시지 메타 정보

```typescript
// 메시지 메타 정보 컴포넌트
interface MessageMetaProps {
  user: User;
  timestamp: Date;
  status?: 'sending' | 'sent' | 'delivered' | 'read';
  location?: Location;
  urgency?: 'normal' | 'high' | 'urgent';
}

const MessageMeta: React.FC<MessageMetaProps> = ({
  user,
  timestamp,
  status,
  location,
  urgency
}) => {
  return (
    <div className="message-meta">
      <UserProfile user={user} size="small" />
      <MessageInfo>
        <span className="username">{user.nickname}</span>
        {user.isLocalVerified && <VerificationBadge />}
        <span className="timestamp">{formatTimeAgo(timestamp)}</span>
        {location && <LocationTag location={location} />}
        {urgency && urgency !== 'normal' && (
          <UrgencyIndicator level={urgency} />
        )}
      </MessageInfo>
      {status && <MessageStatus status={status} />}
    </div>
  );
};
```

---

## ⚡ 실시간 상호작용 패턴

### 타이핑 인디케이터

#### 시각적 디자인

```css
/* 타이핑 인디케이터 */
.typing-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  margin: 8px 16px 8px 16px;
  background: #f5f5f5;
  border-radius: 20px;
  animation: fadeIn 0.3s ease-in-out;
}

.typing-avatar {
  width: 24px;
  height: 24px;
  border-radius: 12px;
  border: 2px solid #ffffff;
}

.typing-text {
  font-size: 14px;
  color: #666666;
  margin-right: 8px;
}

.typing-dots {
  display: flex;
  gap: 3px;
}

.typing-dot {
  width: 4px;
  height: 4px;
  background: #999999;
  border-radius: 50%;
  animation: typing 1.4s infinite ease-in-out;
}

.typing-dot:nth-child(1) { animation-delay: -0.32s; }
.typing-dot:nth-child(2) { animation-delay: -0.16s; }
.typing-dot:nth-child(3) { animation-delay: 0s; }

@keyframes typing {
  0%, 80%, 100% {
    transform: scale(0.8);
    opacity: 0.5;
  }
  40% {
    transform: scale(1);
    opacity: 1;
  }
}
```

#### 타이핑 상태 관리

```typescript
// 타이핑 상태 관리 훅
const useTypingIndicator = (questionId: string) => {
  const [typingUsers, setTypingUsers] = useState<TypingUser[]>([]);
  const { socket } = useSocket();
  const typingTimeoutRef = useRef<NodeJS.Timeout>();

  const startTyping = useCallback(() => {
    socket?.emit('typing_start', { questionId });

    // 3초 후 자동으로 타이핑 중지
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    typingTimeoutRef.current = setTimeout(() => {
      socket?.emit('typing_stop', { questionId });
    }, 3000);
  }, [socket, questionId]);

  const stopTyping = useCallback(() => {
    socket?.emit('typing_stop', { questionId });
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
  }, [socket, questionId]);

  useEffect(() => {
    socket?.on('user_typing', (data) => {
      if (data.questionId === questionId) {
        setTypingUsers(prev => [
          ...prev.filter(u => u.userId !== data.userId),
          data
        ]);
      }
    });

    socket?.on('user_stop_typing', (data) => {
      if (data.questionId === questionId) {
        setTypingUsers(prev =>
          prev.filter(u => u.userId !== data.userId)
        );
      }
    });

    return () => {
      socket?.off('user_typing');
      socket?.off('user_stop_typing');
    };
  }, [socket, questionId]);

  return { typingUsers, startTyping, stopTyping };
};
```

### 실시간 메시지 수신

```typescript
// 실시간 메시지 수신 처리
const useRealTimeMessages = (questionId: string) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const { socket } = useSocket();
  const audioRef = useRef<HTMLAudioElement>();

  useEffect(() => {
    // 새 답변 수신
    socket?.on('new_answer', (answer: Answer) => {
      if (answer.questionId === questionId) {
        setMessages(prev => [...prev, answer]);

        // 알림음 재생 (사용자 설정에 따라)
        if (audioRef.current && isNotificationEnabled()) {
          audioRef.current.play();
        }

        // 시스템 알림 표시
        showNotification('새 답변이 도착했습니다!', {
          body: answer.content.substring(0, 100),
          icon: answer.user.profileImage
        });
      }
    });

    // 답변 채택 실시간 업데이트
    socket?.on('answer_accepted', (data) => {
      if (data.questionId === questionId) {
        setMessages(prev =>
          prev.map(msg =>
            msg.id === data.answerId
              ? { ...msg, isAccepted: true }
              : msg
          )
        );
      }
    });

    return () => {
      socket?.off('new_answer');
      socket?.off('answer_accepted');
    };
  }, [socket, questionId]);

  return messages;
};
```

### 읽음 상태 표시

```typescript
// 읽음 상태 컴포넌트
const ReadStatus: React.FC<{ status: MessageStatus }> = ({ status }) => {
  const getStatusIcon = () => {
    switch (status) {
      case 'sending':
        return <SpinnerIcon className="animate-spin" />;
      case 'sent':
        return <CheckIcon className="text-gray-400" />;
      case 'delivered':
        return <DoubleCheckIcon className="text-gray-400" />;
      case 'read':
        return <DoubleCheckIcon className="text-blue-500" />;
      default:
        return null;
    }
  };

  return (
    <div className="read-status">
      {getStatusIcon()}
    </div>
  );
};

// 읽음 상태 추적
const useReadStatus = (messageId: string) => {
  const [status, setStatus] = useState<MessageStatus>('sending');
  const { socket } = useSocket();

  useEffect(() => {
    // 메시지 전송 완료
    socket?.on('message_sent', (data) => {
      if (data.messageId === messageId) {
        setStatus('sent');
      }
    });

    // 메시지 읽음 확인
    socket?.on('message_read', (data) => {
      if (data.messageId === messageId) {
        setStatus('read');
      }
    });

    return () => {
      socket?.off('message_sent');
      socket?.off('message_read');
    };
  }, [socket, messageId]);

  return status;
};
```

---

## 👆 터치 및 제스처 인터페이스

### 스와이프 제스처

#### 스와이프 액션 정의

```typescript
// 스와이프 제스처 훅
const useSwipeGestures = (
  onSwipeLeft?: () => void,
  onSwipeRight?: () => void,
  threshold: number = 50
) => {
  const [startX, setStartX] = useState(0);
  const [startY, setStartY] = useState(0);

  const handleTouchStart = (e: TouchEvent) => {
    setStartX(e.touches[0].clientX);
    setStartY(e.touches[0].clientY);
  };

  const handleTouchEnd = (e: TouchEvent) => {
    const endX = e.changedTouches[0].clientX;
    const endY = e.changedTouches[0].clientY;
    const deltaX = endX - startX;
    const deltaY = endY - startY;

    // 수직 스크롤이 우선인 경우 제스처 무시
    if (Math.abs(deltaY) > Math.abs(deltaX)) return;

    if (Math.abs(deltaX) > threshold) {
      if (deltaX > 0) {
        onSwipeRight?.();
      } else {
        onSwipeLeft?.();
      }
    }
  };

  return {
    onTouchStart: handleTouchStart,
    onTouchEnd: handleTouchEnd
  };
};

// 메시지 스와이프 액션
const MessageSwipeActions: React.FC<MessageSwipeActionsProps> = ({
  message,
  onLike,
  onReply,
  onBookmark
}) => {
  const swipeHandlers = useSwipeGestures(
    () => onLike?.(message.id),      // 왼쪽 스와이프: 좋아요
    () => onBookmark?.(message.id)   // 오른쪽 스와이프: 북마크
  );

  return (
    <div className="message-swipe-container" {...swipeHandlers}>
      <SwipeAction position="left" action="like">
        <HeartIcon />
      </SwipeAction>

      <MessageBubble message={message} />

      <SwipeAction position="right" action="bookmark">
        <BookmarkIcon />
      </SwipeAction>
    </div>
  );
};
```

### 길게 누르기 (Long Press)

```typescript
// 길게 누르기 훅
const useLongPress = (
  onLongPress: () => void,
  delay: number = 500
) => {
  const timeoutRef = useRef<NodeJS.Timeout>();
  const isLongPress = useRef(false);

  const start = useCallback(() => {
    isLongPress.current = false;
    timeoutRef.current = setTimeout(() => {
      isLongPress.current = true;
      onLongPress();
    }, delay);
  }, [onLongPress, delay]);

  const clear = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
  }, []);

  const clickHandler = useCallback(() => {
    // 길게 누른 경우 클릭 이벤트 무시
    return !isLongPress.current;
  }, []);

  return {
    onMouseDown: start,
    onMouseUp: clear,
    onMouseLeave: clear,
    onTouchStart: start,
    onTouchEnd: clear,
    onClick: clickHandler
  };
};

// 답변 액션 메뉴
const AnswerActionMenu: React.FC<AnswerActionMenuProps> = ({
  answer,
  onAccept,
  onSave,
  onShare,
  onReport
}) => {
  const [showMenu, setShowMenu] = useState(false);

  const longPressHandlers = useLongPress(() => {
    setShowMenu(true);
  });

  return (
    <>
      <div className="answer-bubble" {...longPressHandlers}>
        {/* 답변 내용 */}
      </div>

      {showMenu && (
        <ActionMenu
          onClose={() => setShowMenu(false)}
          actions={[
            {
              icon: '✅',
              label: '이 답변이 도움됐어요!',
              action: () => onAccept(answer.id),
              primary: true
            },
            {
              icon: '💾',
              label: '나중에 참고하기',
              action: () => onSave(answer.id)
            },
            {
              icon: '📤',
              label: '공유하기',
              action: () => onShare(answer.id)
            },
            {
              icon: '⚠️',
              label: '신고하기',
              action: () => onReport(answer.id),
              destructive: true
            }
          ]}
        />
      )}
    </>
  );
};
```

### 터치 피드백

```css
/* 터치 피드백 애니메이션 */
.touch-feedback {
  position: relative;
  overflow: hidden;
}

.touch-feedback::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.6s, height 0.6s;
}

.touch-feedback:active::before {
  width: 300px;
  height: 300px;
}

/* 버튼 터치 스케일 효과 */
.touch-scale {
  transition: transform 0.1s ease-in-out;
}

.touch-scale:active {
  transform: scale(0.95);
}

/* 햅틱 피드백 클래스 */
.haptic-light { /* 가벼운 진동 */ }
.haptic-medium { /* 중간 진동 */ }
.haptic-heavy { /* 강한 진동 */ }
```

---

## 🎤 음성 및 멀티미디어 입력

### 음성 입력 인터페이스

#### 음성 녹음 버튼

```typescript
// 음성 입력 컴포넌트
const VoiceInputButton: React.FC<VoiceInputProps> = ({
  onTranscript,
  onError,
  language = 'ko-KR'
}) => {
  const {
    isRecording,
    transcript,
    startRecording,
    stopRecording,
    clearTranscript
  } = useSpeechRecognition({
    onResult: onTranscript,
    onError,
    language
  });

  return (
    <div className="voice-input-container">
      <VoiceButton
        isRecording={isRecording}
        onPress={startRecording}
        onRelease={stopRecording}
      />

      {isRecording && (
        <VoiceRecordingIndicator />
      )}

      {transcript && (
        <VoiceTranscriptDisplay
          text={transcript}
          onEdit={(text) => onTranscript(text)}
          onClear={clearTranscript}
        />
      )}
    </div>
  );
};

const VoiceButton: React.FC<VoiceButtonProps> = ({
  isRecording,
  onPress,
  onRelease
}) => {
  const longPressHandlers = useLongPress(onPress, 100);

  return (
    <button
      className={`voice-button ${isRecording ? 'recording' : ''}`}
      {...longPressHandlers}
      onMouseUp={onRelease}
      onTouchEnd={onRelease}
    >
      <MicIcon className={isRecording ? 'recording' : ''} />
      {isRecording ? '녹음 중...' : '길게 눌러서 음성 입력'}
    </button>
  );
};
```

#### 음성 시각화

```css
/* 음성 녹음 시각화 */
.voice-recording-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: 16px;
  background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
  border-radius: 20px;
  color: white;
}

.voice-wave {
  width: 3px;
  background: white;
  border-radius: 2px;
  animation: voice-wave 1s ease-in-out infinite alternate;
}

.voice-wave:nth-child(1) { height: 10px; animation-delay: 0.1s; }
.voice-wave:nth-child(2) { height: 20px; animation-delay: 0.2s; }
.voice-wave:nth-child(3) { height: 15px; animation-delay: 0.3s; }
.voice-wave:nth-child(4) { height: 25px; animation-delay: 0.4s; }
.voice-wave:nth-child(5) { height: 12px; animation-delay: 0.5s; }

@keyframes voice-wave {
  0% { height: 5px; }
  100% { height: 25px; }
}

.recording-timer {
  font-family: monospace;
  font-size: 18px;
  font-weight: bold;
  margin-left: 12px;
}
```

### 이미지 및 파일 업로드

```typescript
// 드래그 앤 드롭 이미지 업로드
const ImageUpload: React.FC<ImageUploadProps> = ({
  maxFiles = 5,
  maxSize = 5 * 1024 * 1024, // 5MB
  onUpload
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [files, setFiles] = useState<File[]>([]);

  const handleDragOver = (e: DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const handleDrop = (e: DragEvent) => {
    e.preventDefault();
    setIsDragging(false);

    const droppedFiles = Array.from(e.dataTransfer?.files || []);
    const imageFiles = droppedFiles.filter(file =>
      file.type.startsWith('image/')
    );

    if (imageFiles.length + files.length > maxFiles) {
      alert(`최대 ${maxFiles}개까지 업로드 가능합니다.`);
      return;
    }

    setFiles(prev => [...prev, ...imageFiles].slice(0, maxFiles));
  };

  return (
    <div
      className={`image-upload ${isDragging ? 'dragging' : ''}`}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <ImagePreviewGrid files={files} onRemove={removeFile} />

      <UploadArea
        isDragging={isDragging}
        hasFiles={files.length > 0}
        onFileSelect={handleFileSelect}
      />
    </div>
  );
};

const ImagePreviewGrid = ({ files, onRemove }: Props) => (
  <div className="image-preview-grid">
    {files.map((file, index) => (
      <ImagePreview
        key={index}
        file={file}
        onRemove={() => onRemove(index)}
      />
    ))}
  </div>
);
```

---

## 🏷️ 해시태그 시스템 상호작용

### 실시간 해시태그 파싱

```typescript
// 실시간 해시태그 파싱 및 하이라이팅
const HashtagInput: React.FC<HashtagInputProps> = ({
  value,
  onChange,
  placeholder
}) => {
  const [text, setText] = useState(value);
  const [cursorPosition, setCursorPosition] = useState(0);
  const [suggestions, setSuggestions] = useState<string[]>([]);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  const parseHashtags = (text: string) => {
    const hashtagRegex = /#[\w가-힣]+/g;
    return text.match(hashtagRegex) || [];
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newText = e.target.value;
    setText(newText);
    setCursorPosition(e.target.selectionStart);

    // 실시간 해시태그 추출
    const hashtags = parseHashtags(newText);
    onChange(hashtags);

    // 현재 커서 위치의 해시태그 검사
    const currentWord = getCurrentWord(newText, e.target.selectionStart);
    if (currentWord.startsWith('#')) {
      fetchHashtagSuggestions(currentWord).then(setSuggestions);
    } else {
      setSuggestions([]);
    }
  };

  const renderHighlightedText = () => {
    return text.replace(/#[\w가-힣]+/g, (match) =>
      `<span class="hashtag-highlight">${match}</span>`
    );
  };

  return (
    <div className="hashtag-input-container">
      {/* 보이지 않는 하이라이트 레이어 */}
      <div
        className="highlight-layer"
        dangerouslySetInnerHTML={{ __html: renderHighlightedText() }}
      />

      {/* 실제 입력 필드 */}
      <textarea
        ref={inputRef}
        value={text}
        onChange={handleInputChange}
        placeholder={placeholder}
        className="hashtag-input"
      />

      {/* 해시태그 제안 */}
      {suggestions.length > 0 && (
        <HashtagSuggestions
          suggestions={suggestions}
          onSelect={insertSuggestion}
        />
      )}
    </div>
  );
};
```

### 해시태그 자동 완성

```typescript
// 해시태그 자동 완성 시스템
const HashtagAutocomplete: React.FC<AutocompleteProps> = ({
  query,
  onSelect,
  maxSuggestions = 5
}) => {
  const [suggestions, setSuggestions] = useState<HashtagSuggestion[]>([]);
  const [selectedIndex, setSelectedIndex] = useState(0);

  useEffect(() => {
    if (query.length < 2) {
      setSuggestions([]);
      return;
    }

    const fetchSuggestions = async () => {
      try {
        const response = await api.get('/hashtags/suggest', {
          params: { query, limit: maxSuggestions }
        });
        setSuggestions(response.data);
      } catch (error) {
        console.error('Failed to fetch hashtag suggestions:', error);
      }
    };

    const debounced = debounce(fetchSuggestions, 200);
    debounced();
  }, [query, maxSuggestions]);

  const handleKeyDown = (e: KeyboardEvent) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev =>
          Math.min(prev + 1, suggestions.length - 1)
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => Math.max(prev - 1, 0));
        break;
      case 'Enter':
      case 'Tab':
        e.preventDefault();
        if (suggestions[selectedIndex]) {
          onSelect(suggestions[selectedIndex].text);
        }
        break;
      case 'Escape':
        setSuggestions([]);
        break;
    }
  };

  return (
    <div className="hashtag-autocomplete" onKeyDown={handleKeyDown}>
      {suggestions.map((suggestion, index) => (
        <HashtagSuggestionItem
          key={suggestion.id}
          suggestion={suggestion}
          isSelected={index === selectedIndex}
          onClick={() => onSelect(suggestion.text)}
        />
      ))}
    </div>
  );
};

const HashtagSuggestionItem = ({ suggestion, isSelected, onClick }: Props) => (
  <div
    className={`hashtag-suggestion ${isSelected ? 'selected' : ''}`}
    onClick={onClick}
  >
    <span className="hashtag-text">{suggestion.text}</span>
    <span className="hashtag-category">{suggestion.category}</span>
    <span className="hashtag-count">{suggestion.usageCount}회 사용</span>
  </div>
);
```

### 인기 해시태그 위젯

```typescript
// 트렌딩 해시태그 위젯
const TrendingHashtags: React.FC = () => {
  const [trendingTags, setTrendingTags] = useState<TrendingTag[]>([]);
  const [timeRange, setTimeRange] = useState<'1h' | '24h' | '7d'>('24h');

  useEffect(() => {
    fetchTrendingHashtags(timeRange).then(setTrendingTags);
  }, [timeRange]);

  return (
    <div className="trending-hashtags">
      <div className="trending-header">
        <h3>🔥 지금 뜨는 태그</h3>
        <TimeRangeSelector value={timeRange} onChange={setTimeRange} />
      </div>

      <div className="trending-cloud">
        {trendingTags.map((tag, index) => (
          <TrendingHashtagChip
            key={tag.text}
            tag={tag}
            rank={index + 1}
            size={calculateTagSize(tag.score, index)}
          />
        ))}
      </div>
    </div>
  );
};

const TrendingHashtagChip = ({ tag, rank, size }: Props) => (
  <span
    className={`trending-tag ${size}`}
    style={{
      fontSize: `${0.8 + (tag.score / 100)}rem`,
      opacity: Math.max(0.6, 1 - (rank * 0.1))
    }}
  >
    {tag.text}
    <span className="trend-indicator">
      {tag.trend > 0 ? '📈' : tag.trend < 0 ? '📉' : '➡️'}
    </span>
  </span>
);
```

---

## 🎨 애니메이션 및 피드백

### 메시지 전송 애니메이션

```css
/* 메시지 전송 애니메이션 */
@keyframes message-send {
  0% {
    transform: translateY(20px);
    opacity: 0;
    scale: 0.9;
  }
  50% {
    transform: translateY(-5px);
    scale: 1.02;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
    scale: 1;
  }
}

.message-bubble.sending {
  animation: message-send 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* 답변 수신 애니메이션 */
@keyframes message-receive {
  0% {
    transform: translateX(-30px);
    opacity: 0;
  }
  100% {
    transform: translateX(0);
    opacity: 1;
  }
}

.message-bubble.receiving {
  animation: message-receive 0.3s ease-out;
}

/* 좋아요 애니메이션 */
@keyframes like-animation {
  0% {
    transform: scale(1);
  }
  15% {
    transform: scale(1.3);
  }
  30% {
    transform: scale(0.9);
  }
  45% {
    transform: scale(1.1);
  }
  60% {
    transform: scale(0.95);
  }
  100% {
    transform: scale(1);
  }
}

.like-button.liked {
  animation: like-animation 0.6s ease-in-out;
  color: #ff6b6b;
}
```

### 로딩 상태 애니메이션

```typescript
// 스켈레톤 로딩 컴포넌트
const MessageSkeleton: React.FC = () => (
  <div className="message-skeleton">
    <div className="skeleton-avatar" />
    <div className="skeleton-content">
      <div className="skeleton-line long" />
      <div className="skeleton-line medium" />
      <div className="skeleton-line short" />
    </div>
  </div>
);

// 펄스 애니메이션
const PulseLoader: React.FC<{ size?: 'small' | 'medium' | 'large' }> = ({
  size = 'medium'
}) => (
  <div className={`pulse-loader ${size}`}>
    <div className="pulse-dot" />
    <div className="pulse-dot" />
    <div className="pulse-dot" />
  </div>
);
```

### 성공/오류 피드백

```typescript
// 토스트 알림 시스템
const useToast = () => {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const showToast = useCallback((message: string, type: ToastType = 'info') => {
    const id = Date.now().toString();
    const toast: Toast = { id, message, type };

    setToasts(prev => [...prev, toast]);

    // 3초 후 자동 제거
    setTimeout(() => {
      setToasts(prev => prev.filter(t => t.id !== id));
    }, 3000);
  }, []);

  return { toasts, showToast };
};

const ToastContainer: React.FC<{ toasts: Toast[] }> = ({ toasts }) => (
  <div className="toast-container">
    {toasts.map(toast => (
      <ToastMessage
        key={toast.id}
        toast={toast}
        onClose={() => removeToast(toast.id)}
      />
    ))}
  </div>
);

const ToastMessage: React.FC<{ toast: Toast }> = ({ toast, onClose }) => (
  <div className={`toast toast-${toast.type}`}>
    <ToastIcon type={toast.type} />
    <span className="toast-message">{toast.message}</span>
    <button className="toast-close" onClick={onClose}>×</button>
  </div>
);
```

---

## ♿ 접근성 및 사용성

### 키보드 내비게이션

```typescript
// 키보드 내비게이션 훅
const useKeyboardNavigation = (items: string[], onSelect: (id: string) => void) => {
  const [selectedIndex, setSelectedIndex] = useState(0);

  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => (prev + 1) % items.length);
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => (prev - 1 + items.length) % items.length);
        break;
      case 'Enter':
        e.preventDefault();
        onSelect(items[selectedIndex]);
        break;
      case 'Escape':
        setSelectedIndex(0);
        break;
    }
  }, [items, selectedIndex, onSelect]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);

  return selectedIndex;
};
```

### 스크린 리더 지원

```typescript
// ARIA 레이블 및 설명
const MessageBubble: React.FC<MessageBubbleProps> = ({ message, type }) => (
  <div
    className={`message-bubble ${type}`}
    role="article"
    aria-label={`${message.user.nickname}님의 ${type === 'question' ? '질문' : '답변'}`}
    aria-describedby={`message-${message.id}-content`}
  >
    <div
      id={`message-${message.id}-content`}
      className="message-content"
    >
      {message.content}
    </div>

    <div
      className="message-meta"
      aria-label={`${formatTimeAgo(message.timestamp)}에 작성됨`}
    >
      <time dateTime={message.timestamp.toISOString()}>
        {formatTimeAgo(message.timestamp)}
      </time>
    </div>
  </div>
);

// 라이브 리전 (실시간 업데이트 알림)
const LiveRegion: React.FC<{ announcements: string[] }> = ({ announcements }) => (
  <div
    aria-live="polite"
    aria-atomic="true"
    className="sr-only"
  >
    {announcements.map((announcement, index) => (
      <div key={index}>{announcement}</div>
    ))}
  </div>
);
```

### 고대비 모드 및 다크 테마

```css
/* 고대비 모드 */
@media (prefers-contrast: high) {
  .message-bubble {
    border: 2px solid currentColor;
  }

  .hashtag {
    border: 1px solid currentColor;
    background: transparent;
  }
}

/* 다크 테마 */
@media (prefers-color-scheme: dark) {
  .message-bubble.answer {
    background: #2a2a2a;
    color: #ffffff;
    border-color: #404040;
  }

  .message-bubble.question {
    background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
  }

  .typing-indicator {
    background: #4a5568;
  }
}

/* 폰트 크기 반응형 (사용자 설정 반영) */
.message-content {
  font-size: 1rem; /* 기본값 */
}

@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
```

---

이 명세서는 메시지 스타일 인터페이스의 모든 상호작용 패턴을 상세하게 정의하여, 개발팀이 일관되고 직관적인 사용자 경험을 구현할 수 있도록 안내합니다. 마지막으로 실시간 시스템 아키텍처 기술 문서를 작성하겠습니다.