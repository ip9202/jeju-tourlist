/**
 * ë°°ì§€ ì‹œìŠ¤í…œ ì„œë¹„ìŠ¤ (ê°œì„ ëœ ë²„ì „)
 *
 * @description
 * - ë°°ì§€ ê³„ì‚°, ë¶€ì—¬, ê´€ë¦¬ ë¡œì§
 * - SOLID ì›ì¹™ ì¤‘ SRP(ë‹¨ì¼ ì±…ì„ ì›ì¹™) ë° DIP(ì˜ì¡´ì„± ì—­ì „ ì›ì¹™) ì¤€ìˆ˜
 * - ë°°ì§€ ì¡°ê±´ ê²€ì¦ ë° ìë™ ë¶€ì—¬ ì‹œìŠ¤í…œ
 * - ë°°ì¹˜ ì²˜ë¦¬ ë° í†µê³„ ë¶„ì„
 *
 * @author ë™ë„¤ë¬¼ì–´ë´ ê°œë°œíŒ€
 * @version 2.0.0
 */

import { PrismaClient } from "@prisma/client";
import { IBadgeRepository } from "../repositories/badge.repository";
import { BadgeRepository } from "../repositories/badge.repository.impl";
import {
  BadgeCalculationResult,
  UserBadgeProgress,
  BadgeStats,
  BatchProcessResult,
  ExpertPointsResult,
} from "../types/badge";

/**
 * ë°°ì§€ ì‹œìŠ¤í…œ ì„œë¹„ìŠ¤
 */
export class BadgeService {
  private badgeRepository: IBadgeRepository;

  constructor(prisma: PrismaClient) {
    this.badgeRepository = new BadgeRepository(prisma);
  }

  /**
   * ì‚¬ìš©ì ë°°ì§€ ìê²© ê²€ì‚¬ ë° ìë™ ë¶€ì—¬
   *
   * @param userId - ì‚¬ìš©ì ID
   * @returns ë¶€ì—¬ëœ ë°°ì§€ ëª©ë¡
   */
  async checkAndAwardBadges(userId: string): Promise<BadgeCalculationResult[]> {
    console.log(`ğŸ” ì‚¬ìš©ì ${userId}ì˜ ë°°ì§€ ìê²© ê²€ì‚¬ ì‹œì‘...`);

    // ëª¨ë“  í™œì„± ë°°ì§€ ì¡°íšŒ
    const badges = await this.badgeRepository.findMany({ isActive: true });
    const earnedBadges: BadgeCalculationResult[] = [];

    for (const badge of badges) {
      try {
        // ì´ë¯¸ íšë“í•œ ë°°ì§€ì¸ì§€ í™•ì¸
        const existingUserBadge = await this.badgeRepository.getUserBadgeById(userId, badge.id);
        if (existingUserBadge?.earnedAt) {
          continue;
        }

        // ë°°ì§€ ìê²© ê²€ì¦
        const eligibility = await this.badgeRepository.checkBadgeEligibility(userId, badge.id);

        if (eligibility.isEligible) {
          // ë°°ì§€ ë¶€ì—¬
          await this.badgeRepository.awardBadge(userId, badge.id);

          earnedBadges.push({
            badgeId: badge.id,
            badgeCode: badge.code,
            badgeName: badge.name,
            isEarned: true,
            progress: eligibility.progress,
            maxProgress: eligibility.maxProgress,
            message: eligibility.message,
            points: badge.bonusPoints,
          });

          console.log(`âœ… ë°°ì§€ ë¶€ì—¬: ${badge.emoji} ${badge.name} (${badge.bonusPoints}í¬ì¸íŠ¸)`);
        }
      } catch (error) {
        console.error(`âŒ ë°°ì§€ ${badge.name} ê²€ì‚¬ ì¤‘ ì˜¤ë¥˜:`, error);
      }
    }

    console.log(`ğŸ‰ ì´ ${earnedBadges.length}ê°œì˜ ë°°ì§€ë¥¼ ë¶€ì—¬í–ˆìŠµë‹ˆë‹¤.`);
    return earnedBadges;
  }

  /**
   * ì‚¬ìš©ì ë°°ì§€ í†µê³„ ì¡°íšŒ
   *
   * @param userId - ì‚¬ìš©ì ID
   * @returns ë°°ì§€ í†µê³„ ì •ë³´
   */
  async getUserBadgeStats(userId: string): Promise<BadgeStats> {
    const stats = await this.badgeRepository.getBadgeStats(userId);
    return {
      ...stats,
      completionRate: stats.totalBadges > 0 ? (stats.earnedBadges / stats.totalBadges) * 100 : 0,
    };
  }

  /**
   * íŠ¹ì • ë°°ì§€ì˜ íšë“ ê°€ëŠ¥í•œ ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ
   *
   * @param badgeId - ë°°ì§€ ID
   * @returns íšë“ ê°€ëŠ¥í•œ ì‚¬ìš©ì ID ëª©ë¡
   */
  async getEligibleUsersForBadge(badgeId: string): Promise<string[]> {
    return await this.badgeRepository.findEligibleUsersForBadge(badgeId);
  }

  /**
   * ë°°ì¹˜ ì²˜ë¦¬: ëª¨ë“  ì‚¬ìš©ìì˜ ë°°ì§€ ìê²© ê²€ì‚¬
   *
   * @returns ì²˜ë¦¬ ê²°ê³¼ í†µê³„
   */
  async batchProcessAllUsers(): Promise<BatchProcessResult> {
    console.log("ğŸ”„ ë°°ì§€ ë°°ì¹˜ ì²˜ë¦¬ ì‹œì‘...");
    const startTime = Date.now();

    const activeUsers = await (this.badgeRepository as any).prisma.user.findMany({
      where: { isActive: true },
      select: { id: true, name: true },
    });

    let processedUsers = 0;
    let totalBadgesAwarded = 0;
    const errors: string[] = [];

    for (const user of activeUsers) {
      try {
        const earnedBadges = await this.checkAndAwardBadges(user.id);
        totalBadgesAwarded += earnedBadges.length;
        processedUsers++;

        if (earnedBadges.length > 0) {
          console.log(`ğŸ‘¤ ${user.name}: ${earnedBadges.length}ê°œ ë°°ì§€ íšë“`);
        }
      } catch (error) {
        const errorMessage = `ì‚¬ìš©ì ${user.name} (${user.id}) ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ${error}`;
        console.error(`âŒ ${errorMessage}`);
        errors.push(errorMessage);
      }
    }

    const processingTime = Date.now() - startTime;
    console.log(`âœ… ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ: ${processedUsers}ëª… ì²˜ë¦¬, ${totalBadgesAwarded}ê°œ ë°°ì§€ ë¶€ì—¬ (${processingTime}ms)`);

    return {
      processedUsers,
      totalBadgesAwarded,
      errors,
      processingTime,
    };
  }

  /**
   * ë‹µë³€ ì±„íƒ ì‹œ ì „ë¬¸ê°€ í¬ì¸íŠ¸ ì§€ê¸‰
   *
   * @param userId - ë‹µë³€ ì‘ì„±ì ID
   * @param badgeCode - ë°°ì§€ ì½”ë“œ
   * @returns ì§€ê¸‰ëœ í¬ì¸íŠ¸
   */
  async awardExpertPoints(userId: string, badgeCode: string): Promise<ExpertPointsResult> {
    const badge = await this.badgeRepository.findByCode(badgeCode);
    if (!badge || !badge.adoptBonusPoints) {
      return {
        userId,
        badgeCode,
        pointsAwarded: 0,
        totalPoints: 0,
      };
    }

    // ì‚¬ìš©ìê°€ í•´ë‹¹ ë°°ì§€ë¥¼ ë³´ìœ í•˜ê³  ìˆëŠ”ì§€ í™•ì¸
    const userBadge = await this.badgeRepository.getUserBadgeByCode(userId, badgeCode);
    if (!userBadge?.earnedAt) {
      return {
        userId,
        badgeCode,
        pointsAwarded: 0,
        totalPoints: 0,
      };
    }

    // í¬ì¸íŠ¸ ì§€ê¸‰ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” PointService ì‚¬ìš©)
    const updatedUser = await (this.badgeRepository as any).prisma.user.update({
      where: { id: userId },
      data: {
        points: {
          increment: badge.adoptBonusPoints,
        },
      },
      select: { points: true },
    });

    console.log(`ğŸ’° ì „ë¬¸ê°€ í¬ì¸íŠ¸ ì§€ê¸‰: ${userId}ì—ê²Œ ${badge.adoptBonusPoints}í¬ì¸íŠ¸ (${badge.name})`);
    
    return {
      userId,
      badgeCode,
      pointsAwarded: badge.adoptBonusPoints,
      totalPoints: updatedUser.points,
    };
  }

  /**
   * ë°°ì§€ ìƒì„± (ê´€ë¦¬ììš©)
   *
   * @param data - ë°°ì§€ ìƒì„± ë°ì´í„°
   * @returns ìƒì„±ëœ ë°°ì§€
   */
  async createBadge(data: any) {
    return await this.badgeRepository.create(data);
  }

  /**
   * ë°°ì§€ ìˆ˜ì • (ê´€ë¦¬ììš©)
   *
   * @param badgeId - ë°°ì§€ ID
   * @param data - ìˆ˜ì • ë°ì´í„°
   * @returns ìˆ˜ì •ëœ ë°°ì§€
   */
  async updateBadge(badgeId: string, data: any) {
    return await this.badgeRepository.update(badgeId, data);
  }


  /**
   * ì‚¬ìš©ì ë°°ì§€ ì§„í–‰ë¥  ì¡°íšŒ
   *
   * @param userId - ì‚¬ìš©ì ID
   * @returns ë°°ì§€ ì§„í–‰ë¥  ëª©ë¡
   */
  async getUserBadgeProgress(userId: string): Promise<UserBadgeProgress[]> {
    return await this.badgeRepository.getUserBadgeProgress(userId);
  }

  /**
   * ì „ì²´ ì‚¬ìš©ì ë°°ì§€ ê³„ì‚° (ê´€ë¦¬ììš©)
   *
   * @returns ë°°ì§€ ê³„ì‚° ê²°ê³¼
   */
  async calculateAllUserBadges(): Promise<{
    totalProcessed: number;
    badgesAwarded: number;
    errors: string[];
    processingTime: number;
  }> {
    const startTime = Date.now();
    let totalProcessed = 0;
    let badgesAwarded = 0;
    const errors: string[] = [];

    try {
      // ëª¨ë“  í™œì„± ì‚¬ìš©ì ì¡°íšŒ
      const users = await this.badgeRepository.findActiveUsers();
      
      for (const user of users) {
        try {
          const results = await this.checkAndAwardBadges(user.id);
          badgesAwarded += results.length;
          totalProcessed++;
        } catch (error) {
          errors.push(`ì‚¬ìš©ì ${user.id} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ${error}`);
        }
      }
    } catch (error) {
      errors.push(`ì „ì²´ ë°°ì§€ ê³„ì‚° ì¤‘ ì˜¤ë¥˜: ${error}`);
    }

    const processingTime = Date.now() - startTime;

    return {
      totalProcessed,
      badgesAwarded,
      errors,
      processingTime,
    };
  }

  /**
   * ë°°ì§€ ì‹œìŠ¤í…œ í†µê³„ ì¡°íšŒ (ê´€ë¦¬ììš©)
   *
   * @param days - í†µê³„ ê¸°ê°„ (ì¼)
   * @returns ë°°ì§€ ì‹œìŠ¤í…œ í†µê³„
   */
  async getBadgeSystemStats(days: number = 30): Promise<{
    totalUsers: number;
    totalBadges: number;
    totalUserBadges: number;
    averageBadgesPerUser: number;
    badgeDistribution: Array<{
      badgeId: string;
      badgeName: string;
      userCount: number;
      percentage: number;
    }>;
    recentActivity: Array<{
      date: string;
      badgesEarned: number;
      newUsers: number;
    }>;
  }> {
    return await this.badgeRepository.getBadgeSystemStats(days);
  }

  /**
   * ë°°ì§€ ë¹„í™œì„±í™” (ê´€ë¦¬ììš©)
   *
   * @param badgeId - ë°°ì§€ ID
   * @returns ë¹„í™œì„±í™”ëœ ë°°ì§€
   */
  async deactivateBadge(badgeId: string) {
    return await this.badgeRepository.update(badgeId, { isActive: false });
  }

  /**
   * ìˆ˜ë™ ë°°ì§€ ë¶€ì—¬ (ê´€ë¦¬ììš©)
   *
   * @param userId - ì‚¬ìš©ì ID
   * @param badgeId - ë°°ì§€ ID
   * @returns ë¶€ì—¬ëœ ì‚¬ìš©ì ë°°ì§€
   */
  async awardBadge(userId: string, badgeId: string) {
    return await this.badgeRepository.awardBadge(userId, badgeId);
  }
}