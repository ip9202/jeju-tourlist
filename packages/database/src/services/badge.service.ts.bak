/**
 * 배지 시스템 서비스 (개선된 버전)
 *
 * @description
 * - 배지 계산, 부여, 관리 로직
 * - SOLID 원칙 중 SRP(단일 책임 원칙) 및 DIP(의존성 역전 원칙) 준수
 * - 배지 조건 검증 및 자동 부여 시스템
 * - 배치 처리 및 통계 분석
 *
 * @author 동네물어봐 개발팀
 * @version 2.0.0
 */

import { PrismaClient } from "@prisma/client";
import { IBadgeRepository } from "../repositories/badge.repository";
import { BadgeRepository } from "../repositories/badge.repository.impl";
import {
  BadgeCalculationResult,
  UserBadgeProgress,
  BadgeStats,
  BatchProcessResult,
  ExpertPointsResult,
} from "../types/badge";

/**
 * 배지 시스템 서비스
 */
export class BadgeService {
  private badgeRepository: IBadgeRepository;

  constructor(prisma: PrismaClient) {
    this.badgeRepository = new BadgeRepository(prisma);
  }

  /**
   * 사용자 배지 자격 검사 및 자동 부여
   *
   * @param userId - 사용자 ID
   * @returns 부여된 배지 목록
   */
  async checkAndAwardBadges(userId: string): Promise<BadgeCalculationResult[]> {
    console.log(`🔍 사용자 ${userId}의 배지 자격 검사 시작...`);

    // 모든 활성 배지 조회
    const badges = await this.badgeRepository.findMany({ isActive: true });
    const earnedBadges: BadgeCalculationResult[] = [];

    for (const badge of badges) {
      try {
        // 이미 획득한 배지인지 확인
        const existingUserBadge = await this.badgeRepository.getUserBadgeById(userId, badge.id);
        if (existingUserBadge?.earnedAt) {
          continue;
        }

        // 배지 자격 검증
        const eligibility = await this.badgeRepository.checkBadgeEligibility(userId, badge.id);

        if (eligibility.isEligible) {
          // 배지 부여
          await this.badgeRepository.awardBadge(userId, badge.id);

          earnedBadges.push({
            badgeId: badge.id,
            badgeCode: badge.code,
            badgeName: badge.name,
            isEarned: true,
            progress: eligibility.progress,
            maxProgress: eligibility.maxProgress,
            message: eligibility.message,
            points: badge.bonusPoints,
          });

          console.log(`✅ 배지 부여: ${badge.emoji} ${badge.name} (${badge.bonusPoints}포인트)`);
        }
      } catch (error) {
        console.error(`❌ 배지 ${badge.name} 검사 중 오류:`, error);
      }
    }

    console.log(`🎉 총 ${earnedBadges.length}개의 배지를 부여했습니다.`);
    return earnedBadges;
  }

  /**
   * 사용자 배지 통계 조회
   *
   * @param userId - 사용자 ID
   * @returns 배지 통계 정보
   */
  async getUserBadgeStats(userId: string): Promise<BadgeStats> {
    const stats = await this.badgeRepository.getBadgeStats(userId);
    return {
      ...stats,
      completionRate: stats.totalBadges > 0 ? (stats.earnedBadges / stats.totalBadges) * 100 : 0,
    };
  }

  /**
   * 특정 배지의 획득 가능한 사용자 목록 조회
   *
   * @param badgeId - 배지 ID
   * @returns 획득 가능한 사용자 ID 목록
   */
  async getEligibleUsersForBadge(badgeId: string): Promise<string[]> {
    return await this.badgeRepository.findEligibleUsersForBadge(badgeId);
  }

  /**
   * 배치 처리: 모든 사용자의 배지 자격 검사
   *
   * @returns 처리 결과 통계
   */
  async batchProcessAllUsers(): Promise<BatchProcessResult> {
    console.log("🔄 배지 배치 처리 시작...");
    const startTime = Date.now();

    const activeUsers = await (this.badgeRepository as any).prisma.user.findMany({
      where: { isActive: true },
      select: { id: true, name: true },
    });

    let processedUsers = 0;
    let totalBadgesAwarded = 0;
    const errors: string[] = [];

    for (const user of activeUsers) {
      try {
        const earnedBadges = await this.checkAndAwardBadges(user.id);
        totalBadgesAwarded += earnedBadges.length;
        processedUsers++;

        if (earnedBadges.length > 0) {
          console.log(`👤 ${user.name}: ${earnedBadges.length}개 배지 획득`);
        }
      } catch (error) {
        const errorMessage = `사용자 ${user.name} (${user.id}) 처리 중 오류: ${error}`;
        console.error(`❌ ${errorMessage}`);
        errors.push(errorMessage);
      }
    }

    const processingTime = Date.now() - startTime;
    console.log(`✅ 배치 처리 완료: ${processedUsers}명 처리, ${totalBadgesAwarded}개 배지 부여 (${processingTime}ms)`);

    return {
      processedUsers,
      totalBadgesAwarded,
      errors,
      processingTime,
    };
  }

  /**
   * 답변 채택 시 전문가 포인트 지급
   *
   * @param userId - 답변 작성자 ID
   * @param badgeCode - 배지 코드
   * @returns 지급된 포인트
   */
  async awardExpertPoints(userId: string, badgeCode: string): Promise<ExpertPointsResult> {
    const badge = await this.badgeRepository.findByCode(badgeCode);
    if (!badge || !badge.adoptBonusPoints) {
      return {
        userId,
        badgeCode,
        pointsAwarded: 0,
        totalPoints: 0,
      };
    }

    // 사용자가 해당 배지를 보유하고 있는지 확인
    const userBadge = await this.badgeRepository.getUserBadgeByCode(userId, badgeCode);
    if (!userBadge?.earnedAt) {
      return {
        userId,
        badgeCode,
        pointsAwarded: 0,
        totalPoints: 0,
      };
    }

    // 포인트 지급 (실제 구현에서는 PointService 사용)
    const updatedUser = await (this.badgeRepository as any).prisma.user.update({
      where: { id: userId },
      data: {
        points: {
          increment: badge.adoptBonusPoints,
        },
      },
      select: { points: true },
    });

    console.log(`💰 전문가 포인트 지급: ${userId}에게 ${badge.adoptBonusPoints}포인트 (${badge.name})`);
    
    return {
      userId,
      badgeCode,
      pointsAwarded: badge.adoptBonusPoints,
      totalPoints: updatedUser.points,
    };
  }

  /**
   * 배지 생성 (관리자용)
   *
   * @param data - 배지 생성 데이터
   * @returns 생성된 배지
   */
  async createBadge(data: any) {
    return await this.badgeRepository.create(data);
  }

  /**
   * 배지 수정 (관리자용)
   *
   * @param badgeId - 배지 ID
   * @param data - 수정 데이터
   * @returns 수정된 배지
   */
  async updateBadge(badgeId: string, data: any) {
    return await this.badgeRepository.update(badgeId, data);
  }


  /**
   * 사용자 배지 진행률 조회
   *
   * @param userId - 사용자 ID
   * @returns 배지 진행률 목록
   */
  async getUserBadgeProgress(userId: string): Promise<UserBadgeProgress[]> {
    return await this.badgeRepository.getUserBadgeProgress(userId);
  }

  /**
   * 전체 사용자 배지 계산 (관리자용)
   *
   * @returns 배지 계산 결과
   */
  async calculateAllUserBadges(): Promise<{
    totalProcessed: number;
    badgesAwarded: number;
    errors: string[];
    processingTime: number;
  }> {
    const startTime = Date.now();
    let totalProcessed = 0;
    let badgesAwarded = 0;
    const errors: string[] = [];

    try {
      // 모든 활성 사용자 조회
      const users = await this.badgeRepository.findActiveUsers();
      
      for (const user of users) {
        try {
          const results = await this.checkAndAwardBadges(user.id);
          badgesAwarded += results.length;
          totalProcessed++;
        } catch (error) {
          errors.push(`사용자 ${user.id} 처리 중 오류: ${error}`);
        }
      }
    } catch (error) {
      errors.push(`전체 배지 계산 중 오류: ${error}`);
    }

    const processingTime = Date.now() - startTime;

    return {
      totalProcessed,
      badgesAwarded,
      errors,
      processingTime,
    };
  }

  /**
   * 배지 시스템 통계 조회 (관리자용)
   *
   * @param days - 통계 기간 (일)
   * @returns 배지 시스템 통계
   */
  async getBadgeSystemStats(days: number = 30): Promise<{
    totalUsers: number;
    totalBadges: number;
    totalUserBadges: number;
    averageBadgesPerUser: number;
    badgeDistribution: Array<{
      badgeId: string;
      badgeName: string;
      userCount: number;
      percentage: number;
    }>;
    recentActivity: Array<{
      date: string;
      badgesEarned: number;
      newUsers: number;
    }>;
  }> {
    return await this.badgeRepository.getBadgeSystemStats(days);
  }

  /**
   * 배지 비활성화 (관리자용)
   *
   * @param badgeId - 배지 ID
   * @returns 비활성화된 배지
   */
  async deactivateBadge(badgeId: string) {
    return await this.badgeRepository.update(badgeId, { isActive: false });
  }

  /**
   * 수동 배지 부여 (관리자용)
   *
   * @param userId - 사용자 ID
   * @param badgeId - 배지 ID
   * @returns 부여된 사용자 배지
   */
  async awardBadge(userId: string, badgeId: string) {
    return await this.badgeRepository.awardBadge(userId, badgeId);
  }
}