/**
 * 보안 취약점 테스트
 *
 * @description
 * - OWASP Top 10 취약점에 대한 보안 테스트
 * - SQL Injection, XSS, CSRF 등 주요 보안 위협 테스트
 * - SRP: 각 테스트는 특정 보안 취약점만 검증
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from "@jest/globals";
import request from "supertest";
import { app } from "../../index";
import { prisma } from "@jeju-tourlist/database";
import { generateId } from "@jeju-tourlist/utils";

describe("Security Vulnerability Tests", () => {
  let testUser: any;
  let authToken: string;

  beforeAll(async () => {
    // 테스트 데이터베이스 초기화
    await prisma.answer.deleteMany();
    await prisma.question.deleteMany();
    await prisma.user.deleteMany();
    await prisma.userProfile.deleteMany();
  });

  afterAll(async () => {
    // 테스트 데이터 정리
    await prisma.answer.deleteMany();
    await prisma.question.deleteMany();
    await prisma.user.deleteMany();
    await prisma.userProfile.deleteMany();
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    // 각 테스트 전 데이터 정리
    await prisma.answer.deleteMany();
    await prisma.question.deleteMany();
    await prisma.user.deleteMany();
    await prisma.userProfile.deleteMany();

    // 테스트용 사용자 생성 및 로그인
    testUser = await prisma.user.create({
      data: {
        email: "security@example.com",
        name: "Security User",
        provider: "google",
        providerId: generateId(),
      },
    });

    const loginResponse = await request(app)
      .post("/api/auth/login")
      .send({
        email: "security@example.com",
        provider: "google",
        providerId: testUser.providerId,
      });

    authToken = loginResponse.body.data.token;
  });

  describe("SQL Injection Tests", () => {
    it("질문 검색에서 SQL Injection 공격을 방어해야 함", async () => {
      // Given - SQL Injection 페이로드
      const maliciousQuery = "'; DROP TABLE users; --";
      
      // When
      const response = await request(app)
        .get(`/api/questions/search?q=${encodeURIComponent(maliciousQuery)}`)
        .set("Authorization", `Bearer ${authToken}`)
        .expect(200);

      // Then - 정상적으로 처리되어야 함
      expect(response.body.success).toBe(true);
      expect(response.body.data.questions).toBeDefined();
      
      // 데이터베이스가 손상되지 않았는지 확인
      const userCount = await prisma.user.count();
      expect(userCount).toBeGreaterThan(0);
    });

    it("질문 필터링에서 SQL Injection 공격을 방어해야 함", async () => {
      // Given - SQL Injection 페이로드
      const maliciousFilter = "1' OR '1'='1";
      
      // When
      const response = await request(app)
        .get(`/api/questions?region=${encodeURIComponent(maliciousFilter)}`)
        .set("Authorization", `Bearer ${authToken}`)
        .expect(400); // 유효하지 않은 입력으로 인한 에러

      // Then - 에러가 발생해야 함
      expect(response.body.success).toBe(false);
    });

    it("사용자 프로필 수정에서 SQL Injection 공격을 방어해야 함", async () => {
      // Given - SQL Injection 페이로드
      const maliciousData = {
        name: "'; DROP TABLE questions; --",
        bio: "'; DELETE FROM users; --",
      };

      // When
      const response = await request(app)
        .put("/api/auth/profile")
        .set("Authorization", `Bearer ${authToken}`)
        .send(maliciousData)
        .expect(200);

      // Then - 정상적으로 처리되어야 함
      expect(response.body.success).toBe(true);
      
      // 데이터베이스가 손상되지 않았는지 확인
      const questionCount = await prisma.question.count();
      const userCount = await prisma.user.count();
      expect(questionCount).toBeGreaterThanOrEqual(0);
      expect(userCount).toBeGreaterThan(0);
    });
  });

  describe("XSS (Cross-Site Scripting) Tests", () => {
    it("질문 제목에서 XSS 공격을 방어해야 함", async () => {
      // Given - XSS 페이로드
      const xssPayload = "<script>alert('XSS')</script>";
      
      // When
      const response = await request(app)
        .post("/api/questions")
        .set("Authorization", `Bearer ${authToken}`)
        .send({
          title: xssPayload,
          content: "Test content",
          tags: ["test"],
          regionCode: "jeju_city",
        })
        .expect(201);

      // Then - 스크립트가 이스케이프되어야 함
      expect(response.body.success).toBe(true);
      expect(response.body.data.question.title).not.toContain("<script>");
      expect(response.body.data.question.title).toContain("&lt;script&gt;");
    });

    it("질문 내용에서 XSS 공격을 방어해야 함", async () => {
      // Given - XSS 페이로드
      const xssPayload = "<img src=x onerror=alert('XSS')>";
      
      // When
      const response = await request(app)
        .post("/api/questions")
        .set("Authorization", `Bearer ${authToken}`)
        .send({
          title: "Test Question",
          content: xssPayload,
          tags: ["test"],
          regionCode: "jeju_city",
        })
        .expect(201);

      // Then - 스크립트가 이스케이프되어야 함
      expect(response.body.success).toBe(true);
      expect(response.body.data.question.content).not.toContain("onerror");
      expect(response.body.data.question.content).toContain("&lt;img");
    });

    it("답변 내용에서 XSS 공격을 방어해야 함", async () => {
      // Given - 질문 생성
      const question = await prisma.question.create({
        data: {
          id: generateId(),
          title: "Test Question",
          content: "Test content",
          authorId: testUser.id,
          tags: ["test"],
          regionCode: "jeju_city",
          status: "active",
        },
      });

      const xssPayload = "<svg onload=alert('XSS')>";
      
      // When
      const response = await request(app)
        .post("/api/answers")
        .set("Authorization", `Bearer ${authToken}`)
        .send({
          questionId: question.id,
          content: xssPayload,
        })
        .expect(201);

      // Then - 스크립트가 이스케이프되어야 함
      expect(response.body.success).toBe(true);
      expect(response.body.data.answer.content).not.toContain("onload");
      expect(response.body.data.answer.content).toContain("&lt;svg");
    });
  });

  describe("CSRF (Cross-Site Request Forgery) Tests", () => {
    it("CSRF 토큰 없이 요청 시 실패해야 함", async () => {
      // Given - CSRF 토큰 없는 요청
      const questionData = {
        title: "CSRF Test Question",
        content: "CSRF test content",
        tags: ["test"],
        regionCode: "jeju_city",
      };

      // When & Then - CSRF 보호로 인한 실패
      const response = await request(app)
        .post("/api/questions")
        .set("Authorization", `Bearer ${authToken}`)
        .set("Origin", "https://malicious-site.com")
        .send(questionData)
        .expect(403);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("CSRF");
    });

    it("잘못된 Origin 헤더로 요청 시 실패해야 함", async () => {
      // Given - 잘못된 Origin 헤더
      const questionData = {
        title: "Origin Test Question",
        content: "Origin test content",
        tags: ["test"],
        regionCode: "jeju_city",
      };

      // When & Then - Origin 검증 실패
      const response = await request(app)
        .post("/api/questions")
        .set("Authorization", `Bearer ${authToken}`)
        .set("Origin", "https://attacker.com")
        .send(questionData)
        .expect(403);

      expect(response.body.success).toBe(false);
    });
  });

  describe("Authentication Bypass Tests", () => {
    it("유효하지 않은 JWT 토큰으로 요청 시 실패해야 함", async () => {
      // Given - 유효하지 않은 JWT 토큰
      const invalidToken = "invalid.jwt.token";

      // When & Then
      const response = await request(app)
        .get("/api/auth/me")
        .set("Authorization", `Bearer ${invalidToken}`)
        .expect(401);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("인증이 필요합니다");
    });

    it("만료된 JWT 토큰으로 요청 시 실패해야 함", async () => {
      // Given - 만료된 JWT 토큰 (실제로는 테스트용 만료 토큰 생성 필요)
      const expiredToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjF9.invalid";

      // When & Then
      const response = await request(app)
        .get("/api/auth/me")
        .set("Authorization", `Bearer ${expiredToken}`)
        .expect(401);

      expect(response.body.success).toBe(false);
    });

    it("권한이 없는 사용자가 다른 사용자 데이터에 접근 시 실패해야 함", async () => {
      // Given - 다른 사용자 생성
      const otherUser = await prisma.user.create({
        data: {
          email: "other@example.com",
          name: "Other User",
          provider: "google",
          providerId: generateId(),
        },
      });

      // When & Then - 다른 사용자 프로필 수정 시도
      const response = await request(app)
        .put(`/api/users/${otherUser.id}/profile`)
        .set("Authorization", `Bearer ${authToken}`)
        .send({ name: "Hacked User" })
        .expect(403);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("권한이 없습니다");
    });
  });

  describe("Input Validation Tests", () => {
    it("과도하게 긴 입력을 거부해야 함", async () => {
      // Given - 매우 긴 제목 (1000자 이상)
      const longTitle = "a".repeat(1001);

      // When & Then
      const response = await request(app)
        .post("/api/questions")
        .set("Authorization", `Bearer ${authToken}`)
        .send({
          title: longTitle,
          content: "Test content",
          tags: ["test"],
          regionCode: "jeju_city",
        })
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("제목이 너무 깁니다");
    });

    it("특수 문자가 포함된 입력을 안전하게 처리해야 함", async () => {
      // Given - 특수 문자가 포함된 입력
      const specialChars = "!@#$%^&*()_+{}|:<>?[]\\;'\",./";

      // When
      const response = await request(app)
        .post("/api/questions")
        .set("Authorization", `Bearer ${authToken}`)
        .send({
          title: `Test ${specialChars}`,
          content: `Content with ${specialChars}`,
          tags: ["test"],
          regionCode: "jeju_city",
        })
        .expect(201);

      // Then - 정상적으로 처리되어야 함
      expect(response.body.success).toBe(true);
      expect(response.body.data.question.title).toBeDefined();
      expect(response.body.data.question.content).toBeDefined();
    });

    it("빈 문자열 입력을 거부해야 함", async () => {
      // Given - 빈 제목
      const emptyTitle = "";

      // When & Then
      const response = await request(app)
        .post("/api/questions")
        .set("Authorization", `Bearer ${authToken}`)
        .send({
          title: emptyTitle,
          content: "Test content",
          tags: ["test"],
          regionCode: "jeju_city",
        })
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("제목은 필수입니다");
    });
  });

  describe("Rate Limiting Tests", () => {
    it("과도한 요청을 제한해야 함", async () => {
      // Given - Rate limit 설정 (테스트용으로 낮게 설정)
      const questionData = {
        title: "Rate Limit Test",
        content: "Rate limit test content",
        tags: ["test"],
        regionCode: "jeju_city",
      };

      // When - 연속으로 많은 요청 전송
      const promises = Array.from({ length: 20 }, () =>
        request(app)
          .post("/api/questions")
          .set("Authorization", `Bearer ${authToken}`)
          .send(questionData)
      );

      const responses = await Promise.all(promises);

      // Then - 일부 요청은 제한되어야 함
      const rateLimitedResponses = responses.filter(
        res => res.status === 429
      );
      expect(rateLimitedResponses.length).toBeGreaterThan(0);
    });
  });

  describe("File Upload Security Tests", () => {
    it("위험한 파일 확장자를 거부해야 함", async () => {
      // Given - 위험한 파일 확장자
      const maliciousFile = {
        name: "malicious.exe",
        type: "application/x-msdownload",
        content: "malicious content",
      };

      // When & Then
      const response = await request(app)
        .post("/api/upload")
        .set("Authorization", `Bearer ${authToken}`)
        .attach("file", Buffer.from(maliciousFile.content), maliciousFile.name)
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("허용되지 않는 파일 형식");
    });

    it("과도하게 큰 파일을 거부해야 함", async () => {
      // Given - 매우 큰 파일 (10MB 이상)
      const largeFile = Buffer.alloc(11 * 1024 * 1024); // 11MB

      // When & Then
      const response = await request(app)
        .post("/api/upload")
        .set("Authorization", `Bearer ${authToken}`)
        .attach("file", largeFile, "large-file.jpg")
        .expect(413);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("파일 크기가 너무 큽니다");
    });
  });

  describe("Information Disclosure Tests", () => {
    it("에러 메시지에 민감한 정보가 노출되지 않아야 함", async () => {
      // Given - 존재하지 않는 사용자 ID
      const nonExistentUserId = generateId();

      // When
      const response = await request(app)
        .get(`/api/users/${nonExistentUserId}`)
        .set("Authorization", `Bearer ${authToken}`)
        .expect(404);

      // Then - 데이터베이스 구조나 내부 정보가 노출되지 않아야 함
      expect(response.body.message).not.toContain("SELECT");
      expect(response.body.message).not.toContain("FROM");
      expect(response.body.message).not.toContain("WHERE");
      expect(response.body.message).not.toContain("prisma");
    });

    it("스택 트레이스가 노출되지 않아야 함", async () => {
      // Given - 잘못된 요청
      const invalidData = { invalid: "data" };

      // When
      const response = await request(app)
        .post("/api/questions")
        .set("Authorization", `Bearer ${authToken}`)
        .send(invalidData)
        .expect(400);

      // Then - 스택 트레이스가 응답에 포함되지 않아야 함
      expect(response.body.stack).toBeUndefined();
      expect(response.body.error).toBeUndefined();
    });
  });
});
